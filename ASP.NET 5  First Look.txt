
ASP.NET 5: First Look
by Scott Allen

An early look at the major changes in ASP.NET 5, which includes ASP.NET MVC 6.

Start CourseBookmarkLive mentoring
Table of contents
Description
Transcript
Exercise files
Discussion
Learning Check
Recommended
Projects and Runtimes

An Introduction

Hi. This is Scott Allen, and this module is a first look at ASP.NET 5 and Visual Studio 2015. I'll be using pre-released software in this course, software that might change its look, its feel, and its functionality, but the overarching goal of this course is to give you the big picture of ASP.NET 5, how it works, what's good, what's bad, everything so that you can be prepared to know what will happen with your applications when you make the move. In this first module, we'll be looking at the new runtime, the new environment, and the new project structure for ASP.NET applications because this is one area that has significant changes. And in the next clip I want to talk about the three major changes that you need to be prepared for in moving to ASP.NET 5.

The Big Three Changes

From a wide perspective, here are the top three facts to know about ASP.NET 5. First, there is a new project and configuration system for building ASP.NET applications. Projects are now based on the file system, so all you need to do to add something to a project, like a new C# source code file, is just to place that file in the right directory. This new system is somewhat similar to the ASP.NET website model introduced in Visual Studio 2005 in the sense that the file system is your project and everything inside builds dynamically. So you can edit a source code file like an MVC controller, save the file, refresh the browser, and the build just happens behind the scenes. This is all thanks to the new Roslyn compiler, which I talk about in my C# 6 course. Roslyn allows for a fast compilation where the assemblies are held in memory so we don't have a lot of churn in a temporary ASP.NET directory, and that it allows for a faster build and a faster refresh. The project structure itself is dramatically different from what we've had in the past. We will take a look at these features in both this module and the next. If you're wondering why the project structure is so different, what forced this change, partly it is because the change makes it easier to deploy an application just by cloning a source code repository, but it's also different because of the second fact about ASP.NET 5. The second fact is that we all know Microsoft is focused on cloud services and devices these days, and to enhance the cloud experience we will now have two different flavors of the .NET runtime to choose from. Although we will still have the full .NET runtime to work with in Visual Studio 2015, .NET 4.5.1, that's the runtime we've always loved, there is also a new .NET runtime that is optimized for the cloud, or we could really say for the server. It's called the CoreCLR. So all the pieces from the JIT compiler to the garbage collector to the runtime itself, they are all packaged and designed with the idea of creating fast startup, high throughput, low memory applications. And an application can now have this cloud-optimized framework embedded with the application. That makes it easier to have true side-by-side versioning. And by embedded, I mean you can deploy the .NET Framework by copying a NuGet package. That's amazing. This cloud-optimized framework does come with a cost because it is significantly smaller and lighter than the full .NET Framework, so there might be some types that you depend on that will be missing, but you can always use the full .NET Framework. And on the plus side, with the CoreCLR, the cloud-optimized framework, this framework will even work on Linux and OS X. We'll be looking in more detail at the new runtime in this module. And finally, the third fact about ASP.NET 5 is that there has been a unification and a streamlining of the frameworks inside. The Web API framework has merged with ASP.NET MVC. This is ASP.NET MVC 6. That's what ships with ASP.NET 5. And with this merge we now only have one base controller class, one set of attributes, one set of model binders, and so on, so the frameworks are conceptually simpler. And also, when I talk about streamlining, I also mean that the frameworks are a little more lean under the covers. ASP.NET MVC no longer relies on the System.Web assembly. That means it's easy to self host and also run on the CoreCLR. And we still have an object that represents the HTTP context, but that context now carries something like 2 KB of overhead for every request unlike the old System.Web HTTP context that required at least 30 KB per request. Now if all of these changes sound scary and you're worried that you won't be able to work with your existing applications in VS 2015, don't worry. Those applications are still supported. My website is built with ASP.NET 5 and Web API 2, and all those technologies from the previous release of ASP.NET I can open and edit and build that application plus several others with no problems. What I won't be able to do without some migration work is take advantage of the new project layout or run with the cloud-optimized CoreCLR. But now that we know about some of the overarching goals and changes in ASP.NET 5, let's dig in to start looking at some details.

Files and Compilation

Here we are in a CTP release of Visual Studio 2015. Let's use File, New, Project, and see what happens. I want a Web application, specifically an ASP.NET Web Application. Let's call this FirstLook. And when I press OK, the dialog that appears should look somewhat familiar. This is where I can choose a template to start the project. The contents of this dialog will probably change by release, but I've been told the dialog should contain some of the templates that we're already familiar with from Visual Studio 2013, the Web Forms template, Empty template, Web API template, Single Page Application template. All of these will produce the traditional ASP.NET projects with the structure and behavior that we're accustomed to in previous releases. What we want to look at is the ASP.NET 5 template, one of these two, because these will use the new project structure that we want to look at. I'm going to choose the Starter template because this template uses ASP.NET 5 and gives me an application with the usual home controller and account controller. It allows the user to register and log in, and that means behind the scenes it's going to be using the Entity Framework and the ASP.NET Identity Framework to build a membership system for me. So I'll click OK. I need to give Visual Studio some time to create this project, and then we'll take a look at the application running. The project is ready. The readme file is on the screen. Let's press Ctrl+F5 to see what sort of application this has produced. And what we see is your typical starting MVC application. There are links to an About page. That's at /Home/About. There's also /Home/Contact. And if I wanted to, I could click the Register link, fill out some user information, and register myself on the site. So far everything should look familiar. But now let's look at the project structure in the Solution Explorer window. The first thing I want to point out is that the structure of the solution will exactly match the layout of files on my PC. So this is the folder for FirstLook. It contains a solution file. You'll notice there's a src folder in Solution Explorer. That's where the FirstLook project is. Indeed if I drill into src, there's FirstLook, and there are folders that appear in Solution Explorer. Now some of the folders that are disk do not appear in this Solution Explorer window. We'll talk about those later. But let me create a New Folder here. Let's call it doc or docs, and inside of docs I'm going to create a New Text Document called readme. And if we come over into the Solution Explorer window, you can see those files are already there. So traditionally in an ASP.NET project if I wanted to get a file into that project, even if it was just a simple text file, if it was going to appear in the Solution Explorer window, I would have to add it by right- clicking and saying Add Item. But ASP.NET 5, it's significantly different. The file system is my project. And that's true even for compiled files. Essentially, the way ASP.NET 5 will be configured by default is that the runtime will be looking for anything under the src folder for compilable artifacts. Let me give you an example. Let's swing out back into the browser and try to go to /hello. We have the default routing rules that you would expect working in this application. So ASP.NET MVC is going to look for a hello controller and not find that controller, so we will get a 404 Not Found response. So let me with the command line come into the FirstLook\src\FirstLook project Controllers folder, and let's create a file Hello.cs. Inside of here we will be using Microsoft.AspNet.Mvc. We'll probably want our code inside of here to be in a namespace. Let's call it FirstLook.Controllers. And I want a class HelloController that derives from a base Controller class just as we've always done in the past, and I want this to have an Index action that's just going to return a string, which is something we've always been able to do with ASP.NET MVC. It will essentially just take that string and send it back down to the client browser, and I will say Hello, World! And you might be wondering why I'm doing this all in Notepad. Well, I'm doing this because I just want to show you that I can create this file, save it to disk, refresh my browser, and it all just works. So this is the dynamic compilation feature of ASP.NET 5. I don't need to add that CS file to a project file like I did in previous versions. I just need to have it on disk. One thing I'm really looking forward to with this release of ASP.NET is that I will no longer have to manage merge conflicts with a project file because both myself and three other developers have added new files to a project. This new system will also make it easier to deploy web applications just by cloning a source code repository. All of the compilation will just happen dynamically. Once the source code is on the web server, everything should just work. I don't have to worry about finding a way to build C# code and controllers once the files are on the server. So now we know that we have a project system that is based on the file system, and we have dynamic compilation. What else is different? The files that you will find inside of the project are different. We'll take a look at this in the next clip.

The wwwroot Folder

This new ASP.NET 5 project we're looking at, we know we have controllers now in this project, and I can also show you that we have razor views with the cshtml extension. So you don't have to reprogram your brain to work with ASP.NET 5, at least not reprogram it completely. There are many concepts that carry forward, controllers, models, views, a separation of concerns, and staying close to CSS, HTML, and JavaScript. All those concepts are still here. But there are also some significant changes to be aware of in ASP.NET 5. The team at Microsoft continues to borrow ideas from other web communities like the Rails community and the Node.js community. Some examples include the project layout and configuration. We'll get to configuration later, but for now know that the root of the website is no longer the root of the project. By default, a root is this wwwroot folder, what some might call dub, dub, dub root. The idea is to create a clean separation between the files that the web server will retrieve and send to the client and the files that contain the logic and configuration for the application. Static files like JavaScript files, CSS files, images, HTML files, these are all static assets for a website that can live in wwwroot. For example, you'll see here is a css folder inside of wwwroot, and inside of that it's the site.css file. And if we swing over and look at the _Layout view for the application, the view that all the content views plug into, this file references site.css just by going to the top-level folder, tilde, then into css, and then asking for site.css just like Bootstrap css file is in lib/bootstrap/css. And again, that is something that we can see in the lib folder that is under wwwroot. Now we'll talk about how some of these files arrive in this location later in this course, but it is important to know that the website it is rooted in wwwroot. That is optional. You can name this folder whatever you like. It's configurable, and you can also choose not to use it. If you want the app rooted at the root of the project, you can, but you have to also be very careful not to accidentally serve up a configuration file to the user. But just to prove my point, let's go and edit the readme file that we created earlier in the docs folder. I'll just put in here the word Readme and save this file. And currently this file is outside of the root folder, so the browser has no way to see this file. If I try to go to docs/readme.txt, I will get a 404 Not Found error. But if I take this folder and I move it or copy it to the root folder, now I should be able to come back out to the browser and refresh, and there's my Readme file. So again, this root folder is for static assets. ASP.NET MVC views, they're still compiled into executable code, so they can live outside of this folder. They can live in the Views folder or wherever you have them configured. But speaking of executable code, notice that the bin folder for the site is in the wwwroot folder. That's exactly what we'd expect with ASP.NET. That's what we've always worked with. We're accustomed to having a bin folder for binaries underneath the website root, and that is where web servers like IIS Express look for the code to load up to execute the site. But what is the magic that tells ASP.NET 5 where the root of this website should live? Well, you might expect a configuration file, and you would be correct. But if you go looking for a web.config file, you'll notice there is no web.config file in this project. In fact, there are a number of files that we've become accustomed to that don't exist. For instance, global.asax. That's been replaced with a Startup.cs file. More details on that later also. Instead, what I want to focus on next is this project.json file. This file now manages many aspects and behavioral characteristics of the website. One of the first items that you'll notice here is a webroot setting that points to wwwroot. This is where you could change the name of that folder if you so desire. You could call the folder public or assets or remove it entirely. But this configuration file, which is using JSON format, JavaScript object notation, this is also telling the ASP.NET runtime what else this project needs to execute, what third-party code, what NuGet packages, what other assemblies, so let's talk about that next.

The project.json File

In this new world of ASP.NET 5, there is a new way to manage dependencies. No longer do we reference assemblies and store the list of referenced assemblies in a C# project file. Instead, we refer to NuGet packages as dependencies, and these dependencies are listed in our project.json file. There are a few reasons for this change. One reason is to simplify dependency management. You'll see how simple this approach is, and eventually in the future it looks like everything will be a package. Even the CLR can be deployed as a package. Another reason for this change is that ASP.NET is moving away from requiring Visual Studio or Windows or GUI tools to mange and build ASP.NET projects. All I need to make an ASP.NET app is a text editor like Notepad, but hopefully you'll pick something with more features than Notepad, maybe an editor like Sublime or Atom or Vim if you go that route, or develop on a Linux system. In this JSON file, you can see this project has dependencies. It has dependencies on the EntityFramework, on AspNet.Mvc, on AspNet.Identity, and numerous other packages. If a NuGet package exists that contains a feature that I want to use, I have two options. I can still right-click on a project and Manage NuGet Packages. Notice now we have a nicer UI to manage packages, and we aren't stuck with the terrible modal dialog that we had before. I can still filter this list to just the packages that I have installed. This should reflect exactly the dependencies that are in my project.json file. But from here I can also go out to remote NuGet sources and search for packages just like I did in the past. I can even configure NuGet options to search for packages from nuget.org or MyGet or local directory or my own private NuGet feed or file share. So let's say I'm planning to use some Windows Azure blob storage. I might want to go out and search for windowsazure and find the SDK or the Storage package. And once that appears here, I could select that package. I could select the version that I want. And when I click Install, a reference to that package would go into my project.json file. But I can also edit this project.json file directly. I can even have IntelliSense in here. So let's say I want to get to the WindowsAzure.Storage package. You can see it appears here in the IntelliSense window. This can even go out and search for remote NuGet packages with a string. But I will select Storage, and then I have the option of either not specifying a version, which means I always want to run with the latest version. If you're a little bit paranoid, you can also use the IntelliSense to help you select a version. Perhaps we want to go with the latest version. And now all I have to do is save this project.json file, and magic will happen. But before I do that, I do want to point out that the packages I'll reference in project.json will almost always be 100% .NET packages. So in previous releases we used to use NuGet to manage packages for client-side libraries like jQuery and frontend frameworks like Bootstrap, but with ASP.NET 5 there's a different tool that's integrated into Visual Studio for managing those types of frontend libraries. We'll look at it in the last module of this course. But now I'm going to save the file, and I want you to watch the References node here in Visual Studio when I click Save. You can see it says Restoring. It's going to go out and check what it has downloaded and associate it with this project versus any changes I made in project.json. Right now it should be going out and fetching that WindowsAzure.Storage package and bringing it down. And once that is complete, I want to show you that I can drill into this References node. And there are actually a couple things I want to talk about at this point. We do at some point need to discuss where these packages are stored because it's not like it used to be in the past where all the downloaded NuGet packages went into a packages folder for the solution. That has changed. But before we get to that, I want to address what we're seeing inside of References. I can see there's ASP.NET 5.0, ASP.NET Core 5.0. These are the two different runtimes that I can use, the full CLR versus the cloud-optimized CoreCLR. That's what we're going to talk about next. But I do want to show you if I drill into either of these I will be able to find WindowsAzure.Storage. This UI is listing my top level dependencies. So essentially everything I see in project.json like EntityFramework.SqlServer and EntityFramework.Commands, I will see them as top level nodes underneath the appropriate runtime. And then of course these packages might depend on other packages like the EntityFramework.SqlServer package depends on EntityFramework.Migrations, which depends on mscorlib. But what I'm getting is a nice simplified view of my dependencies, just what are the top level things that I need, and the dependency management system is just going to figure out everything else that that particular package need and make sure that it's brought into the project. But why do I have these two nodes, ASP.NET 5 and ASP.NET Core 5? Let's talk about these different runtimes next.

Frameworks and Runtimes

As I mentioned at the beginning of this course, our ASP.NET foundation is splitting into multiple runtimes. There's the full .NET Framework on one side and the cloud-optimized framework known as .NET Core on the other side. Inside of our project.json file, there is a list of frameworks that our project will support and build against. So every time our source code compiles, ASP.NET will make sure it works against both of the frameworks listed here. Aspnet50 is the identifier for the full .NET Framework. This will give me everything in the .NET Framework with ASP.NET 5 while aspnetcore50 is the CoreCLR. This is the streamlined cloud-optimized framework that is about a tenth the size of the full .NET Framework, which means some pieces are missing. So you might be wondering well which framework here are we actually running against? I'll tell you the answer in just a bit. For now, just know that since I have both of these listed here, as long as my application compiles successfully, I have a choice, and I can run against either framework. I can choose the full CLR or the CoreCLR. For right now, I just want to focus n the build and runtime behavior of the two. So first of all, since both frameworks are listed here, we will be building against both frameworks. By building against both with every compile cycle, we can be sure that the application will actually work against both frameworks. If you've ever been on a project that targets multiple platforms, you've probably had the experience of checking in code that works fine in development, but something fails on the build server for a different platform configuration. That means you develop, and you end up switching platform targets all the time to catch any errors. ASP.NET 5 just takes care of that for us automatically. Whenever we save a file, there will be a background build against both frameworks to make sure things work. So let me give you an example. Let's go back to the Hello controller that we were working with. It currently just displays Hello, World! Well, let's modify that controller. That was in the Controllers folder. We created it with Notepad, but now I want to edit it with Visual Studio. I also want to rename it so it follows the proper naming conventions. And let's open that up. And instead of displaying Hello, World, let's return Assembly from the System.Reflection namespace .GetExecutingAssembly. And I want to show the FullNname of that assembly, so just save this file and refresh. And that appears to be working. I see there is an assembly called FirstLook. It's version 1. Everything looks good. But let's look at the Output window, and I can actually see that there is one error listed here. That error is because when we compiled against the CoreCLR the GetExecutingAssembly API was missing. So the CoreCLR just does not contain all of the same APIs that the full .NET Framework has. So I'm building with an error, but the application is working just fine because there is no problem running it against the full CLR. If I decide that supporting the CoreCLR is not something that I want to do, I can just come in here and comment this out, save the file, watch my References refresh. We drop the reference to the CoreCLR. Let me do an explicit build again with a Shift+Ctrl+B, and now I can see that I build successfully, and the application should still be running just fine. Well, let's turn this scenario around. Let's say I do want to support ASP.NET Core. what are my options? Well, in that case let me place everything back here, save the JSON file. We're going to bring the CoreCLR back in. And I want to go to HelloController and just show you that when I go to GetExecutingAssembly you'll notice the little warning icon here in the IntelliSense window. It's not there for equals, but it's here for most of the API. And what this pop-up is telling me is that for the full CLR GetExecutingAssembly is available; for the CoreCLR it is not. So the IntelliSense windows are trying to help me out with this situation before I even get to a build. And this might be one of the scenarios where it could become useful to use compiler directives, the C# preprocessor directives that start with a pound sign. Essentially in my project.json, when this application is being built, there will be some specific symbols defined for each different build. When I'm building against the full CLR, there will be a pound defined for aspnet50, and when I'm building against the CoreCLR, there will be a pound defined for aspnetcore50. That means inside of my HelloController I could have something like if ASPNET50, and these are capitalized when the system defines them, and place and endif, and I could also have a #if for ASPNETCORE50 with an endif. And here perhaps we could do something like let's get the type of HelloController and return its AssemblyQualifiedName, which will include the assembly name. And now if I save that controller, I can come over to the browser, I can refresh, and that's working. You'll also notice that I have no build errors. So that gives us a clue that by default we're running against the full CLR. What if I want to run against the CoreCLR? Let's take a look at that next.

The Letter K

To understand what we're going to see next, we have to understand that ASP.NET 5 has to provide a runtime environment for our application, and this runtime environment has to have the ability to load up the correct version of the CLR and essentially boot the CLR. To manage these different runtimes, ASP.NET provides the K Runtime Environment, or the KRE. If you're wondering what the K stands for, all we know is that the code name for this version of ASP.NET was Project K, but beyond that you'll have to draw your own conclusions for the significance of the letter K. In this rest of this module and in this course we're going to see several tools and folders prefixed with the letter K, but for now I just want you to know when you see KRE think K Runtime Environment. It is the KRE that loads up the proper CLR into our application's app domain. Let's go to the project Properties for our FirstLook application. And if I look at what's available on this Application tab, I can see that our target K Runtime Environment is KRE-CLR-x86 beta2. This tells me I am running against the full .NET Framework for x86 processors, and this KRE is beta2. But I can also find in this dropdown list a KRE-CoreCLR, which will load the CoreCLR. So let's select the CoreCLR. I'm going to save the project properties. I'm also going to come out and stop IIS Express. So this is IIS Express running in the system tray. If I right-click, I can close that process. And we've been using IIS Express for the last several versions of ASP.NET and Visual Studio. It's essentially a stripped down version of IIS that runs under my user account. ASP.NET 5 is no different that way. We can still host things in IIS or IIS Express. Now let me also put a breakpoint here inside of our HelloController, and let's run this application with debugging. I'll press F5. This will launch a new tab in my browser. And now that the application has launched, let's go to our HelloController. We hit our breakpoint, but for right now I just want to press F5 and run through it so we can compare the output. Now I know I'm running on the CoreCLR because the output on this tab is showing the type name of my controller, as well as the assembly name while the tab left from the previous run on the application that was using the full .NET Framework it is just showing the assembly name. So the full CLR output on one tab, the CoreCLR output on a second tab. Let me refresh this page, and we should hit our breakpoint again. What I want to do is open up the Modules window. So modules in many cases have a 1:1 mapping to assemblies, but you can have multiple modules per assembly. What this Modules window is showing me is what modules are loaded into this application. And I can see that nearly all of the modules that are loaded are coming from a folder that is underneath my User folder on this machine. Let's stop debugging and go out and look at that folder. There are actually a couple significant directories I want to point out. The first one is this kre directory. As you know now, this stands for the K Runtime Environment. Drilling into here, I can see a packages directory, and inside of that there appears to be a package folder for the x86 version of the CoreCLR. And finally, inside of here is a NuGet package file, an nupkg file or what David Fowler of the ASP.NET team calls a nupkeg. It's about 14 MB, and this is a CoreCLR. It's a CLR distributed as a 14 MB NuGet package. I can literally just copy this file to a machine to deploy the Core .NET Framework. That's amazing given some of the pain that I've experienced in the past trying to deploy or update .NET on the server. And inside the bin folder here is an unzipped version of that nupkg. It's all the assemblies that are inside. This is again the CoreCLR. Now there's also in my folder a KRE-CLR, which we know is the full .NET Framework. You might notice that some of the assemblies aren't in the bin folder and that the NuGet package file is a lot smaller than the CoreCLR. Why is that? Well, because when we're using the full .NET Framework, the assemblies are stored in the Global Assembly Cache, the GAC. The GAC has been around since the very beginning of .NET Framework, and when our application is using the full .NET Framework, the KRE will simply be loading assemblies from the GAC. With the CoreCLR, there is no GAC, which also means there are none of the headaches that the GAC commonly imposed. But that doesn't mean that we don't have a central location to store the CoreCLR or actually packages in general. Now chances are you've been using NuGet packages with Visual Studio 2013 and even previous to that, and you probably know when you install a NuGet package for a project there will be a local packages folder. It commonly exists at the Solution level, and it has all the NuGet packages that your application needs. That sort of packages folder no longer exists in ASP.NET 5. Instead, there is a global packages folder. It will be under my username under the folder .kpm, so K packages. So there's a tool we'll look at later in the course called the K Package Manager, but everything is being stored inside of here. You'll remember earlier we added a reference to the package for WindowsAzure.Storage. If I look through here, I can see that WindowsAzure.Storage package is not stored locally with my project. Instead, it has gone into this kpm folder. And if I drill into here, I can have multiple versions of that package on this machine. So ASP.NET completely embraces NuGet packages. We manage dependencies through NuGet packages. We can have our Common Language Runtime stored in a NuGet package. And as we'll see later in this course, we can even build our project into a NuGet package for deployment. We can also build NuGet packages to share and install them into our global package cache, the kpm folder. ASP.NET 5 loves NuGet packages, but what ASP.NET 5 loves even more is source code. I'll show you why next.

Class Libraries

Back in the project.json file, now we've learned a bit how to manage frameworks, how to manage dependencies, but there are a few things I haven't told you yet. Inside of the framework objects in this JSON file, I can list dependencies specific to building and running against that version of the framework. For example, earlier we pulled in the WindowsAzure.Storage NuGet, and I placed it in the top level of the dependencies. But really the way this package works today, it will only work against the full CLR and not the CoreCLR, so it would make sense to remove that package from the top level dependency list and place it down here so that SDK is only available when building and running against the full CLR. Will this complicate the code with more if define statements? Probably, but to be honest, for an application, I think it probably makes sense to choose one of these two frameworks and just go with it. Chances are you're going to select your framework, and that's what you're going to use in development and in production. But for anyone writing libraries that plug into other applications, that's a scenario where you probably want to support multiple runtime environments so your library can be used in a wide variety of applications. And speaking of libraries, in the project.json file when I add a dependency like WindowsAzure.Storage, The K Runtime has a few locations where it will look for this dependency. One location is that global package folder in my user directory. Another location is nuget.org. ASP.NET 5 can also look in any other NuGet feeds that I've configured for NuGet, but there is one place where ASP.NET will look before consulting these various package sources, and that is this very solution. To demonstrate, let's add a class library to this application, so I will Add a New Project. And what I don't want to do is go to the usual place to build a class library. Usually what we do when building a class library is to go under Windows Desktop, find the Class Library project, and add that. What I want to do is use an ASP.NET Class Library, an ASP.NET 5 Class Library, and that's because this particular class library uses the same compilation model that my web application uses, and that is when I add a file to the file system, that file will automatically be included in the class library, and whenever I save a file, a build will happen behind the scenes. All I need to do is refresh a browser, and I should be able to see changes. Let's call this FirstLookLibrary and hit OK. And this project is also going to go under the src folder. That's significant because of another file I haven't showed you yet, but it is the global.json file. This file exists right alongside the solution file for this project, and what it's going to tell ASP.NET is where to look for source code. There are two places to look for source code. One is in the folder called src, source, and that's where my web application lives, that's where this new class library lives. And another folder it can look into is a folder called test, which we don't have, but if you want to write unit tests against classes that are in your web application or in your ASP.NET class library you can add a test folder and put all your test code inside of there. But going back to the class library, it is under the src code folder so it can be compiled, and let's rename Class1 to be something like Greeter. And then I can come over here, and let's just give this class a method that we can call, so maybe something that returns a string. Let's call it GetGreeting, and it will return Hello with a few exclamation points. Now notice that my class library has a project.json. This specifies the versions, the dependencies that work across all frameworks, and it says that we're going to build and support both the full CLR and the CoreCLR, and here you can see we have a very, very minimal set of dependencies for these frameworks. For the most part, ASP.NET has a pay as you go type of model meaning you'll start off with the bare minimum, and then you add in just what you want to use. But now to get to this class, which I've called Greeter, from my web application I have to open up the project.json for my web application, and FirstLookLibrary is the type of dependency that I might use regardless of which framework I'm targeting, so I will add it to this top level dependencies. And you can see it appears in the IntelliSense window. ASP.NET and the Visual Studio tooling are aware of that library. And up here I can specify a specific version, remember FirstLookLibrary was version 1.0.0.0, or I can just leave an empty string here to say take the latest that you have available, which will be the source code that currently exists for that library. And once I save the JSON file, I should be able to come over into the HelloController, and I should be able to instantiate that Greeter, and I should be able to do that once I pull in the namespace that that class lives in, which is FirstLookLibrary, and then I can ask that greeter for the greeting. And then I could take that string that is returned and use it to compute a better return result from this controller action, but I'm sure you could figure out how to do that. The overarching goal of this particular clip was just to show you that in addition to referencing NuGet packages in project.json I can also establish references between the projects that are in my solution so my web application can depend on a class library, that class library can depend on another class library, and the second class library can have dependencies on the CoreCLR. And when I list a dependency like this, FirstLookLibrary, ASP.NET will always be looking in the src and test folders first to see if there's a project by that name. What's really amazing about this approach is that you could even clone the source code to something like Microsoft.AspNet.Mvc, have that living in your src folder, and every time you run your application ASP.NET will be rebuilding Microsoft.AspNet.Mvc. You can make changes to that source code. You can step through that source code just by having it in your src folder. ASP.NET will be using the source code instead of the global package, which makes it very easy and fun to explore some of the ASP.NET runtime. If you've tried to do that in the past, you know there are all sorts of issues around resolving strong names or getting rid of strong names, but now working with the ASP.NET source code is just as easy as cloning a repository and adding a dependency.

Summary

In this first module, we looked at the new project system for ASP.NET 5. We now know the layout and the content of the file system are what we see in the Solution Explorer window, and all we need to do to make changes to a web application is save a file. ASP.NET will automatically build assemblies for us. We've also seen how to manage dependencies in ASP.NET 5 and how to build against and select a target CLR for our application. We can use the full CLR or the streamlined server and cloud CLR. In the next module, we'll build on this knowledge. I want to create a web application from scratch. By starting from scratch, we'll learn about the new configuration system of ASP.NET and also focus on how the MVC and Web API frameworks have merged into a single slick framework for us to use.

ASP.NET MVC 6 - The Great Unification

Introduction

Hi, this is Scott Allen, and in this second module of an ASP.NET 5 first look we will build out a very small application to see what it's like to work with ASP.NET MVC 6. MVC 6 is the new ASP.NET MVC and Web API as the two frameworks have rolled into one. There are many concepts you'll already know about MVC 6 like how to route requests, respond to requests with controller actions, use model binding. These concepts won't be new or different, but there are some significant changes in how MVC behaves and how you use this framework. For starters, MVC 6 no longer relies on the System.Web assembly, so there might be some code that you've written no longer works. Also, the complex configuration system that we've come to learn over the last 14 years is gone, but we'll see those types of details shortly. Let's get started.

Startup and Middleware

Inside of Visual Studio 2015, let's create a new project. Once again, I want an ASP.NET Web Application. I'll call this Messenger. I'm going to place it in my development folder, and this time I'm going to select the ASP.NET 5 Empty application template. This will give me a very Spartan starting point. And once Visual Studio gets the solution loaded up, you can see we have a very different project look than the one we did in the first module. There's no controllers folder; there's nothing in my wwwroot folder. I really do have a very basic application starting point, and if I try to run this application, I will just get an error back from the web server because there is nothing in this application to respond to a request. Let's change that. Now in most ASP.NET web applications to date we can make some modifications to our global.asax file or our web.config file to modify the startup of our application, but you'll notice we have neither of those files in this project. Instead, what we do have is a Startup.cs file. Now at this point I'll put in a shameless plug for my ASP.NET MVC 5 Fundamentals course, specifically the module in that course that deals with OWIN and Katana. If you've watched that particular piece of the course, you know that there is a new HTTP pipeline available for ASP.NET. It's based on the OWIN specification. And what we can do in ASP.NET is plug in middleware pieces that sit in that HTTP pipeline and follow the OWIN specification on how to work with a request and a response. We also know from that video that there's some magic inside of ASP.NET that can automatically go out and find a class called Startup that is in the root namespace of the web application. And if ASP.NET finds that, it will automatically invoke a method called Configure after it instantiates that class, and it will pass in an object that implements the IApplicationBuilder interface. In ASP.NET vNext, this is almost entirely how we configure an application to behave. What frameworks is the application going to use? Is it going to use MVC? Is it going to serve up static files? All of those different behaviors and options are configurable as middleware that I can set up in this Configure method. For example, without adding any references to any other packages, and I just want to point out that in project.json I really have no dependencies other than a dependency on Microsoft.AspNet.Server.IIS, which will allow my code to get into IIS Express, so if no other package is loaded, I can set up a piece of middleware using app.Run that says basically give me a context object, and what I want to do is a ctx.Response.Write, in fact I could make this WriteAsync, and let's just another Hello World. Let me make this async, and we will await ctx.Response.WriteAsync. Let me save this file, and now if we come back to the browser every request that comes into our web application should return with the text Hello World! Now if you've done some work with the Startup class that existed in ASP.NET MVC 5 projects and you've loaded up OWIN middleware, you know it's quite common that you'll want to install other pieces of middleware that aren't immediately available in the project, and to do that you'd probably add a reference to a NuGet package. This version of ASP.NET is no different. It's just that our NuGet packages, we can manage them through the project.json file. So I want to look for a package called Microsoft.AspNet.Diagnostics, we'll take the beta2 version, and I'll save this project.json file. ASP.NET will bring that package in. And if you're familiar with this middleware component, you'll know that when you bring in a new piece of middleware, some OWIN component, it commonly installs an extension method for ApplicationBuilder so that you can do more interesting things than you could before you referenced that package. And these extension methods usually start with the word Use. And if I scroll through here, I can find at the very bottom something called UseWelcomePage. So instead of our app.Run, I want to use this WelcomePage just to show you how easy it is to install a NuGet package that provides some middleware, configure that middleware into the HTTP pipeline in the Startup class, and then viola this WelcomePage middleware is producing the page that we see here in the browser. And now any time that you want to add new features or new frameworks into an ASP.NET 5 application, you'll probably be adding some NuGet packages coming into the Configure and adding more middleware into the application. And that's what we'll do next. What I'd like to do next is start using ASP.NET MVC 6. That's going to require some middleware, as well as some additional pieces. Let's look at that next.

Startup and MVC Services

Instead of using this simple middleware, let's add something more significant like ASP.NET MVC. One of the first things I'll need to do is add the package for ASP.NET MVC. I can come in here and do a search for MVC. If I scroll around a little bit, I should find Microsoft.AspNet.Mvc, and let's just take beta2. I will save project.json, and over here in the Startup file I now actually have a couple different tasks to take care of. This version of ASP.NET now has dependency injection woven throughout the framework, and when the application starts up we need to go through a couple different phases. One phase will be the configure phase where we configure middleware against this ApplicationBuilder object, but before that phase occurs there will be a phase where we can configure services, services that will be available throughout the application, and as we'll see later in this module we will be able to configure services to be injected into other components much like you would do with an IOC container like Windsor or StructureMap or Ninject. But the configuration of the services takes place before the configuration of the ApplicationBuilder. That way you can have all your services available and ready to go by the time we're ready to configure the application. And to configure the services that are going to be available for this application, I can add a ConfigureServices method to my Startup class. This runtime will call this automatically, and it will pass in an object that implements the interface IServiceCollection. This is in a namespace that I need to bring in, the Microsoft.Framework.DependencyInjection namespace. I will call this parameter services. And in order to use ASP.NET MVC correctly, I'm going to need to configure it in as one of the available services. But before I do that, it might be instructive to show you what the middleware configuration looks like and the error that results if the service is not properly configured. So, in other words, now that I have a dependency on the ASP.NET MVC NuGet package, that package will install a new extension method that I can use against IApplicationBuilder, and that extension method is UseMvc. If I just want to take all the defaults that the framework provides, this is the only code I need to write to start using MVC, well this and the service configuration. But I just want to show you if I try to run the application we will get a 500 error response from the server, and the underlying error was an InvalidOperationException. The runtime was unable to find the required services. And you can see it's being very explicit that I need to walk up to the IServiceCollection and use a method called AddMvc to make sure the proper services are in place. So let's do that. I can say services.AddMvc. So you add services to the ServiceCollection, and you use middleware against the ApplicationBuilder. And later in this module we'll come back and configure some additional services, but for right now I should be able to save my Startup file, and let's go out and create a controller and see if it works. So I will Add a Folder here where I can place Controllers, and inside this folder let me Add a New Item, and there will be an item template in here for MVC Controller Class. I do want something called HomeController.cs, so let's just add this. And for right now I don't want to get involved with views and things like that, so let's just return some Content, text content that says Hello from a controller! I should just be able to save my files, refresh the browser, and hopefully see this work. And it does. I get Hello from a controller! So any time you've worked with ASP.NET MVC you have seen some sort of routing configuration. The routing configuration tells the MVC runtime how to take an incoming HTTP request and map that to a controller. And in our application we have not configured any routes. When we don't configure any routes, we just get a default routing configuration that is very much like the default routing configuration you would see in previous versions of ASP.NET MVC. You would explicitly see the code inside of the global.asax startup file somewhere. But our application is not specifying any routes. We're just getting the built-in defaults. But what if I wanted to call this action Default instead of Index? Well when I do that and save this file, I will now get a different response from the server because ASP.NET MVC looked at this request, couldn't find a controller and action to respond to the request, so it just let the request flow through, and eventually IIS Express came back and said no, we're not allowed to list the contents of this directory. You're trying to get to the root of the site. There's no default page. There's nothing to handle that request. It's just going to return an error. So what if I wanted to change some of the routing rules to make sure that I called this Default action? There are a couple different ways to do that. One approach is that when I say that I want to use MVC there's an overload of this that will take a func, so I'll use a lambda expression here where the func takes a parameter IRouteBuilder, and I can use that RouteBuilder to configure as many routes as I want. So this is actually routes I should call this. I want to use routes.MapRoute. Now MapRoute is actually an extension method, but one of the nice features in C# version 6 and Visual Studio 2015 is that the tools can actually go out and find extension methods that I might be missing. So it's telling me if you just include this namespace, Microsoft.AspNet.Routing, then you'll actually be able to map a route. And the routing really hasn't changed from the previous versions of ASP.NET MVC. I can specify the name of this route, I'll call it the default route, and then I can specify a template like controller/action. But one thing that is new in this version of MVC is that if I want to provide default values for the controller and the action because those sections of the URL don't exist, I no longer have to pass in this crazy anonymously typed object that has controller and action properties. Instead, I can specify the default right here in the URL template by just saying controller, the default controller equals Home, the default action equals, let's call it Default. And once I have the proper number of parentheses here, I can save this file, come back to my browser and refresh, and there I have effectively changed the default routing rules that we use with ASP.NET MVC, and my default controller action is now named Default. And of course I can still get to that explicitly. I can go to /home. That resolves to the same controller and action. Or /home/default also works. So this is one way to configure routes. I'm going to leave this code here but comment the code out, and I'm going to go back to using just app.UseMvc. I want to show you another way to modify the routing for an application, and that is by using attributes. Now attribute routing was actually introduced with ASP.NET MVC 5, but there are some new features. It has been refined a little bit. With attribute routing I could come in and I could say I want a Route Home to map to this controller, but one of the new features that is introduced in this version of ASP.NET MVC is that I can also specify controller in square brackets, and now the runtime knows that this should be /home. If I ever change the name of the controller, if I called it GreetingController, then this route definition would effectively be /greeting. And down here on my default action I can also provide a Route, and I could say this needs to respond to the name of this method, Default. So save this file, come out, and refresh the browser. This will still be working when I go to /home/default. That's good. What happens if I just go to /, well now I don't have a default routing rule that says go to the HomeController by default. What I could do is add an additional route here that says please respond to a request to the root of the website, and I can add a Route here that would effectively make this action optional and save this file again and refresh. And now a request to the root of the website will execute my HomeController's Default action. So as you can see, many similar concepts carrying over from the previous version of ASP.NET MVC. We still have routing, we still have controllers, we still have a base controller class, we still have action results, and what I want to show you next is that we still have razor views.

Razor Views

Inside our Default action, instead of returning Content, let's return a View result. So in this version of ASP.NET MVC there is still a helper method called View that will create a View result for us. The default name of the View will be the same as the action, and we'll be able to see that if I refresh this page because we currently don't have a view, and the MVC framework will tell us exactly where it went looking for a view and what the name of the view was. So we went looking for a view called Default.cshtml in the Views Home folder and the Views Shared folder. What I should do now is Add a Folder. We will call this folder Views, and inside of that folder I will Add a Folder Home. This will be the views for the HomeController. And then inside of that folder I will Add a New Item, and I can find an item template for a razor view, MVC View Page. I actually want to call this Default.cshtml, and inside of here let's add some markup, so perhaps an h1 element that says Hello and a div that says this is a view. Once again, I just need to save files. I don't need to go through a build step, but I should be able to refresh my browser, and now I have a view working just like I would expect. So we can see the MVC framework it still has controllers, it still has views. What about using models and passing models to a view? Let's look at that plus do some dependency injection next.

Injecting Services

Now imagine in my application if I want to display some text in this view, but I don't want that text to just be hard coded into the view or into the controller. I want to retrieve that text from some component, and that component might be talking to a web service or a database. I don't particularly care from the controller's perspective where that data ultimately comes from. I just want to be able to use some sort of component, some sort of service to be able to retrieve a model that I need to present to the view that needs to go to the user. So let's create a Services folder, and what I'm about to do I would typically do across multiple C# code files. But just to keep things a little bit simpler, I'm going to mash up three different classes inside of the same CS file because I'm thinking I'll need one class to represent my entity or my model that will contain the text of the message to display. Then I'll need another type, an interface definition that I can inject into a controller so it can call into some component to get today's message, and then I'll need a concrete implementation of that interface. And that concrete implementation might talk to a database or a web server. I don't really care. But let's create a Class file. I'll call it IGreetingService, and inside of here we'll have a few things. So first of all the model or the entity. Let's call it GreetingMessage, and like many entities it will have some sort of Id property, and I'll also give it a property to represent the Text of the message. Now I need an interface. Let's call it IGreetingService. So this will be a service that I want injected into my controller. It will have a method that returns a GreetingMessage. Let's call it GetTodaysGreeting. And then I'll need a class. Let's just call it GreetingService. This will implement IGreetingService, and I'll use Visual Studio Ctrl+. here to implement this interface for me. And inside of GetTodaysGreeting I will return a new GreetingMessage. The Text of that message could be Hello from the greeting service. And I also want to initialize the Id property. Let me use a private id field here that I can use and increment, and I'm going to do this to demonstrate some of the behavioral characteristics of services in ASP.NET MVC. And I just need to make sure that I have my syntax all set and that I don't have semicolons in the wrong place, and that appears to be working now. And now over in the HomeController, this IGreetingService, I want to be able to inject this into the controller, so I need a constructor, a constructor that takes an IGreetingService. Let's call it greeter. And I will save that off as a private field here to make it available in the other instance method, so _greeter equals that incoming greeter. And I'm just going to need to bring in the namespace for this, which is Messenger.Services. Now if you've done this type of thing in previous versions of ASP.NET, you would know that things would turn ugly pretty quickly because as soon as you have a non- default constructor on a controller then the ASP.NET MVC framework would give up and say I cannot create this controller. Well we still do get an error message, but it's a much different error message than we used to get in the past. Now instead of giving up, the MVC framework says it at last tried to do this, but it was unable to resolve a service. It was unable to resolve some service that implemented this IGreetingService interface. And this is where we can use the dependency injection features that are built into the framework to resolve this problem. If I come over into Startup.cs where I ConfigureServices, one of the things I can do with services is add specific service instances. This is one method for registering services. I want to show you a couple different variations of these, but let's use services.AddInstance to say that if something needs an IGreetingService, and again I'll have to bring in the namespace here, Messenger.Services, when someone needs an instance of that, give them this instance of the concrete GreetingService class. And now any time the MVC framework is trying to instance a component like a controller that needs an IGreetingService, it will just take this object's instance and pass it in. So I should now be able to refresh my page, and now I can see that I can still instantiate the HomeController. So now I want the HomeController to use this service that is being injected to create a model to pass along to the view. So this is just traditional MVC at this point, things that you've already done. I will say that the greeting = _greeter.GetTodaysGreeting. I will pass that in as a model to my razor view, then save this file. Let's come over into Default.cshtml. I'm going to add a using for Messenger.Services, and I'm going to add a model directive that says the type of object that you should receive as the model for this view will be a GreetingMessage type. And now I can write out some information about that message, so let's write out the ID of that message, that would be Model.Id, and let's write out the text of that message, which will be Model.Text. And let me save my Default.cshtml file and refresh the application, and you can see that we're looking at the first message that was produced. So the message has an ID of 1. It says Hello from the greeting service. Everything is working correctly. Notice what happens when I refresh this page. The ID keeps incrementing, and that's because the way we have configured the service we essentially have a singleton object for our IGreetingService. Now sometimes that is the behavior that you want, you want a service that is a singleton, but other times you might want the service instantiated each time it is required, and sometimes you want a service scoped to a specific HTTP request. That's quite common when you're doing data access with an ORM framework like the Entity Framework. You're trying to represent a unit of work, and you want something like a DbContext derived class where there will be one instantiated for each HTTP request, and any component that participates in responding to that request, they'll all get the same instance. But when a second request arrives, it gets a new instance of that DbContext. This is all possible through different registration methods that are available on IServiceCollection. By doing AddInstance, that was effectively the same as doing AddSingleton, which you can see here. The only difference between the two is that with AddInstance I pass in the object instance. With AddSingleton, what you do is you pass in either a type, or you can pass in a func or a lambda expression that takes an IServiceProvider parameter and returns an instance of the service. There is also AddScoped. This would give me a new instance of the service for each HTTP request. And there's also AddTransient. AddTransient is a way of saying give me a new instance of the service every time someone needs one. So if there are three or four components in an HTTP request that need a GreetingService, they would each get a different instance. What I will use now is the func approach that says given a parameter P, which is a service provider, give back a new instance of the GreetingService. And now if I save this, since we're using AddTransient instead of AddInstance, we no longer have a singleton GreetingService. Instead, we're reinstantiating the GreetingService each time we need it, and that means the ID is always being reset back to a 1. So you can see that dependency injection has taken a front row seat in the ASP.NET framework. It works up and down the stack now. And typically what you will do is use this ConfigureServices method of the Startup class to initialize the container behind the scenes. And again, you can plug in other containers. So if you want to use Ninject or StructureMap or Windsor, you can plug those containers into the framework. The container that is in ASP.NET is a very simple container, and it can work with transient services and HTTP scoped services and singleton services, but many of these other frameworks like StructureMap, they have a very rich API and a lot of features that you can take advantage of. Now you'll set all of this up inside of ConfigureServices, which again gets invoked before Configure. And one of the things that you might want to take advantage of during ConfigureServices is some sort of configuration information. You might need to know if you're running in production or if you're running in debug mode. You might need to be able to access things like data connection strings. How does all that work in this new world of ASP.NET? Let's take a look at that next.

Working with Configuration

The configuration system in this version of ASP.NET is considerably different from the configuration system that we've become accustomed to. In the past, ASP.NET configuration involved a machine-level web.config, a machine.config, a local web.config. You probably also had web.config files in subfolders, and all of this relied on inheritance and lots and lots of XML. What I have in this application right now is zero configuration. I do have some configuration. It's in the Startup class. It's the services I configured and the middleware that I configured, but I have no web.config file. Now there is a good reason to have some sort of configuration file because as you move an application between environments it becomes very useful to be able to open up a file and change some setting for the application like a database connection string. We can do that with this version of ASP.NET, but it's not going to involve any XML. What I will add to this project is a JSON File, and I will call this JSON File config.json, and I will just add it right here in the root of the project. And what I want to be able to do is to make the message inside of our GreetingService configurable. So right now this GreetingService and IGreetingService, it represents some component that might be doing database access. I didn't have to build it out this way, but I wanted to build this component in a way that showed you how dependency injection works and how you can still build a testable controller by having dependencies injected from a container. But it's a good example because even though this GreetingService doesn't use a database, it represents a component that might need to access the database. And if it's accessing the database, chances are it needs access to some configuration information. So I want to be able to pull some text from the config file and use it as the text for my greeting message. So let's say we have a message property in here, and I'll just say This is configurable text. That's all I need to put in here for now, but your config.json, it can be as complicated as you want it to be. Now to take this JSON file and properly plug it into the new configuration model for ASP.NET 5, I'm going to add another dependency. This dependency will have the word JSON in the name because it is Microsoft.Framework.ConfigurationModel.Json. Let's take beta2 version of that, save project.json, and now inside of Startup.cs I want to let ASP.NET know that config.json is a source of my configuration information. And I want it to be able to read that file and give me access to the file, so let me create a property called IConfiguration or of type IConfiguration that requires me to bring in a namespace, Microsoft.Framework.ConfigurationModel. And I will call this property Configuration, and I want Configuration to be equal to a new Configuration object. Now at this point there's a bit of a fluent API that's available to configure different sources of configuration. For example, I could say I want to add a JSON file called config.json, and what that will allow me to do is when I read configuration information from this IConfiguration it will be pulling that information from config.json. Now in the past with ASP.NET there were all sorts of tricks you could do to change configuration information automatically when you push something to a QA server or to a production server. It typically involved XML transformations, and that's why we used to have a web.config and a web.debug.config and a web.release.config. With this version of ASP.NET we don't have transformations and we're not using XML, but what we can do is add multiple configuration sources. So you'll notice there are methods available here to add a command line source, add environment variables, add in any file if you want to store your settings in an any file. And if I were to choose something like AddEnvironmentVariables here, this is what I would be telling ASP.NET. Go out and read things from config.json sure, but if the same setting exists in an environment variable, use that environment variable instead. And what this allows you to do is define something like a database connection string inside of config.json. You can check that code in, you can push it to a server, but on the server you might have an environment variable that overrides that database connection setting. And so it doesn't matter what you accidentally put in the config.json. On the server, your production server, you'll always be using the right connection string because it's defined in an environment variable. And that works out really well for environments like Azure because you can log into the Azure portal and set up environment variables for your website. And those environment variables can have all the secret keys and secret passwords, and they override whatever's in config.json. But now that I have my IConfiguration source available, I need to get that into my GreetingService so that it can use it. So over here in the Greeting Service I might define a constructor that takes an IConfiguration. And again, I'll have to bring in that namespace, Microsoft.Framework.ConfigurationModel. Let's just call this config, and I will save that off into a private variable, so _config, and _config equals that incoming config parameter. With that IConfiguration, I should be able to set my Text equal to _config. Please Get me something by key value. Inside of my JSON file I have a property called message, so this will essentially be saying get me the value of the property message, return it as a string value, and let's just put that into text. So when I run this application, I should be able to see something that is in my config.json like This is configurable text. But before I do that, I now have a GreetingService that requires a constructor parameter, and that means over in Startup.cs I can no longer just instantiate GreetingService this way. Now there are also some tricks I could use to get this GreetingService instantiated. There are lots of IOC containers out there that know how to set up objects that have nested dependencies. I can certainly delegate to one of those. I can also use the ServiceProvider parameter that comes in, and it has an interface that will allow me to do things like GetService, GetRequiredService. All sorts of options here, but I also have the option, since I have IConfiguration available right here on my class and it's already initialized, to just pass that into the GreetingService. And now I should be able to save everything and refresh my browser. This is configurable text. That's good. It works. So this is the new configuration model for ASP.NET 5 applications. It's really geared towards using JSON files by default, but also allowing you to add additional configuration sources like environment variables or command line parameters. So this is drastically simpler than what we had in the past, but also very flexible, and once again is an example of ASP.NET adapting itself and optimizing itself for things like cloud deployments and running in Azure. Now so far we've done all this work with a controller that looks very much like a traditional ASP.NET MVC controller, but what about the Web API. How does that work now? Let's look at that next.

WebAPI Controllers

Let's say that we wanted to take our greeting information and serve it up over an HTTP API, an API that has built-in structure to take care of things for us like content negotiation. If the client is asking for JSON, I want the API to serve up JSON. If the client asks for XML, then serve up XML. And this sounds like a perfect job for the Web API. Now in previous releases of ASP.NET, using the Web API meant installing new NuGet packages or additional NuGet packages into the project, but with this application in ASP.NET 5, then ASP.NET MVC includes both the MVC framework, as well as the Web API. So I'm not going to add any new dependencies to this project. Instead, perhaps I will just add my new controller. Now this time I'm going to pick a Web API Controller Class, and I'm going to call it Greetings.cs, and I'll let that item template generate the code for me. And I just want to point out a few things about the generated code. First of all, notice my controller derives from a base Controller class, and this base Controller class is Microsoft.AspNet.Mvc.Controller. That is the exact same base class that I'm using for my HomeController, which is more of a traditional MVC controller that serves up views, but with MVC 6 the Web API framework and the MVC framework have combined together into something that's very flexible and usable and allows you to produce anything from a razor view to an IEnumerable of string. This string array will be serialized into JSON or XML or any other format that you want as long as you add the appropriate extensions just like Web API worked. Notice we can use routing attributes that say in order to reach this controller you have to go to api/ and then the controller name, in this case Greetings, but then on the individual actions we're specifying verb-based routing, and this is what we're accustomed to with the Web API. If I issue an HttpGet request to api/greetings, that will invoke this action that returns a couple strings. If I invoke api/value/5 and pass an id in the URL, that will invoke this version of the Get method. And you can see there's also Post, Put, and Delete in here. All I really want to implement is this first Get method. So this controller is going to need a constructor so that it can get a hold of an IGreetingService. I just need to bring in the namespace, Messenger.Services. We'll call this greeter. And just like we did with our other controller, I'll create a private field here to hold that greeter, so _greeter equals the incoming greeter. And let's change around the Get request to return instead of IEnumerable of string, we will just return a single greeting message, and I'll get rid of this second Get that expects an id parameter. My model will be _greeter.GetTodaysGreeting, and I'll simply return my model. So let me save all the files, this is really the only file that I have edited, and let's swing over to Chrome. Now I have an application extension installed in Chrome. It is called Postman. This is something that you can get from the Chrome web store, it's very easy to use, and what this extension does is allow you to interact with HTTP APIs in a very easy way. So, for example, I want to send off a request to localhost 28549/api/greeting. That should get to this controller. It's going to be a GET request, and I'm going to send along a header, an Accept header that says I want to see application/json. Let's send that request off, and you can see I get back my greeting message as JSON. And now let's change this over to use XML, send that request off, and now I get the XML version. This is just like how the Web API behaved in previous versions of ASP.NET. But now we have this nice unified model where MVC and Web API they're really the same framework. It's one framework with the capability of both MVC and Web API, and that generally means it's easier to work with. So if you want to install something like a global filter, you only need to do that in one place. If you need a custom model binder, you only need to do that in one place. When the ASP.NET team rolls out a new feature, it's available for both the MVC framework and the Web API, so we're really in the future probably not even going to make a distinction between the two. It's just all the same framework. It can serve up views, it can serve up JSON, it can serve up XML, and that's something I wish Microsoft had been able to do from the start. And well it just took a couple of years, but we're finally there now.

Summary

In this module, we started with an empty ASP.NET 5 web application, and then we added the dependencies, the services, the middleware, and the configuration that we needed to build out an application. Although we only reached a basic starting point here, hopefully you've seen how easy it can be to work with this framework. And most of your existing knowledge still applies. We still have controllers, models, views, built-in content negotiation, and all the primary features we need in a web app, plus today we have pluggable configuration sources and dependency injection built in throughout the framework. That's a nice place to be for building web applications. However, we aren't finished taking a first look at ASP.NET 5. There are still plenty of tools we need to look at, tools to make our job easier and to make our application easier to deploy and run fast. We'll look at these tools in the next module.

ASP.NET 5 Tools - The Letter K and Node.js

Introduction

Hi, this is Scott Allen, and in this module we're going to look at some of the tools for ASP.NET 5. Some of these tools are provided by Microsoft, like the KVM, the K Version Manager. The KVM lets me update and manage runtimes from the command line, and I'll show you how you can use this tool to be more effective with the K Runtime. Other tools we will look at are provided by third parties. These are tools like Node.js and the build tools and package managers that run on top of Node.js. In this module, I'll show you how these tools allow you to work productively with frontend frameworks and libraries and also how they integrate with Visual Studio 2015. We'll kick things off by looking at the version manager for ASP.NET 5, the KVM.

The KVM

Earlier in this course we looked at where the runtimes and packages existed for ASP.NET 5. This was a collection of folders underneath my home directory. That was 24 hours ago when I recorded that part of the course, and now things have changed. I just installed an update to Visual Studio 2015. I'm now working on CTP 6, and the first thing I want to show you is that the folder structure changed slightly. Previously we had .kre and .kpm folders inside of my home directory. Now if I look in my home folder, I have a single folder, .k. So again, the code name for ASP.NET 5 was Project K, and it's underneath this folder where I will find all those pieces that I saw before under distinct folders that were in my home folder. Now everything is under .k, so I have the packages folder, I have the runtimes folder, and if I go into the runtimes folder, we can see those same identifiers that we saw earlier in the course for the different runtimes that are installed. There's the runtime for the full CLR and the CoreCLR, and for each of these there is a 32-bit and a 64-bit runtime. Now inside of each of these runtime folders there is a bin folder, which will contain not only some assemblies for that particular runtime, but also some command and executable files. These are commands like the K command and the KPM command, both of which we will use in this module to do interesting things like run a web application from the command line or bundle an application for deployment. But before we can build or bundle, we have to be able to execute these commands, and in order to be able to execute these commands we have to be in the right folder or have these commands in our path. Now since you might be using different runtimes for different projects, ASP.NET provides a tool that allows you to switch between the runtimes very easily when you're working from the command line. This tool will set up the correct path to reach these commands. It can also update and install new versions of these runtimes. We expect ASP.NET to release new versions on a regular basis. Now the tool that I'm talking about is a tool named KVM, the K Version Manager. That naming convention will be familiar to anyone who has worked with Ruby, which has the RVM for the Ruby Version Manager, or Node.js, which has the NVM for the Node Version Manager. K is for Project K ASP.NET, so this is the K Version Manager. The one catch to the KVM is that it is not installed by default, at least not with this release of Visual Studio; however, it is easy to install. If I go to the home page for ASP.NET on GitHub, if I do a search for kvm, I will find eventually a simple command that I need to copy. I just need to take the text here, I need to copy that, I need to open up a command prompt, paste in that text, and then press Enter. What this command will do is launch PowerShell and download another script from GitHub, and that script will install the KVM. The KVM will set up a path in my environment variables so that I can run KVM from anywhere, and it will also set up a path so I can execute commands from one of the runtimes installed on this machine. Now once the KVM install is completed, it might be best to restart your command prompt just to make sure that all the changes take effect, but now I should be able to run KVM, and I will get a usage display because KVM expects me to run it and pass in a specific command that I want to use. For instance, I can upgrade the K Runtime Environment. I can explicitly install a specific runtime environment. I can also tell KVM to switch around my environment variables so that I am using a very specific runtime environment. And how do I know what runtime environments are available? I can just do kvm list. So here I can see full CLR, CoreCLR, 64-bit, 32-bit. And the way things are set up right now, if I try to run the k command, which will fail because I haven't given it enough instructions, but we'll look at that later, that K command should be executing from the full CLR runtime, the 1.0.0-beta3 runtime with the x86 architecture. If I wanted to switch to using the CoreCLR, I can say kvm use 1.0.0-beta3 -r for runtime CoreCLR. And now if I kvm list, I can see that the active version is in fact the CoreCLR version. So if I run k again, we still fail. Slightly different output, however, and that's because I'm using a different version of k. Let's for right now switch things back to use the regular CLR, and I'll just verify that with kvm list. And now we can start to talk about why this is interesting. Why do I want to be able to run this k command? We'll talk about that in the next clip.

K Commands

With the KVM installed, we can now run k. And you might wonder why k is useful. So far every time I run k the program has thrown an exception. But let me move into the same directory as our web application, and now I will run k, and I get some different output. This is because I'm now in a folder that has a project.json file for our web application, and k is an ASP.NET utility we can use to run commands that we define in project.json. What sort of commands do you place here? Well, you can have commands defined to run unit tests, to run database migrations, to launch a web server. I'm sure there will be many more commands available in the future. All we have to do is specify the available commands for this application inside of this project.json file. So I will add another property here, commands, and these will be the commands available for k. So first I provide an alias for the command. Let's have a command called web. What I want to be able to do is come out to the command line and be able to type k space web to have k execute this web command, and what I want the web command to do is launch a web server that serves up this application. So the way I do that is to first specify the name of a program. In this case, I'm going to specify Microsoft.AspNet.Hosting. Microsoft.AspNet.Hosting is essentially an assembly that has a program class inside with a main method. So k will know to load for that assembly, look for that main method, invoke the main method just like you might do for a console application, and then that main method takes parameters. In this case, those parameters can describe how we want to host the application. I can pass in what server I want to use, and I want to use a server that is built on top of http.sys in Windows. Now to do this, I'm going to need to bring in another dependency, and this dependency will make sure that HTTP listener is available. The dependency I want ends with the word WebListener, so let me just do a quick search for WebListener. There it is, and I'm going to select the beta3 version. And now let me copy this text because this is the server that I want to use, so --server is Microsoft.AspNet.Server.WebListener, and then I can specify the URL or the URLs that I want this server to listen on. I'm just going to specify http://localhost:5000. And I'll save project.json, and now I have a command available inside of project.json that I can run with k. So before I do that, let me run the application the usual way, which is Ctrl+F5 in Visual Studio. This is going to serve up the application from IIS Express. And now you might remember that this piece of text comes from our configuration sources, and you might remember in the last module that when we set up configuration for this application we told ASP.NET to first look inside of config.json, and there it will find a message, but it can also look inside of the EnvironmentVariables for the process that it's running in. And from there it can find something that overrides what is in config.json. So now coming back to the command line, let me first set up an environment variable. I'm going to say set message=. This is from an environment variable. Let's just call it var. And now let me run k web, and I can see that the server has started. And again, web is just an alias for something that's in my project.json file. I could've called this serve or run or anything that I like. Well, let's come over to the browser, and I want to now go to localhost:5000, which is where I told this to run. And you can see not only is the application running, but it also picked up some configuration from an environment variable. So to summarize what we've done so far, we've installed the K Version Manager, KVM. This tool allows us to manage the current runtime and execute the k utility. The k utility will be able to execute commands defined in our project.json file, and that allows us to write scripts and automate tasks, do things like run tests and database migrations. You will be able to plug all sorts of commands into project.json and give them easy aliases. Now we will return to the letter K later in this module, but before we do I want to look at different set of tools available with Visual Studio 2015, tools that make frontend development easier. Specifically, I want to look at Node.js and Bower.

Silly ES6 Script

Now that I can run my application under two different web servers, one IIS Express and one from the command line, I've decided I want to add some interactivity to the application, some client-side interactivity, and that means I'll need to write some JavaScript. Let's go ahead and write the script. I want to add a new folder to this project, let's call it scripts, and inside of there I will Ctrl+Shift+A to bring up Add New Item, select JavaScript File, and I will call this Silly.js because we're not going to do anything serious for interactivity. I just want to demonstrate a workflow that you can use to bring in JavaScript libraries, write some JavaScript against those libraries, and package up everything for deployment. So let's assume that all I want to do is something like if the user clicks on a div inside of this page I'll show an alert box. So again, very silly functionality. But I'm going to assume that I have jQuery available, so I will write a function that executes when the DOM is ready, and I want to go out and select the divs on the page and wire up a click event that will invoke a clickHandler, which we haven't defined yet, but I can just say clickHandler is a function that will alert This is silly. So again, the idea is not to give a tutorial on using jQuery, but instead a tutorial on how I can get this script into my page, how I can install and use jQuery, and how I can do things like concat and minify files. And to make this even more challenging, let's change this around to use some ES6 syntax. So the next version of JavaScript has what we call arrow functions, which look a lot like lambda expressions from the C# language. So I'm saying here's a function definition that takes no parameters, and in fact here's another function definition that takes no parameters. All I need are the parentheses here and the arrow, or in C# what we would call the goes to operator. Now Joe Eames and I have a course on ECMAScript 6 that's available on Pluralsight. You can go out and watch that to see all of the syntax that is in ES6. It's really going to be a much more powerful language. And you can also see a lot of the tools that you need to use with ES6 because as the world stands right now not every browser and environment understands ECMAScript 6, so I cannot just take this script file and push it down to the client. What I'm going to need to do is transpile this ECMAScript 6 source code into ECMAScript 5 or the current version of JavaScript that almost all browsers understand. I'm also going to have to pull in jQuery somehow and make sure that is put onto the page. And to do all these things, I'm going to switch over to the Node.js environment because Visual Studio now works very well with some of the Node.js tools, so we'll get to see that integration, but also because some of the best tooling for JavaScript is available in the Node world because Node is essentially a JavaScript execution engine, and it's not surprising that the people who have to work in JavaScript full time have developed some serious JavaScript tools. Now that we know what the goals are, let's start talking about some of these tools in the next clip.

Bower for Frontend Packages

To compile and work with our script file, I'm going to be using some Node.js tools that integrate with Visual Studio. My goal is not to give you a complete tutorial on Node. We have lots of Node content on Pluralsight.com. Shawn Wildermuth has a course, and John Papa has a course that actually goes into great detail on one of the tools available, the Gulp tool. But if you haven't worked with Node, I want to give you the quickest tutorial available in the history of Node and give you just enough information to get started. So first of all Node.js is installed by default when I install Visual Studio 2015, and Node is in my path. So I can open up a command prompt, and I can type node, and I am now in a REPL, the read, eval, and print loop that allows me to write JavaScript like 2+2, which is a legal JavaScript expression, and Node evaluates that expression to be 4. So Node.js is simply a JavaScript execution runtime. It's based on the same V8 engine that Google uses inside of Chrome to execute JavaScript. And with Node I can write entire programs. So if I create a file, let me just call it test.js, I can write JavaScript and say let's create a variable called name and then console.log that name, save this and type node test.js, and Node has executed that program. It prints the string Scott. Let me delete test.js, but hopefully that gives you an idea. If you bring in enough libraries and you write enough code, you can Node do pretty much anything. You can turn Node into a web server, and you can use Node to write command line utilities. And in fact many people have written command line utilities for Node. We're about to look at one. It's a utility that I want to install called Bower. So the question would be how do you install libraries to build a web server for Node, and how do you install utilities like Bower, which can manage frontend frameworks as I'm about to demonstrate? Well, generally you do that with npm, which is the package manager for Node. It's very similar to NuGet. I can do npm install and install various libraries and utilities that I can use. Something that I have already installed is this tool called Bower, which allows me to easily work with frontend libraries and CSS frameworks, and I have done that by doing npm install bower -g. That tells npm to install Bower in a global location where I can access it from a command prompt that is open to any folder. So since I've already executed npm install bower -g, I'm not going to show that to you again. It takes a little bit of time to complete. But once it does complete, I should be able to execute Bower. Now Bower is also a package manager. But while npm is focused on packages for Node and writing Node programs, Bower is focused on packages for frontend development, things that you will place into a browser, libraries like jQuery, frameworks like Angular, and CSS-oriented frameworks like Bootstrap. It is also very similar to NuGet. I can do things like bower install, and I might want to install jQuery. Now both npm and Bower have configuration files that can live in my web application. These configuration files will be very much like the project.json file that I have for my ASP.NET application that tracks all of the dependencies my application is using. All of these package managers do essentially the same thing, keep track of what is installed. I can use Visual Studio to add a Bower configuration file that will be able to track the client side packages that I have installed. So I'm going to select the Bower JSON Configuration File from the Add New Item template, and this is yet another JSON file. It's a very simple schema that just has the name of my project. This is private, so it's not something I'm going to publish for other people. And then a list of dependencies. And if I want to install jQuery, there are a couple different ways I could do that. I could come out here and say that I want to install jQuery, and you can see that once again I get IntelliSense inside of Visual Studio, so Visual Studio is going out and searching the Bower repository for all of the known packages. And I could say I want jQuery, and then it will figure out the version numbers that are available. I could select the latest version of jQuery, which is 2.1.3. So I can do that here. I can also do this from the command line. If I type bower install jquery and then add a --save parameter, what Bower will do is go out and fetch jQuery, download it, put it into this project, and then save the fact that I'm using jQuery into my bower.json file. Once this is complete, I should be able to flip back here and see that yes it has placed jQuery into my project. And I can do the same thing to bower install bootstrap, bower install angular, bower install ember. Pretty much any JavaScript library or framework is going to be available through Bower. And Bower does require that you have a Git client available from the command line. Fortunately, Visual Studio also installs a Git client. The only problem I had with my installation is that Git was not in the path. I just had to go out and set my path and add the folder programfilesx86/git. And now I can run Git from the command line, and that means Bower can work. So where does Bower place components? Once it has downloaded jQuery, where does it place things? Well what you will notice, if you look in the folder now, is that there is a blower_components folder. That is where Bower will place things by default. That's a configurable location, you can have it move things around, but you'll notice that is one folder that doesn't appear in my Solution Explorer window. Something has been programmed to hide that particular window. But if you come up and do Show All Files, I can see my bower_components folder. And one of the general ideas is that people usually don't check in their bower_components folder because it's really easy to recreate using Bower. If I delete this folder, I can come back out to the command line and type bower install, and Bower looks inside of the bower.json file, sees oh we need jQuery. It goes out and downloads it and puts it in bower_components again. Now if this is something that you just want to happen automatically, you can add a scripts section to project.json. So coming back to the project.json, I can add a section called scripts, and you can see from the IntelliSense here that I can tap into some events that happen in the development lifecycle of an application. For instance, if I want to execute a script after ASP.NET is finished building my application, I can add a postbuild property here. I can also do a postpack, we'll talk about packing later, postrestore, prebuild, prepack, prepare, prerestore. What I might want to add is a postrestore, that is anytime ASP.NET vNext is going out and restoring dependencies, I want it to also to restore any Bower dependencies that I have. So I can give an array of commands here or a single command. My single command would be to run bower install in this folder just like we did from the command line here to reinstall any packages that might not be available. And now what I can do is I can check my entire application into source control. My project.json and my bower.json files will be in source control. Another developer will come along and clone that repository, load things up in Visual Studio, and when they do not only will my NuGet dependencies be restored, but so will my Bower dependencies. So now what is in my bower_components folder? Well, this is where things get a little bit interesting with Bower because you can bower install just about anything, jQuery, Angular, Bootstrap, Underscore, Lo-Dash, Jasmine, the test runner. But each of those projects might have a slightly different file layout inside of bower_components, so you will always have a folder for the particular package that you downloaded. But inside of that there are no rules. It just so happens with jQuery there will be a dist folder, and it is these files that ultimately I want to get into the browser so that my silly script can work. I want to get jquery.js into the browser, and I want to combine it will silly.js, and I still need to compile that file. How are we going to do all these things? I need to process these files and get them into my wwwroot folder where I serve static assets. And how will I do all this? I will do this with another Node.js tool, a tool called Grunt.

Grunt for JS Tasks

In the JavaScript and Node.js world, there are several tools available that are comparable to MSBuild in the .NET world. These are tools that allow you to define tasks like how to build your JavaScript code or compile your JavaScript code or check your code for errors, minify your code, and concatenate files together. The two most popular tools at the moment are Grunt and Gulp. Of these two tools, I personally prefer Gulp. I believe the programming API is easier to use, and I've also seen Gulp outperform Grunt. But in this video we are going to use Grunt primarily because Grunt is still the more popular task runner I believe at this point, it's certainly been around the longest, and also because it integrates a little bit better with the current Visual Studio tooling. The first thing you would need to do is install Grunt. It is a tool that requires Node.js. And as I pointed out before, Node.js has a package manager, npm. And just like Bower is a package manager but for frontend frameworks, npm is a package manager for things that run under Node. And just like Bower, we can also have a JSON file that describes what Node packages we need installed. So I'm going to add another item to this project. This one is going to be an NPM configuration file. It's called package.json. And inside of here there's some metadata about the version and the name of my project, and then there's also a list of devDependencies and dependencies. Dependencies are things that you would need at runtime. DevDependencies are tools and things that you might only need in development. And just like with bower.json and project.json, I have IntelliSense inside of here. So if I wanted to install something like Grunt, I can just start typing. It will do a search. I can see Grunt is there. And I can ask for a specific version, or I could use the semantic versioning syntax, which will allow me to update to the most recent major version. And that means if I have Grunt caret 0.4.5 listed as a dependency, npm will happily install 0.4.6 if it comes out or even 0.5. If I want to just go by minor versions, there's a tilde that will do that. So lots of different JSON files happening here in our project. And just not to get confused, project.json is what ASP.NET uses. This describes my dependencies; it tells ASP.NET where my wwwroot folder is. We're also using bower.json for the Bower tool. That's going to manage client side frameworks like jQuery. And now there's package.json, which will manage the dependencies I have for Node. So I want Grunt installed, and as long as I have package.json saved I should be able to come out and say npm install. Npm is going to see that I have Grunt listed there. It is going to throw up some warnings when I install Grunt, but everything should be working. And I need to tell there are actually two pieces that you need to install to use Grunt. The first thing you actually need to do is to npm install grunt-cli. So this is the command line interface for Grunt. This will install with a -g flag, which means install this globally. What this will do is put a command inside of a folder that is in my path so that I can run Grunt from anywhere. I can just type Grunt now, and Grunt can execute. But what grunt-cli will do is delegate the actual execution of the tasks that we're going to define to a local copy of Grunt, and that's why I need Grunt here installed locally. That's going to go into a folder called node_modules, which Visual Studio also hides. This folder, just like bower_components, is a folder that I don't necessarily need to check into source control. All I really need to check into package.json, and then when someone pulls down this project, typically the first two things they will do is npm install, which will install any dependencies that I have on Node.js tools, and actually Visual Studio will start listing those things. I need Bower and npm. And what is one of my npm dependencies? Well, it's Grunt. And what is my Bower dependency so far? Just jQuery. But a developer will pull down the source code. They'll do an npm install to get the Node dependencies. They'll do a bower install to get the Bower dependencies. And you might remember that we had Bower dependencies installing automatically thanks to a postrestore step. I could turn this into an array to make sure this just happens automatically and say let's run on a restore, first npm install, and then bower install. That means other developers don't necessarily have to know anything about any of these tools. All the correct pieces are just put in place. But now back to the command line. Ultimately what I'm doing is I'm going to use this tool Grunt to process my JavaScript files, and in order to do that I need what's known as a Gruntfile. You can see the current error on the screen is that Grunt was unable to find a Gruntfile. A Gruntfile is going to define the tasks that I need to execute what are the steps inside of those tasks, what files are modified just like in .NET an MSBuild would describe different tasks that can be executed like a build and a clean and a deploy. So in the next clip we're going to create a Gruntfile and start defining tasks that we need to execute.

Our First Gruntfile

Inside of Visual Studio there is IntelliSense support and error checking support for not only all these JSON files that we are working with, but also for a Gruntfile. So I'm going to Add a New Item to the project, a Grunt Configuration file. I do want it to be called Gruntfile.js, and I do want it to be in the root of the project here. And it's important to understand that this JavaScript code is executing inside of Node.js, so this code is going to look a little bit different than the code that we run in the browser. For one thing, there is a common module system defined for Node, and what this code is doing is when we run this file with Grunt it will export from this module a function that Grunt will call, passing in an object that represents itself, and what we need to do is take that object and initialize a configuration that defines the tasks that we want to execute. Now out of the box Grunt itself can do very little. Anything you want to do, you typically install a Grunt plug-in, and you can go out and search for Grunt plug-ins. You will find thousands of Grunt plug-ins. There are plug-ins to minify JavaScript files, also minify CSS files, to compile TypeScript files, minify images. Pretty much anything that you would want to do in frontend development, there will be a Grunt task for it, and we can install and manage these plug-ins using npm. So here I am at npmjs.com. This is the global repository for Node packages. And the package that I searched for and that I found and that I'm currently fond of is a plug-in called grunt-babel. Presumably this is named for the Babel fish in Douglas Adams' books or perhaps for the biblical Tower of Babel. But the idea behind this plug-in is that it can take ECMAScript 6 code and turn it into ECMAScript 5 code, which is exactly what I need to do with my silly script. And here you can see some instructions on how to install and use this. What I will do is in my package.json I will say that I want to have grunt-babel installed, and I will take anything that is 4.x. Save package.json. In fact, let me save everything including the Gruntfile. And now because we have that postrestore step defined in project.json, grunt-babel will just automatically go into my node_modules folder so I can see it listed as a dependency here. And now I can start defining a task that will compile that file for me. So the typical steps that you follow when adding a task to a Gruntfile is first we'll need to use this object, this grunt object that is passed to this function to load a task. This is effectively saying please go out and find grunt-babel and import that plug-in so it is available to me here. And then inside of initConfig we're going to define an object that has various tasks to execute and the instructions associated with that specific task. So I'm going to define a task here. It's just a property on this object, and it's a task called babel. Whenever this task executes, it will use grunt-babel and follow the instructions that I list in a configuration object here. Now a lot of people just inline the configuration as an object literal right at this point, but what I'm going to do to make things a little bit more sane is bring this configuration out into a separate object. Just one of the things that really bother me about Gruntfiles for more complicated projects is that you can have hundreds of lines of code defining an object literal here, and it becomes very difficult to know where a comma is missing or where a curly bracket is misplaced. But here's the configuration for this task. Most Grunt tasks work with the file system, and you can give the task options so everything is defined with an object literal, but you can give the task options, and then you can also describe the files that this task is going to work with. There's usually a set of source files, and there's usually a set of output or destination files. So it doesn't matter what task you're performing, maybe you're minifying JavaScript files, well you need to specify a source for what file to grab and minify and then a destination for where to put the output. So we'll see this pattern again and again as we define different tasks. What is the source? What are the files that I want to compile? Well, I will define an array. I want you to go to the scripts directory, and let's actually place our ES6 files into a folder called es6. This is just going to make things a little bit easier for this demonstration, and we'll be able to clearly see the output. So there's my es6 folder with silly.js inside of it. I'm going to say go to scripts/es6, and then blob up every JavaScript file that is in that folder or in a subdirectory of the folder. That's the double star. And because this is an array, I could continue adding other folders that I might have in this project where they contain script files that need to be compiled, but in this case there's just one. And so technically I don't need the array brackets here, but I'm going to leave them in just so you know you can specify multiple patterns and multiple paths here. For a destination, I'm going to specify a single file. Let's tell Babel that what is should do is create a folder es5 and just create a single file, scripts.js. And so now when I use Grunt to run this Babel task, it should pick up all the es6 JavaScript files and transpile or compile them into a single scripts.js file that lives in the es5 folder. So let me save this file and come over to the command line and just type grunt just so I can show you the output because now Grunt has found a Gruntfile. But because I didn't give it a specific task to execute, it went looking for a task called default, didn't find it, and basically just quit. I can also type grunt babel, and now it should find that specific task and follow the instructions inside. And I can see it executed that task, and it's done without errors. Swinging over into the project, I can now see a scripts.js, and I can see that this file looks different from silly.js because this file has been transformed into ECMAScript 5 code. So I should be able to send this to any browser, even IE9. But now to actually get this to work in the web page, what I'm going to need to do is put together both the jQuery and this little bit of script and then get it into the page. And to do that and to make things efficient, what I want to do is concatenate this file onto the end of jQuery and then minify the whole thing. That's what we'll do with Grunt next.

Concat and Minify

Now my goal is to concatenate and minify scripts. This is easy to do with some additional Grunt plug-ins. What you'll find generally in this world of Node.js is there's very granular plug-ins to do a specific task, so concatenation is something that I can do with grunt-contrib-concat. I'll take anything that is a 0.x version. And minification, one of the more popular plug-ins for this is a plug-in called uglify because it really makes the JavaScript code ugly. But with those references in my package.json, I can now concentrate on my Gruntfile. And we're going to follow a very similar pattern to what we had before. First I will need to load those npm tasks, so I want to load grunt-contrib-concat, and I want to load grunt-contrib-uglify so these tasks are available for me. I'll need to register the tasks in initConfig, but first I'll create some config objects for each step. So again, files for concatenation. The src will be first of all I have to include jQuery. So jQuery was under bower_components/jquery. There's a dist folder, and then there's jquery.js. And the second file I want to include is that es5 file that was produced by Babel. So use both those files as sources. And then the dest, let's move this over into our root folder so it can be served as an asset. Let's create a scripts folder underneath of there, and let's just have a script.js file as the output. The uglifyConfig is going to look very similar. What are the files that I need? Well, as a src, actually the one and only file that I need wwwroot/scripts/script.js, and as the dest, let's just go to that same folder, but let's call this script.min.js. And now I just need to place these configurations into my configuration object. So when you run the task concat, please use this concatConfig. When you run the task uglify, please use this uglifyConfig. And at this point I should be able to save the Gruntfile, and let's swing over into the command line where I will now try grunt concat. I can see this is successful. It's written a file into wwwroot/scripts/script.js. Let's just take a quick peek. There I can see jQuery has successfully made it into this file. And if I scroll all the way to the bottom, there is my script appended onto the end. So that is good. But now let's minify it to make for an efficient download. Come back out to the command line, grunt uglify, and it has picked up my script file, and I now have a script.min.js. And yes that looks very minified and very ugly, so mission accomplished. Except I don't want developers to have to go out and run these individual tasks each time they change a script file. I don't want them to run grunt-concat, grunt-uglify. There actually is an easy way to do that from Visual Studio so you don't even have to use the command line. Visual Studio now has a Task Runner Explorer that can look inside of a Gruntfile. And we can see oh yeah there are three tasks defined in here. Let me just right-click and run one. And that worked, and that's good. But typically when someone saves a JavaScript file they will want to run all three of these tasks. That's easy with Grunt fortunately. What I can do is define another task using an API registerTask. You can see I get IntelliSense for that. I'm going to register a task called build. And when I register this task, I can pass in a function to define what to do during a build, or I can just pass in an array of other tasks that need to execute when there is a build. So the first thing I would want to do is run Babel. Then I would want to concatenate files. Then I would want to uglify files. And if I save the Gruntfile, this should now appear as one of the tasks in the Task Runner Explorer. And so now I could go out to the command line and type grunt build, or I can just run this from Visual Studio. It's going to go all three of those steps. And then finally to make this even easier, it might be nice to just automatically have this happen as part of a build process. So when ASP.NET builds my web application, I also want to make sure that it runs my Grunt tasks. That I can do using this scripts section. So in addition to postrestore, I can specify a postbuild, in this case just do one thing, which is run grunt build. And now I don't even have to think about doing anything when I make changes to a JavaScript file. All I need to do is edit files, JavaScript files, C# source code files, doesn't matter. When I refresh the browser, Visual Studio and ASP.NET will do a build. That will compile not only my C#, but will also run Grunt over my JavaScript files, and I'll just see the changes in the browser. Then I just need to test, make sure things are working, and I can deploy. Oh, but before we do that, we should probably see if this script even works. Let's go to the view that we created for our HomeController, and I want to add a reference to this file, the minify version. And drag and drop doesn't quite work here. I need to take off the wwwroot part of this path. But now save this file, run with Ctrl+F5. Everything should build at this point. And let's try to click, and great! My new feature is working. Now let's ship it.

KPM and Deployment

In addition to the KVM utility, which can help me manage versions, and the K utility, which can run commands defined in my project.json file, there is also a KPM utility, the Project K Package Manager. This can do things like restore packages, list the dependencies of a project, so I can do kpm list, and it prints out a very detailed list of everything I need, but I can also bundle an application for deployment. Let's do kpm help bundle, and I can see that I can specify a specific runtime, I can specify an out PATH, and I can also specify that I don't want to deploy the source code. I just want all the source code compiled in a NuGet package, and we'll ship that to the server. Now what I'm going to do is I'm going to kpm bundle this application and then deploy it to a server. But instead of doing a Windows server, which you would naturally expect to work, I'm going to push this to a Linux server that I have in Azure. And then we will run this application under Linux and see how that works. You might be wondering why would I ever want to do this? Well things are still a little bit rough around the edges at the current moment. It's not something I would want to do today. But once things stabilize, if I want to host virtual machines in the cloud, Linux servers are often considerably cheaper than Windows servers. So if I can run an ASP.NET application on Linux in the cloud and save 30% per month, that is something I will certainly look into. Now in order to be able to run this under Linux, I'm going to need to add an additional NuGet package to my project. This package will bring in a server that is available on Linux. Let me do a search for Kestrel, and we will install the beta3 version of this tool. I need to accept the license, and of course what that should do is place that dependency in our project.json file. Let me shrink some of these folders up, open up our project.json, and there's Kestrel. And now I want to define a command that will make it very easy to run this application on Linux. Essentially all these tools that we've seen on Windows like the KVM, K, and KPM, they're also all available on Linux, and that means I can use something like k web to start our server that will serve up my application. The problem is I cannot use k web. That depends on the web listener, which builds on specific features in Windows. But I could define another command here, let's call it kestrel, and what I'm going to do is copy this line of code because I'm still going to use Microsoft.AspNet.Hosting. Just the parameters are going to change a bit. Instead of using a Windows-specific web listener, I'm going to use the Kestrel package. And instead of listening on a URL that will only respond to localhost requests, let's actually change this over to my Ubuntu server, so otcubuntu.cloudapp.net. That is the location of my server. So now I have two commands I can run, web on Windows, kestrel on Linux. And if I have everything set up correctly, I should now be able to save this file. Let's come back to the command line prompt, and I want to kpm bundle this application. I want no-source, and I'll specify an output path there. Let's put it in c:\temp\messenger just to make things easy, and this will go off and bundle. I'll be back in just a second. KPM has successfully bundled up my application, and that included a complete build. And because I have a postbuild step registered, that included all of the Grunt tasks that I have defined. But now what I need to do is get this bundle onto my server. Fortunately, when Visual Studio 2015 does its installation, it installs a Git client, and that Git client just so happens to include a couple utilities like SSH and SCP. SCP is a secure copy utility. All I needed to do was add this to my path. So I want to recursively copy from c\temp\messenger. And yes the syntax is a little funny because SCP doesn't like to see c:. But I want to recursively copy everything in that directory to the following server with this username, bitmask@otcubuntu.cloudapp.net, and this is the syntax I use to say place it in my home directory, actually in a folder called messenger that is off my home directory. I will need to enter my password, and now this is off and running. This will take a moment, so we will be right back again. Now that we have everything copied, let's actually connect to that server, and I will try to start a web server. Now obviously there are some prerequisites to getting this to work on Linux. A lot of this work I've already completed. But if I look at this directory, I can see it looks like I have copied messenger up to the server. I also have a directory called mono because I had to download Mono, which is an open source implementation of .NET 4 Linux, and I had to build Mono from the sources. If you do a Google search for running ASP.NET vNext or ASP.NET 5 on Linux, you'll find quite a few blog posts that describes the process you have to go through to reach this point. And it's not too difficult. And once you get Mono running, which I do, you can install the KVM and use the KVM to install a runtime. So you can see I have a single runtime, its beta3 version, it's based on Mono, and that means I can run a k command. I'll want to do that from the messenger folder. And actually I don't have to use k. When KPM packages up my application for deployment, it will include command files that I can use from Windows, and you'll notice these command files match the commands that I have defined in project.json. So in Windows I could just run web.command, and it would use k to execute that particular command from my project.json file. On Linux, the files that don't have an extension are actually scripts, Bash scripts that I can run, so if I run Kestrel, hopefully we'll get a server running. Now while that's booting up, which it did already, I'll just point out that I already have on this machine in Azure a hole in the firewall at port 5000, so I should be able to reach this web server. Well, let's try it. I want to go to otcubuntu.cloudapp.net port 5000, and there's my application running. And for you disbelievers out there, let's take advantage of that feature where I can override a configuration object using an environment variable, so export message="This is running on Linux." Do this, relaunch my web server, refresh the browser, and hey it's a whole new world with ASP.NET 5. In this module, we looked at the tools for ASP.NET 5, including the...

Summary

KVM, the KPM, the K, the Grunt, the Bower. All of these tools are optimized and integrated with Visual Studio now to make it easy to create and deploy applications with ASP.NET. But there's nothing that says you need to use Visual Studio anymore. The integration is nice, but you can also do all of this work with other text editors. And that concludes my first look at ASP.NET 5. I hope you've found the information valuable as you start to make the transition. My goal from the start was to save you hours of time when you were surprised by how different some of these changes are, and then I wanted you to get excited by the changes. I know I am.

Course author

	
Scott Allen

 Scott has over 15 years of experience in commercial software
 development and is a frequent speaker at national conferences,
 and local user groups. Scott is a Microsoft...
Course info

LevelIntermediate
Rating
(1493)
My rating
Duration2h 5m
Released13 Mar 2015
Add to playlist
Share course

