
C# Fundamentals with Visual Studio 2015
by Scott Allen

C# Fundamentals covers all the essential topics you need for developing with the C# programming language.

Course Overview

Hi, this is Scott Allen and welcome to my course on the C# programming language. I've been using the C# language for over 15 years at this point because I love working in C#, and I want to show you all the great features of this language so that you will love it too. In the course we'll work on building some simple applications and focusing on different areas of the language. Like how to use classes, how to write methods and properties, and how to raise and handle events. I'll also give you some tips on how to keep your code readable and tell about common conventions that you'll see in day-to-day programming with C#. We'll also be looking at how to handle errors in your program. And of course, I'll show you a few features of Visual Studio, too. It will be fun for you to follow along. By the end of the course you'll feel comfortable reading and writing C# code in your own applications. I do expect that you have some programming experience before you start this course. Ideally you feel comfortable with concepts like loops and branching in programming. I'll show you how to write loops and branches in C#, but the course will definitely be easier if you know some of these fundamental programming concepts already. And if not, there are plenty of courses on Pluralsight.com to help you get started programming as an absolute beginner.

An Introduction to C# and .NET

Introduction

Hi, this is Scott Allen, and this module is the first module of the course designed to give you everything you should know about the C# programming language. In this first module, I want to spend some time showing you the environment and tools you'll be working with and allow you to get everything set up and installed to write your first simple program. C# is a wonderful and popular programming language that you can use to write programs that run tablets, phones, webservers, and desktops. In this module, we'll start to talk about the syntax of the C# language and the different types of programs that you can write. But before all the fun can begin, we do need to install some software to help us create our C# programs, and we'll get started with that in the next video clip.

Setup

In this course, we will use a tool from Microsoft named Visual Studio to work with C#. Visual Studio is a Windows-only application, but there is a free version called Visual Studio Community. All you need to do is go to www.visualstudio.com and click on Download Visual Studio Community, start the installation running, and take all the default options. After that, you will have installed Visual Studio Community, currently the 2015 version. If you have access to a different edition of Visual Studio, like Visual Studio Professional, everything I'm going to show you in this course will work in there to. And if you're using an older version of Visual Studio, like Visual Studio 2013 or 2010, then 95% of the things I cover in this course will work there too. There are only a few topics near the end of this course that will require 2013 or above. Once you're installation has finished, you should be able to launch Visual Studio and write your first program. But before we jump in, let's take a moment to understand what we have installed.

.NET

Now that I've Visual Studio on my machine, I've also installed the .NET Framework because the .NET Framework is part of the Visual Studio installation. When we write our applications in C# with Visual Studio, our applications run on top of the .NET Framework, and then our applications can take advantage of services and programming interfaces that the framework provides. These programming interfaces include the ability to save information into a database, the ability to read information from an XML file, as well as cryptography, configuration, network communications, and all the basic core features that nearly every application needs, and that means you can use C# to build business applications, to build games, web applications, and apps that run on different types of phones and mobile devices. We commonly think of the .NET Framework as consisting of two distinct pieces. First there is the Common Language Runtime, or the CLR, and there's also the Framework Class Library, or the FCL. Let's talk about these two pieces in more detail.

The Common Language Runtime

In various parts of the course, I'll talk about the Common Language Runtime, the CLR, so it's important to note that the CLR is an execution environment for .NET applications, and that includes applications written in C#. It is the CLR that is responsible for bringing your application to life and managing it while it executes, and it's also the CLR's job to tear down your application when it's finished executing or if it has an unrecoverable error. And here some of the services that the CLR provides when it's managing your application. One is memory management. The CLR is actively tracking all of the memory that your program uses to do work, and it knows when your program is finished with memory, so it will clean things up and allow your program to continue to have enough memory as it runs. The CLR also virtualizes your execution environment, so for the most part you do not need to worry about what version of the operating system that your application is executing on, you don't need to worry about the specific CPU that is installed on the machine, whether that CPU is 32-bit or 64-bit, or how many cores are present, or what instruction set is available. The CLR will take care of all those things and make sure that your application will execute correctly. The CLR was also designed to support multiple languages. You can write programs in C#, but you can also write .NET programs in Visual Basic or F#. In fact, there are many different languages you can use to write .NET applications, and all those applications will be managed by the same CLR. The CLR is available for every version of Windows since Windows XP. There's also a CLR for mobile phones like Windows Phone 8 and a new version of the CLR, the CoreCLR, will even run on non-Windows machines, like MacBook's running OS X and Linux machines. For the most part, you don't care which operating system you are on. Certainly what we will cover in this course will be code that can run anywhere; although, there's always an option to use an operating-specific feature that would tie your code to a specific platform. But, as I said, we'll focus on the features of C# and the .NET Framework Class Library that will work anywhere. And speaking of the Framework Class Library, let me give you a quick overview of the FCL.

The Framework

While the CLR works in the background to manage your application while it is running, it is the Framework Class Library of .NET that you will interact with on a day-to-day basis because it's the FCL that contains reusable software that you use to build applications. It provides you all the functionality to do useful work like use regular expressions and read and write data from a disk. You will also hear people refer to the BCL, or Base Case Library, which technically is a subset of the FCL. It's contained inside the FCL, but it's a subset so it doesn't contain quiet as many features, but it does work everywhere, and that's what we'll be using for this course, the subset that works everywhere. But chances are when you start building your own applications you'll be using pieces of the more expansive Framework Class Library because it is the Framework Class Library that includes software to help you write desktop applications and web applications and web services and apps. The FCL is so large and so varied that it is rare for one person to know all the ins and outs of the entire library. Typically you're going to focus on just a couple areas of the FCL and master those. Like you might become a master of ASP.NET to build web applications because that's what your business requires. ASP.NET is just one part of this .NET Framework. And now that we know that we're using C# on top of .NET, and .NET gives us the CLR to run our applications and the Framework Class Library to give us software components to build on, let's make this all a little more concrete by writing our first C# program.

The C# Language

C# is one of the languages that you can use to write applications with .NET, and the syntax of C# was inspired by C++, so C#, Java, and JavaScript, all three of these languages look somewhat similar. Here is a snippet of C# code. This snippet contains many different concepts that we will investigate further throughout this course, but let me give you a quick preview. This snippet of code is defining a method named Main. A method is a place where you can organize your code so that you can call this method from other places and force the code inside to execute and run. The code inside of this method is using the DateTime class, which is part of the .NET Framework Class Library. I can use DateTime.Now to find out the current time, and I can use .DayOFWeek after that to find out the current day of the week. And if the current day of the week is equal to Monday, and we'll check that by using a double equal sign, that checks to see if two values are equal, if the current day of the week is Monday, then we will branch inside of this if statement and execute the code inside of the curly braces. Inside of here we're calling another method, WriteLine. This method is attached to a console class, also part of the FCL, so we're forcing WriteLine to execute, and we're passing it some data, a parameter. We're passing it information that is going to write onto the screen. In this case, it's going to write out the text, Another case of the Mondays! But again, that only happens if the current day is a Monday. If the current day is not a Monday, we don't execute the code inside of here. We come straight down to the bottom where the method will exit and return without writing any information to the screen. Let's take code very similar to this code and place it into a program that we can execute from the command line.

Hello, World

Inside of Windows I'm going to go to the Start menu, and I'm going to do a search just by typing for command because what I want to open up is the command prompt. We're going to write our first program using some low-level tools and without Visual Studio just so you can see a little bit about what is happening behind the scenes. When you install Visual Studio, Visual Studio will install some command line tools that you can use to create applications. Not many people will use the command line tools on a day-to-day basis, they'll use Visual Studio instead, but what I'm just trying to do right now is simplify some things. So I'm going to go into my Documents folder, and I'm just going to use notepad to create a file called hello.cs. The goal is to create the canonical hello world example, something I can run and just print the string hello world to the screen, and I'll do that by placing my code inside a file called hello.cs. Dot cs is the common extension for C# source code. All of the .NET tools and every .NET developer will know that a .cs file will contain C# source code. And inside of here I'm going to create a class. So there are many concepts that we're going to have to come to grips with in this very simple demo, things like classes and strange keywords, and we will cover all of these things in detail throughout this course. For right now, just know that most of the code that you write for .NET will live inside of a class. And inside of a class I can create methods. I'm going to create a method called Main. The start of this method begins with this opening curly brace and ends with this closing curly brace. Just like with the class, anything I put between those outer curly braces will be part of this class or inside of this class, and now anything I put inside of this Main method will be code that executes when I run this program. And that's because there's a little bit of magic happening here. When the CLR starts a command line application, what we call a console application, something that I would run from the command prompt, it will automatically look for a program class with a Main method and just start executing the code inside of there for me. So if I were to place inside of here something like System.Console.WriteLine, Hello World, then this is something very similar to the code that we had on the slide. We had Console.WriteLine. What's new here is this System word, and this System word exists because inside of .NET there are thousands and thousands of classes that I can use, classes like Console. And we don't want all 10,000 or more classes available at one time, so what .NET does is it partitions classes into various namespaces. And to use a class, you have to be very explicit and let .NET know from what namespace that class lives in. So to use the Console class, it lives in the namespace called System, so I either have to use the word System here or there's another way to tell .NET about the namespaces that I need, and that is with the using keyword. So if I say using System and a semicolon, and yes there are certain pieces of code that have to end with a semicolon and certain pieces of code that don't need a semicolon, we'll talk about that more throughout the course, when I say using System, I'm telling .NET and this tool we're about to see, known as the C# compiler, that when it encounters classes inside of this program, classes like Console, it should look for them inside of the System namespace. And this is about the simplest possible C# program that I could write. I'm going to save this file and come out to the command line and run a tool called csc.exe. This tool exists, by default, in my Windows directory under a folder called Microsoft.NET. Inside of there, there will be a Framework folder, and then inside of a Framework folder you can have various installations of the .NET Framework, multiple versions. And if I tab through here, you can see I have various versions installed, version 1, version 1.1, version 2. I want to go to the latest version, which is the version 4 directory because inside of there, there will be a little program that I can run called csc. Csc, as you can see, is the Visual C# Compiler, so C# code is code that needs to be compiled before it can execute. This is unlike some other languages, languages like Perl, and Ruby, and Python. What I need to do with the C# code is pass it through the C# compiler, and what the C# compiler will do is produce an executable that I can run. So if I say csc, and then follow that with the parameter hello.cs, I'm asking the C# compiler to compile hello.cs. And if the compiler encounters any problems, it will complain, but it looks like it finished successfully. And inside of this folder now I can see hello.exe, so the act of compiling hello.cs produced hello.exe, and the exe extension means this is a executable file, something that I can run from the command line. And if I run it just by typing in hello.exe, I get Hello, World! Now as I said before, typically you don't use csc directly. Instead, you use Visual Studio, and Visual Studio will figure out the way to call csc correctly. But I do just want to point out that csc might give you some error messages. So, for example, let's say that I forget the semicolon after using system, and I recompile the application. The C# compiler here is very explicit, and it says semicolon was expected on line 1, column 13. Unfortunately, not all error messages are so explicit. Let's come down and leave off an opening curly brace here on my method because now the C# compiler won't know where this method starts. And if I save that file and try to compile it again, this one missing character actually generated three different error messages, is telling me a semicolon was expected, and there's an invalid token. And over time you'll become accustomed to these error messages and become accustomed to looking at your C# code and figuring out things like, oh I just had a missing curly brace here. And if I save this file again, we should be back in working order, but let's make one more change. Instead of displaying the text Hello, World, let's use some more code from that previous slide, and I want to print out the current day of the week. And I can do that by using the DateTime class. That DateTime class is also in the system namespace, so it is available to me. I can have multiple using statements here, but the only classes I'm using for this simple example are classes that are in the System namespace. I'm going to say please print out DataTime.Now.DayOfWeek. And I'll save hello.cs again. I need to recompile it for csc to pick up those changes and produce a new executable, but now I should be able to run hello.exe. And you can see that this example is being recorded on a Wednesday. So this simple example has a lot of very deep concepts, concepts like classes and strange keywords like static and void. I want you to ignore some of those specific syntax details for right now. We'll get to the point where you can understand all of those. For right now, I just want to take a step back and talk about this compiler that we're using, and after that we can jump into Visual Studio and get the same code running from Visual Studio.

The Compiler

We've just used the command line C# compiler, csc.exe, and we gave the compiler one job that was to compile a single file, hello.cs, but you can tell the compiler about multiple files to compile all at once. And certainly when you start building real applications you don't want all of your code inside of a single file. You'll take all of your code and spread it across multiple files, even across multiple directories, and pass everything to csc.exe, which will produce a single executable or library. When it comes to using multiple files, this is where Visual Studio is useful because Visual Studio can manage all of those files and call the compiler for us, and we never have to worry about the details, but it is good to know what happens behind the scenes. And it's also good to know with the C# Compiler is actually doing. It's taking your C# code, and its transforming it into something called Microsoft Intermediate Language. Some people will refer to this as M-S-I-L, or MSIL for short. MSIL defines instructions for the CLR. It's the CLR's job then to read those instructions and transform those instructions into instructions that the CPU on your machine will understand. So the processor that is inside your computer by itself, it cannot execute the code that you write with .NET even after the compiler has transformed that code into an executable. You need to have the CLR, the Common Language Runtime, to take those intermediate instructions inside an executable and transform them into native instructions, native meaning the instructions work on the real hardware where the program is running. All of that happens without us needing to do anything special, and it's somewhat similar to what happens in the Java space, with Java compilers producing bytecode as an intermediate language. But now that we know some of these low level details that are good to know, let's jump up into the space we'll be working in for the rest of the course, which is inside of Visual Studio.

Visual Studio

Now let's go into Windows and open up the Start menu and search for Visual because I want to launch Visual Studio 2015 and create this hello world program in the Visual Studio environment. And pretty much every application that you ever build with Visual Studio will start by saying File, New, and then selecting this Project menu item. This will launch a dialogue that presents me with many different project types that I can build across various languages that are supported by Visual Studio. But I want to build a Visual C# application, specifically a Windows application, and even more specifically a Console Application, so an application that runs form the command line. Down here at the bottom of the dialogue I can select a Name for my project, I'm going to call it Hello, and I will leave it inside of this default location, which is a project subfolder underneath of documents/visual studio 2015, but you can place this anywhere on the hard drive that you like. I will just select OK, and Visual Studio will go out and create this project for me. Now depending on your configuration, you might have different windows that open up inside of Visual Studio. I just really want to focus on one for right now, which is the Solution Explorer window. I'm going to close everything else. And if for some reason you don't have the Solution Explorer window or you accidently close the Solution Explorer window, you can always reopen this by going to the View menu. Selecting this item will open that Solution Explorer window if it's not already open. The Solution Explorer window is a window that organizes all of my code and all of my projects. So the currently highlighted node in this tree in the Solution Explorer, this is my project. It's called Hello. Inside of that project I have one source code file, one C# source code file called Program.cs. I can click on any .cs file inside of Solution Explorer, double-click on it, and it will open over here in a text editor window. And in bigger applications you'll have multiple .cs files inside of a project. In fact, you'll probably have folders inside of your project and organize your source code files into folders. And then project goes into a Solution, also named Hello, and in a larger application you can have multiple projects inside of a Solution. We'll see both of those scenarios as the course progresses. We'll work with multiple source code files; we will work with multiple projects inside of a Solution. For right now, I just want to focus on Program.cs and recreating our Hello World application. So the code that is inside of Program.cs looks a little bit different then what we wrote inside of Hello.cs. For starters, there are quite a few namespaces that are listed here. These are just namespaces that Visual Studio included by default because these are common namespaces that you typically use on a day-to-day basis. There is no harm in leaving these namespaces here, but for right now I'm just going to delete all of those namespaces. And then I'll point out that I also have a custom namespace here. The namespace is Hello. Everything inside of the curly braces that delimit this namespace will be a part of that namespace, so my class Program, it's full name now is not just Program, it's really Hello.Program. And this program still has a method named Main, just like we had in Hello.cs. We'll talk about this additional args thing here in just a minute. For right now, I just want to use Console to do a WriteLine. And now we'll start to see one advantage of using Visual Studio over Notepad. Visual Studio is constantly evaluating the code that you're writing with every keystroke, and it's trying to detect anyway that it can help you write that code or if there's any problems with that code. Right now it has detected a problem. It'll express that with a red squiggly line that appears underneath of Console. And the problem here is that Visual Studio knows if you try to compile this file that the compiler will not know what this Console thing is, and that's because, as we discussed earlier, this Console class that we want to use, it's really system.console. And if I come over here and click on this lightbulb, then whenever you see that lightbulb appear you can click on it. That's Visual Studio's way of saying I might be able to help you with this problem, and it will give you a big list of suggestions on how to fix this problem that Console does not exist. The first suggestion is to add a using System to the top of the file. That's the suggestion that I want to take because once I choose that the red squiggly goes away, at least the red squiggly that's under Console, and now Visual Studio's just telling me that I need to do something with Console. So let me backspace a bit and then hit period, and here's another way that Visual Studio tries to help you. This is the IntelliSense window. Visual Studio knows about everything that you can do with a Console. It knows that you can do things like set the cursor position, and it knows that I can do things like WriteLine, so I'm going to select this method just by pressing enter because I want to write the string Hello, World. So a string in C# is just a sequence of characters that appear between double quotes. Almost every programming language has the concept of strings. Some languages use single quotes, some languages use double quotes, C# is one of those languages where a string has to be inside of double quotes. C# is also a case sensitive language, so Console, the C has to be uppercase; otherwise, you can see I get the red squiggly. And the method call WriteLine, that has be an upper case W and an uppercase L. But since I don't currently have any red squigglies on the screen, I should be able to run this program. The easiest way to run a console application is to go to the Debug menu and say Start Without Debugging. Visual Studio will automatically compile all of my source code, it will produce an executable, and then it will launch that executable inside of a new console window. Visual Studio is also smart enough to add a feature where you have to press a key for this console window to go away. If that feature wasn't there, the console would just flash on the screen and go away immediately because my program exits immediately after displaying Hello, World. But now that I can see this running, I will press any key, and now I can come back and edit some more source code. I also want to run this directly from the command line myself, and I can do that. I can see down here in the Output window, which will appear anytime you build or run an application, I can see in this window exactly where Hello.exe lives. It's underneath of the location that I specified in the File, New, Project dialogue, and then it falls under a folder called Bin, which is short for binaries, which are executable files that are on file system, bin\Debug\Hello.exe. The Debug is here because by default Visual Studio will build your application in a way that makes it easy to debug, that is easy to find problems and errors that occur during runtime. We'll look at debugging in just a bit. For right now, I actually want to go to a console window and find this directory, which is Visual Studio 2015\Projects\Hello\Hello\bin\Debug. And if I do a directory of this folder, I can see inside of here, Hello.exe. There are some additional files here, but again most of those are related to debugging. I just want to be able to run Hello.exe from this folder and see that still works. And I'm thinking it would be nice to be able to type Hello and run this program and also pass this program a parameter like the name of a person so the program will say Hello Scott or Hello Alex. Currently I don't have that ability. Every time I run the program it will just say Hello, World, but this is easy enough to change. Whenever I type additional arguments to my program, those arguments will be passed into my Main method in this method parameter names args. So just like WriteLine takes a parameter and I can pass it something like Hello, World, this Main method can take a parameter. In this case it is an array of strings, and the name of this parameter is args. We will be talking in more detail about arrays later in this course, but for now just know that inside of a console window I could do something like Hello Scott, Joy, Chris, Sarah, and I could keep typing words out here, and when my program runs each of these will be an individual string inside of a collection of strings. And this is the syntax in C# to say I don't have just one string, I can take 0 or more strings. So if someone wants to pass me three names, those three names will be packaged up into this parameter called args. Again, more on arrays later in this course, but these two square brackets indicate that I have an array of strings. My ultimate goal is to pull out just the first string in that parameter and use that to write out a greeting here. So let me show you something else I can do. Just before we do that, I'm going to add a double quote here after Hello comma and a space, and then use the plus sign or an addition symbol to say Hello plus World. The addition symbol does what you might think it would do. It's going to concatenate those two strings together so that I get one string, Hello comma space World. And if I were to run this program Without Debugging, I get the same output that I had before, Hello, World. But now let's get this working with a name. So instead of concatenating this hard-coded string World, I want to take the first argument out of this argument array and concatenate that after the string Hello comma. Arrays in C# start with a base index of 0. That means to get the first element in an array you use the square brackets, and you place a 0 inside. It's a common beginner mistake to ask for the first element of an array by using args sub 1, but sub 1 would actually give you the second element in an array. I want args sub 0. And after I do that I'm going to save the file, come back to the command line, and type Hello Scott, and you'll notice I still get the text Hello, World. That's because I was very careful to just save this program and not recompile the program, which means my source code is different. But I never had Visual Studio build that source code into a new version of Hello.exe, so I'm still running an older version of Hello.exe, I don't have a new one yet. If I want to make sure that Visual Studio builds this, I can go to the Build menu and say Build Solution. When you run the program from the Debug menu, Visual Studio automatically does the build, but if I'm going to run from the command line like this, I have to explicitly ask Visual Studio to build, and now I should be able to come out and say Hello Scott, and I can see Hello Scott, or Hello Joy, and I see Hello Joy. And I now have a program that accepts some command line parameters from the user and uses those parameters to change the display, to change its output.

Debugging

Let's talk about the types of things that could go wrong when you're writing a C# application. There are two general categories of errors. The first type of error, sometimes the easiest type of error to fix, is when you have an error that will not allow the C# compiler to compile your code. And these can be easy problems to fix because Visual Studio can show you little red squigglies when you're missing something like a semicolon or if you're missing something like a curly brace. And perhaps I have an error like this where I'm missing a curly brace inside of a source code file that I don't even have open and I cannot see the red squigglies. In that case I might think I'm okay and try to build the solution, but I will get an error list that shows me output from the C# compiler. And this output is saying that there is a curly brace expected, a closing curly brace somewhere. Any time this error list window is open I can double-click on a line inside of the error list, and Visual Studio will open the file that has the error and put the cursor on the position where the C# compiler thinks the error is. And we looked at this scenario earlier in the module. Some errors the C# compiler can be very specific and say you are missing a semicolon at this exact location. In this case, it's just telling me I'm missing a curly brace. It's not really sure where that curly brace should be, but it does know that the count of curly braces doesn't add up. There are three opening curly braces, but only two closing curly braces. If I just type a curly brace down here at the bottom of the file, you'll see that Visual Studio is smart enough to say, oh this is working now. It reformates my code, puts all the curly braces in the right position, and I should now be back to having a working application. So any time the Error List window opens up, just double-click on an error in this table of errors, and Visual Studio will take you to the location where you can start to look around and see what needs to be fixed up. The other type of error that you can commonly encounter when writing a C# application is a runtime error. Let me show you an example of what one would like. Let me build this solution again just to make sure we are up-to-date, and I'm going to come out and run this solution Hello without passing any parameters. That means the argument's parameter, the string array that is passed into Main, will be empty. There are no arguments available. So when I run the program, all sorts of catastrophic error messages pop up. I can see in the command line window that there was an Unhandled Exception. We'll be talking more about exceptions in this course, how to both generate exceptions when your application logic detects something has gone wrong, as well as handling exceptions at runtime so that they don't crash your program. But here we have a program that doesn't handle any exceptions. That means an error occurred inside the application, and the runtime, the CLR, is going to shut down the application so that it cannot continue. It's usually not a good idea to allow a program to continue executing when it has some sort of fatal exception. Windows has detected that something has gone wrong also, so it pops up this message box, but let me dismiss this and talk to you a little bit about the debugger. So when you have runtime errors inside of your application, sometimes you need to do a deep investigation of what is actually happening inside of your application, and that's when the debugger is useful. The debugger allows me to step through line-by-line all of the code inside of my application, and inspect variables, and inspect the environment, and try to figure out where the logic has gone wrong. When you use the debugger, it's very useful to set breakpoints inside of your application. Breakpoints allow you to stop the application right on a specific line of code, and then you can start inspecting the environment. To set a breakpoint, just come over out here on the left hand side of the editor window, this grey strip that I have here, and I can click here, and now I have a red dot. That is how Visual Studio tells me that I have set a breakpoint on this line. And now I can come into the Debug menu, and this time instead of Starting Without Debugging I'm going to Start With Debugging. I could also just press F5. And Visual Studio is going to launch the application, and it's going to stop execution right on this line of code. Down here in the Windows menu, I can see the application running. It hasn't produced any output as of yet because we've stopped the program before it got to the WriteLine statement. And inside of Visual Studio I've had all sort of windows open up. I'm just going to shut down a few that I don't really need, and I'll show you just a couple of things. First of all, by default, you should have an Autos window that pops up. This Autos window will show you some of the variables that are available in the current context where you're debugging. Right now the only real variable I have is the parameter args, and I can see the value for this is string with a 0 inside of the square brackets. That's the debuggers way of telling me that args is a string array, and it's a string array of length 0. That means there are no arguments inside. I could also do that by hovering the mouse over args. So anything in a C# application that is holding data, you could put your mouse over this symbol and get this little popup window that shows you what's inside of a particular variable or data structure. And once you have stopped execution at a breakpoint and you've inspected some things, you might want to resume the application running. There are a couple of ways to do that. I can us the F10 and F11 keys to step through my program, that is step line-by-line. If I'm inside of a method that's calling into another method, F11 will Step Into the lines of code inside that other method. If I just want the debugger to execute that method and then give me back control when that method has finished executing, I can use this Step Over command. And if I think everything is going to work and I just want to continue with the application running, I can just press F5, and the application will execute until it hits another breakpoint. Let's try the Step Over command, which is F10, and I can see that this little yellow arrow has advanced one line. You can think of that yellow arrow as an instruction pointer. It's showing you the current instruction or the current line of code that's going to be executed. And now I'll just use the shortcut key, F10, to try to step over this line of code, and this is the line of code that's generating the exception. And now since I'm in the debugger, Visual Studio is going to halt execution there and pop up a dialogue that will tell me I'm getting an IndexOutofRangeException. So that is something that you get when you try to index into an array and you try to grab an element that doesn't exist. So this code is using args sub 0, it's trying to get to the first element of the array, but unfortunately args, as we saw before, is a completely empty array so there is no first element, and that's an error condition that in this scenario is going to force my program to crash. Something has gone wrong, and the CLR won't allow my program to continue executing. So let's go into the Debug menu and Stop Debugging. Now one question you may have is how can I pass in some arguments when I'm running from this Debug menu? It's very easy to do when I'm running from the command line. I can just type Hello Scott or Hello Joy, but what about when I'm running with the debugger? To do that, I'm going to go and click on the project Hello. In fact, I'm going to right-click on that project. Pretty much everything in Visual Studio you can right-click on to get a context menu, and in this case what I want to do is open up the Properties for this project. This is going to open up a window that shows me all sorts of configuration and build-related settings for my application, what's the target framework, what's the name of the executable it's going to produce. There are lots and lots of settings inside of here, but I just want to, for now, focus on the Debug settings. And in the Debug settings you can see that there are Start Options where I can specify command line arguments that I want past to this program when I'm running with the debugger. So let's pass in Scott, and I'll close this window, and now let me press F5 to run with the debugger. We're going to stop on our breakpoint again. This time I can see that args is a string array with a length of one, so there's something inside of args. I can expand this and see that the first element inside of args is Scott. I can also mouse over args and do the same thing here. And if I press F10 a couple times, I can see that I stepped over two lines of code, and I should be able to see Hello Scott. If I come out here to the running program, I can see that it produced the right output. So let me just press F5 to continue running, and the program will exit.

Are You Sleepy?

Now that we know a little bit more about Visual Studio, let's create a more interesting program. What I want to happen is instead of forcing the user to pass in their name as a command line parameter, I want the user to be able to start the program running without any command line parameters, and then the program will prompt the user and ask them to enter the user name. So I want to accept user input as the program is running, and this is something that I can do with another method on the Console class. This method is Console.ReadLine. So WriteLine puts something onto the screen; ReadLine will allow the user to type characters and then press the return key, and ReadLine will take those characters, put them into a string, and return that string to me. That's what his IntelliSense window is trying to tell me. The return value of calling this Console.ReadLine method is a string, so I will need to take that string, and I will need to save it somewhere so that I have access to the user's name later inside of this method. That's when I can declare a variable. C# is a typed language, so I need to have type for every variable that I define. In this case the type is string, and the variable is called name. And we'll be talking in a lot more detail about the types of variables that you can have, but for now you can effectively think of this name variable as holding on to that user input so that I can use it later. Name will be available anywhere else throughout the rest of this method after it's been defined. I want to say Console.WriteLine Hello and then plus the name. Now it would probably also be a good idea before I accept that user input to write out something that tells the user they need to input their name. So let's just WriteLine, Your name, and then read the result of that, and then echo it back out, Hello plus name. Let's try this real quick. I'll do a build just by hitting the shortcut keys Shift+Ctrl+V. Let's come out and run the program. I'm just going to type Hello this time. It's going to prompt me for my name. I will type in Allen just to try something different, and we get Hello, Allen. Very good. Let's take this one step further. Let's try to find out if the user had enough sleep last night. We'll just basically ask how many hours of sleep did you get, and then use some logic to determine if the user is well-rested or not. So first let's do the prompt. I want to WriteLine something and ask the user, How many hours of sleep did you get last night? And now I expect the user to type in a number, a number between let's say 0 and 24, and I want to store this value so I can inspect it later and figure out if the user got enough sleep to be rested. So because I expect the user to type in a number, I'm going to this time declare a variable as type int, which is short for integer. This will be a variable that can store a number, hours of sleep, which would be a common naming convention for a C# variable. Variables that you define inside of a method, they always start with a lower case letter. If they contain multiple words in that name, then you upper case the letters of those words. That's a little bit different from class names, which always start with an uppercase letter and method names, which always start with an uppercase letter. So now I have this integer variable, HoursOfSleep, that can store the amount of sleep that a user has. Let's try to do another Console.ReadLine to allow the user to input this value, and you'll notice that I get a red squiggly inside of Visual Studio. If I hover over that line, I will see the problem here, the error message. It says it cannot implicitly convert type string to int. So C# is a typed language, and not all variables are compatible. If you try to assign something like string to an integer, Console.ReadLine returns a string, a sequence of characters. It could be anything like ABC. How can you possible take that value and put it into a variable that holds a number? That's something that the C# compiler and the runtime just won't do for me automatically. I have to do some explicit conversion. I need to take this string and turn it into an integer. That's something that I can do by invoking a method on int. It's a method called Parse. You pass in a string, and Parse will try to take that string and turn it into an integer value. So the user types in the characters 1, 2, int.Parse will turn that into the number 12. The user could also type in the characters A, B, C, and int.Parse is going to through an exception and crash the program because it cannot convert A, B, C into a number. We'll talk about how to deal with that type of scenario later in the course. For right now we'll assume that the user is a good user; they always type in numbers. And now I can make a determination if the user has enough sleep or not. Let's say that if the user has more than eight hours of sleep that they should be well-rested, so we want to write a message that tells them they should be well-rested. Let's do this after we say their name. I want to say Console.WriteLine, You are well rested, but remember I only want to do this if the user had more than eight hours of sleep, and this is a place where I can use an if statement in C#. If allows me to write an expression that will evaluate to true or false. So if hoursOfSleep is greater than eight, then do what is inside of these curly braces, so I want to take this Console.WriteLine method and cut it and move it inside of that if condition. And now what if the user didn't have more than eight hours of sleep? Well then I can use the else keyword. If else logic is very common logic in a C# application. You can say if you meet some condition do this; otherwise, do this other thing. The other thing could be that we could Console.WriteLine, You need more sleep. And now we have an application that not only takes some user input, but also branches the execution of the application in different directions depending on that input. And let's just run this with the debugger to see how it works. I'll press F5. We will hit our opening breakpoint here at the beginning of the program. Let me F10 over a couple of lines. We hit the ReadLine statement, and Visual Studio is smart enough to switch over to the application and show it because it's expecting some input here. I'll put in my name, which is Scott. I can use the mouse, hover over this, see that name does contain the value Scott, that's good. Now let's get the number of hoursOfSleep. Let me enter the value nine. Again I can hover over hoursOfSleep, see that there is a nine there. We will WriteLine out the name, and now you can watch this: If hoursOfSleep is greater than eight, I press F10. Yes, we're going to branch into that condition, and we will Write.Line You are well rested, and we will skip the else part. So I only get to execute one of those two branches. And let me just flip over to the program. I can see it produced the right output, Hello, Scott You are well rested. So I will press F5 and allow the application to finish executing, and then the debugger exits, and I can go back to editing some source code. And now I encourage you to try out this same program, and try it out with different inputs, see what happens if hoursOfSleep is less than eight, see what happens when the user enters characters for the hoursOfSleep, something like ABC, see how the program crashes and how it behaves. Try some of these things until you are comfortable with Visual Studio and the debugger, and then you can move on to the next module.

Summary

In this first module I intended to introduce you to Visual Studio and get you up and running by writing a simple program. This program gives you an idea of what the C# language looks like. And we talked about quite a few concepts, concepts like classes, types, variables, expressions. Those are all topics that we'll cover in more detail throughout the rest of this course. What you really want to do right now is try your hand at writing that same program and just getting familiar with the Visual Studio environment. Make sure you know how to create a new project, edit some source code, save a file, build a project, and run with the debugger. Learning those basics will help you move a little bit quicker in the rest of the course.

Classes and Objects

Introduction

Hi this is Scott, and this module is about classes in C#. Classes allow us to module the world around us in software. We create custom classes to represent purchase orders, automobile parts, employees, accounts or spaceships in a game. Anything you need to write software about, you can create a set of C# classes to help. In this module, we'll talk about the relationship between classes and objects and start to learn how you can use C# as an object-oriented programming language.

The Grade Book

When you sit down to write a class in C#, it's usually because you need to write some code to create a program for something that you need or something your business needs. So pretend someone comes to you with the following requirements: We need an electronic grade book to read the scores of an individual student and then compute some simple statistics from the scores. The grades are entered as floating point numbers from zero to 100, and the statistics should show us the highest grade, the lowest grade and the average grade. These requirements describe the program we need to write, but where do we get started? Well, fundamentally, C# is a language where you write classes to implement features in your software, so these requirements will force us to write at least one class and to use other classes that have already been written for us by the framework class library. But what class should we write? This is one of the toughest questions to answer if you are new to programming. But generally, we use classes to create abstractions for the different nouns that we need to work with, or a noun is a person, a place, a thing, an idea. So when I scan through the requirements, a noun like grade book will instantly jump out at me because it is a noun that the business is using. It's in the requirements, and it would seem like a good place to get started is to create a class named grade book that will implement the functionality to store grades and compute statistics. Let's get started on these requirements by creating a new project. So once again, I'll go to the File, New Project menu. Once again, I want a console application, and I'm going to give the project the name Grade, with the capital G. I'll let Visual Studio create this project for me and Visual Studio will give me my first class. The program class, just like we saw in the last module, here's the mean method on that program class. That's the entry point for the application, and that's where I want to use a grade book class that I'm going to create. So where do I put the GradeBook class? Well, it's perfectly legal to define multiple classes inside of the same file, but most C# developers will follow a convention where each class gets its own individual file. So I'm going to right-click the project that opens up this context menu, and then I can say let's add a class to this project. The dialog that opened contains a number of templates for all sorts of different things that you can add to a project, but I just want to add a class. And down here, I can give that class a name, give this file a name. It's going to be GradeBook.cs. And by convention, the file will have the same name as the class. So Visual Studio has already given me a class definition here. The class is GradeBook. A class definition always starts with the class keyword and then the name of the class. Everything between these curly braces then will be what we call members of this class, just like this class is nested inside of a namespace called Grades, so GradeBook is a member of grades. And here at the top, we have a number of using statements. We won't use classes from all of those namespaces, but I'll leave them there because they don't hurt anything. And now inside of GradeBook, anything that I add here will be a member of the class. And class members broadly fall into one of two categories. One category would be members of this class that hold state or data, because state is the data that you need to work with inside of the class. The state for GradeBook would be the grades that a user is entering for a student. So somewhere inside of this GradeBook, I'm going to need to store each grade as it is entered, and then the other category of class members would be behavior-related members, that is members that do work. These members are typically methods, methods that I want to write to allow someone to interact with a GradeBook and ask it to do something like add a grade or compute statistics. The class is a noun, and methods that do work on that class are typically verbs, like AddGrade, ComputeStatistics. So they are members that start with a verb. And let's start by adding a member that will allow me to add a grade into the GradeBook. I'll do that first by using two C# keywords, public and void. We will circle back later and talk about what those two keywords mean, and I'm going to create a method called AddGrade. It's a method because it's going to have parentheses at the end. And then there's an opening curly brace and a closing curly brace. Everything that goes between those curly braces will be the code that executes when someone invokes this method and executes this method. The parentheses here contain the parameter list for this method, that is, what is the data that someone wants to pass into this method? Right now, this method doesn't take any parameters, but obviously when I want to add a grade to the GradeBook, I will need to take some data, which is the grade, and I could do that by asking someone to pass in an integer value. Let's call it grade. And you can see that defining this parameter is very much like how we defined a variable in the last module. I have to give that parameter a type, which is integer, and I have to give that parameter a name, which is grade. But in this case, the requirements did say that these grades would be floating point numbers, and integer is not a good way to hold a floating point number. There's a couple other classes that .NET provides that I should use for floating point numbers. There is double, which is a double precision floating point number; and there's float, which takes up less space, it's a single precision floating point number. And for this application, float should be good enough. We'll have a high enough precision. And at this point, this grade variable will be available throughout the rest of the method. We say that it is scoped to this method between these two curly braces. I cannot use it anywhere outside of those curly braces, but I can use this parameter, grade, which I can just think of now as a variable anywhere inside the curly braces. I could, for instance, say grade = grade + 5. That would add five points to every grade before we store it, but I don't need to do that. What I really need to do is store this grade, make it part of the state of this class. I don't know how many grades someone will pass to me ultimately. They can invoke AddGrade 10 times. I would need to store all 10 grades. And I'll need access to those grades outside of this method, outside of AddGrade, because when someone calls a different method, ComputeStatistics, the parameter grade won't be available. So I need to store that somewhere. And to do that, I'll use another class from the framework class library, one that is in the namespace System.Collections.Generic. As the name of that namespace implies, this namespace is full of collection classes, that is, classes that allow you to store multiple things. One such collection is the list collection. A list can store zero items or 10 items or 1000 items. But before I can use a list, I have to tell the list what type of items it's going to be storing. Is it going to be storing a list of strings or a list of integers? Or a list of floating point numbers? That's what I want because the grades are being passed to me as floating point numbers. Later in this course, I'll describe exactly what this syntax means, this syntax with the angle brackets. It's part of what we call the generic type syntax in C#, but that's a preview for a later module when I talk about generics. For right now, you can think about this as a list that can hold zero or more floating point numbers. And this is going to be one of the members of the class that holds the state for the class. It's what we would call a field. So right now, we have a method called AddGrade, and this is going to be a field. And just like a method, this field has to have a name. I'm going to call it grades for now. For fields, the naming convention is to use lowercase names. And to place a grade into this collection of grades, I just need to come into my method and say grades, and that will be available to me inside of this method because grades is a member of the class. And once I hit the period character, the IntelliSense window pops up to show me all of the different things that I can do with a list. That includes things like clear the list, to empty it out, flush all the grades out. I could also sort the list in some specific order. But what I want to do is just to add something to the list. I want to add the grade that is being passed in to the AddGrade method. Now there's at least one more thing that we have to do to make this class usable, but we'll see that next. For right now, I just want you to know that this is how you create classes. I now have two classes in this project, Program and GradeBook. The project system in Visual Studio will make sure both of these files go to the C# compiler, which will compile them both into my application. And each of these classes, GradeBook and Program, they both have their own file to live in with a .cs extension. And in this GradeBook class, we have one method and we have one field. Throughout this course, we'll discover other types of members that we can add to a class. But for right now, let's work with this method in this field.

Classes and Objects

Let's return to Program.cs and the main method which is the entry point for the application. And now that I have a class, GradeBook, I can have define variables of type GradeBook. And the name of this variable could be GradeBook or Grades. Let's just call it book. And through that variable, I should be able to invoke methods like the AddGrade method that we gave a GradeBook, and I can pass in a parameter to that method. Let's pass in a 91. Now if I were to build the application at this point, I would get a compiler error, and Visual Studio is already indicating that there's going to be an error with the red squiggly line. And the error is the use of an unassigned local variable, book. Once I have a class definition, I can use that to create variables like book. But just by adding a variable of type book to this method, that doesn't give me an actual GradeBook. All it does is give me a variable that I can use to access a GradeBook. And here's an important concept in C# that we will talk about several times in this course. When I create a class definition, I can think of that class definition like a cookie-cutter. A cookie-cutter allows me to create one or more cookies with a specific shape just by applying the cutter to some dough. And its cookies that I really want to work with and eat, but cookie-cutter only exists to create cookies with a consistent and specific shape. A class definition is similar to this because I don't do any actual work with the class definition, but I can use the class to create objects with a specific and consistent shape and then work with those objects. The class is a cookie-cutter. But instead of stamping out cookies from dough, a class will stamp out objects from the memory of the computer. And it objects that I need to work with in my program. It is objects that are allocated into the memory of my computer and hold the data that I need. The way I create a real GradeBook object using that GradeBook class is to use another keyword in C#, the new keyword. And I'll say new GradeBook. Literally, I am asking for a new instance of this GradeBook class, and I'm going to store a reference to that object, this new GradeBook object, in the variable book. I'm also going to apply a parenthesis here, and it looks like I'm invoking a method. That's because behind the scenes, I actually am invoking a method. I'm using the name of the class, GradeBook, and then applying parentheses. Behind the scenes, that will invoke what's known as a constructor. And a constructor is responsible for creating a new instance of this GradeBook by allocating memory and initializing the state inside. We are going to talk more about instructors in just a bit. But now that I've created a new GradeBook and I've assigned that to book, that takes care of the uninitialized variable, that is, a variable that just wasn't assigned anything. The C# compiler was smart enough to know that, that variable was going to create a problem, it didn't point to an actual GradeBook. And now let me try to run this program with the debugger to see if we can add a grade. I'll do that just by pressing F5 to run with the debugger. And after Visual Studio builds the project, it will start the application running and we will get an exception inside of our AddGrade method. This exception is a NullReferenceException. Is an exception that you are sure to see many times over the course of a career in C# programming. And in this case, it means I'm using an uninitialized variable, and that uninitialized variable is the field, grades, that I have inside of GradeBook. Let me stop the debugger and show you that Visual Studio tried to indicate that this was going to be a problem. It did that with a warning or a green squiggly line. It's not an error because the C# compiler cannot tell with 100% accuracy that this was going to create a problem. It was able to do that inside of Program.cs with this very simple logic before I had new GradeBook. The C# compiler knew that book was uninitialized and I was certainly going to have a problem. In the case of the class, it wasn't so clear. But I did get a warning here that this grades field was never assigned to and will always have the default value, null, which means I will not have an object that is a list of floating point numbers. I will have a variable that points to nothing. There's nothing I can do with it. Just like with the GradeBook in Program.cs, I have to make sure that this field is initialized and actually points to an object, a list of float that will do real work. And once again, I can do that with a new keyword. So I could say this list of floats should be initialized and start off with a new object that is constructed for me, because now the C# compiler can see that this field is assigned to. And now I'm pretty sure that this program should work, and I'm so sure that I want to come back to Program.cs and actually add another grade here. Let me add the grade, 89.5. And I just want to show you another interesting error message. If I hover over this error, I can see that the argument I'm passing to AddGrade is getting an error, cannot convert from double to float. So when we defined AddGrade, we said that when someone invokes this method, they need to pass us a number that is typed as float, which is a single precision floating point number. But when I use this literal value here, 89.5, by default, that's going to be a double precision floating point number, a double. And the C# compiler, it's very picky about types. Now 91, this integer value, the C# compiler will allow me to pass that value into AddGrade, because it will implicitly convert that value into a float. Any integer value will convert to a float, but the C# compiler is not going to do that with the double precision floating point number. It's not going to try to place it or convert it into a single precision floating point number because you might lose some information. This is just like if I declared a variable of type double and I initialized it with a value 91.5, that's going to work just fine. But if I change this type to float, that will be an error. What I need to do is I need to tell the C# compiler that this value should be treated as a floating point number. And the way I can do that is by appending an F at the end of this number. And now that line of code would work, so let me also apply an F here to AddGrade. And now let's set a breakpoint here at the bottom of the program. I'll press F5 to run with the debugger, and I just want to inspect my variable book to see what's inside. I can see that, that grades field has two items inside of it and that the grades are 91 and 89.5. So now I know that the GradeBook is successfully storing my grades. And that's good, we have a working GradeBook. Now let's go back and talk about the construction of this GradeBook just a bit.

Constructors

When I use the new keyword and then the name of the class with parentheses, this is instantiating an instance of that class, it's creating an object. And instantiating a class will invoke a special method we call a constructor, because a constructor helps construct an object. Every class will have a default constructor that exists implicitly, unless I do something special. And this is why I can create an instance of GradeBook and use it even though I don't have a constructor explicitly defined in that class. If I do want to define my own constructor, it's very much like defining a method. I'll use the public keyword and then the name of the class followed by parentheses. Just like a method, I had those parentheses at the end of my curly braces to denote the start and the end of the method. There are many scenarios where you will want to write your own constructor for a class, because writing your own constructor gives you control over the initialization of an object. You can initialize fields and data for the object. You can set default values. You can create other objects that your object uses. And you can even have multiple constructors defined, but we'll look at that later in the course. For now, let's look at implementing a constructor for our GradeBook. Currently in my program, when I say new GradeBook, we will be using an implicit constructor that is defined for us, because we never wrote an explicit constructor for GradeBook. But now let's take control over the initialization of a GradeBook, and write a constructor. There's a very easy way to do this in Visual Studio. If I just typed ctor, those characters are recognized as one of the code snippets in Visual Studio. What a code snippet allows you to do is just type some short sequence of characters, like ctor, and this is the code snippet for a constructor. And if I press tab twice, Visual Studio will do a little bit of code generation and write the constructor for me. I already have the public keyword in place, and a constructor is a method definition where the method name is the same as the class. Like every method, it has some parentheses where I can take parameters, and then the opening and closing curly braces. There's some other snippets that we'll see throughout this course, but ctor, that's one I use every day. It's short for constructor, that's easy to remember. And now it's inside of this constructor where I can take explicit control over the initialization of my object. It turns out we're already doing some initialization during the construction of a GradeBook, because when we defined this field, this field being grades, I'm using what's known as a field initializer syntax here. I'm saying I want a field named grades, and I want to immediately initialize it to a new list for each GradeBook that is constructed. So each GradeBook maintains its own list of grades. Instead of using field initializer syntax, I could cut this line of code out of here and inside of the constructor, say grade equals a new list of float. For the most part, it doesn't matter if you use that field initializer syntax or if you initialize a field and constructor. There's no obvious differences in terms of performance. It really comes down to the syntax that you're most comfortable with, and also some special circumstances. For example, in a constructor, since it is a method, I can take some parameters here like maybe I want the maximum grade or the maximum number of items that I'm going to store in a grade, and then I need that parameter to pass along to other constructors. That's a case where I probably wouldn't use field initializer syntax. I would use explicit initialization inside of a constructor. But for right now, let's keep what is known as a default constructor. A default constructor is a constructor that doesn't take any parameters. So when someone initializes a GradeBook and creates an instance using the new keyword, they don't have to pass any parameters that arrive here to the constructor method. Just like I'm using the default constructor for a list of float, I'm using the new keyword and invoking that constructor, and I don't pass any parameters along. And the important concept to take away here is that GradeBook is a class, it's a blueprint for creating objects. It's a cookie-cutter. In order to get an object that is an instance of this GradeBook class, something that I can use and something that I can actually add grades to, I need to create an object. And I do that using the new keyword. I want a new GradeBook or a new list of float. And now that we know a little bit more about constructors, let's really drill into the details about the differences between objects and variables.

Classes and Variables

One topic I want to make clear before removal is the distinction between a class and a variable. A class is a blueprint for creating objects. I can use the new keyword with the GradeBook class, and that creates a GradeBook object for me in memory. And that GradeBook and hold a list of grades. I can also use a class to define the type of a variable, because in C#, every variable needs a type, and a class defines a particular type. We'll see other categories of types in this course. A class is just one way to create a type. But when I use a class to type a variable, it's because I want to remember some specific object when I'm inside of a method. I want to remember the GradeBook so that I can add grades to that specific object and eventually ask it to compute some statistical results. You can think of the variable as a storage location that points to a specific object. Let's make that concept a little more concrete using the debugger. Inside the application, I've created a new GradeBook and I'm holding on to that book through a variable named book. But what would happen after I add these two grades to that GradeBook if I reassign that variable and said book is now equal to new GradeBook? And to make things interesting, let's add a grade to that GradeBook, something different than we have. So just a 75. And now I'll press F10 to start the debugger. F10 will step through each line of code. I want to step until I get to the bottom of the program, and I want to investigate this book variable. Now the question is, does this book variable point to a GradeBook that holds two grades, the 91 and the 89.5? Or does it hold one grade, the 75? Or does it hold three grades? And the answer is, if I hover over book, I can see there's one grade inside, it is the 75. And that's because this line of code I added, book = new GradeBook, that's creating a brand-new instance of a GradeBook, a second instance. And this new GradeBook will start with an empty list of grades until I add that first grade, the 75. And that is now the object that this book variable refers to throughout the rest of the method. And the lesson is that when I declare a variable of type GradeBook, that variable isn't stuck referring to a single object throughout its lifetime. That's why it is a variable. I can take the variable and point it to any GradeBook object that I have available, and then I can invoke methods and do other interesting things with that variable. And in this program now, I've created two separate GradeBook instances. But by the time I reach this line of code, I only have access to the second instance. I don't have any variables that refer to that first GradeBook that I created. There's no way to get back to that, and it's become garbage. That's what we call objects that are no longer being used by the program, and the Common Language Runtime is smart enough to periodically scan through memory and figure out which objects are garbage. The CLR can then clean those objects up and free up memory so that we have more space for other objects. This is just like cleaning up a hard drive by removing files that you no longer need. You remove files and make space for new files that you're going to use. But what happens if I want access to two different GradeBooks? Well, that's when I would need two different variables. So let's call this variable book2. And since this is a new variable, I'm going to need to properly declare that variable and provide a type. So book2 is a variable of type GradeBook. And now let me right click on the bottom of this program and say run to cursor. That's another easy way to get the debugger just to run to a specific point in your code. And now I can investigate book2 and see that it has my one grade, the 75. But I still have access to the first GradeBook through the book variable, and that's still holding on to the two grades that I put inside of there. And now let's try one more experiment. Instead of staying book2 equals a new GradeBook, let's say book2 = book. And the right question to ask would be to figure out if this is making a copy of the original GradeBook. In other words, will I now have two objects of type GradeBook, one with two grades in it? And will book2, will that GradeBook have three grades in it or one grade in it? I'll show you the answer in the next clip.

Reference Types

When we define a class in C#, we are creating something that is called a reference type. We will explore another category of types later in the course, but reference types are important to understand in C# because when we have a variable that is typed as a class like GradeBook, which is a reference type, the variable gives us a place to remember the GradeBook. But the variable does not hold the GradeBook itself. The GradeBook is somewhere else in memory, and the variable holds a pointer to that object in memory. The variable literally contains a memory address. So imagine the table on the right-hand side of the screen representing a section of memory on your computer, and each memory location has an address like six, seven, eight, nine, 10. There are billions of these memory cells. Let's say when we create the GradeBook object, the runtime placed the start of the object at location eight in our computer. That means the book1 variable, you can think of it as holding the value eight, which indicates where the GradeBook lives inside of those billions of memory addresses in the computer. It's like when someone gives you their business card, you don't hold the other person, you hold a pointer or an address and something that can lead you to that person when you need to talk to them or you need them to do something for you. A variable for a reference type holds a pointer. And when I do something like invoke a method with .AddGrade, the runtime takes care of following that pointer for me and invoking the correct method on the proper object. One important implication of reference types is that I can have multiple variables all pointing to the same object. If I use a line of code like book2 = book1, then the runtime will copy the value of the book1 variable into book2, which means the runtime will copy the memory address, eight, into book2. And now I can use both book1 and book2 to interact with the exact same GradeBook object. Let's take a look at this scenario with the debugger. At the end of the last clip, I included this line of code in the project that says book2 = book. And the way to think about this is that the value that is inside of book is copied and placed into book2. But you must always remember with C#, that the value inside of book is not a GradeBook object. It's just a pointer to a GradeBook object. So what I'm doing is I'm copying that pointer into another variable, and both book and book2 should now be referencing the same GradeBook. I can verify that by right clicking and saying run to cursor here at the bottom of the main method. And if we look inside of book, we will see it has three grades, 91, 89.5, and then the 75 was added through the book2 variable, because book2 points to the exact same GradeBook. Now one thing that might have occurred to you as we've been using the debugger is: why can the debugger see the grades that are inside of a GradeBook, but I cannot see those same grades if I stop debugging and try to access those grades through one of these variables? For instance, if I say book2.grades, this isn't available in the IntelliSense list. The only thing I can get to is really AddGrade on that book2 variable; and the same goes for the book variable. So what is it that makes AddGrade available to me but not the grades field that is the list of float that is inside of a GradeBook? Let's talk about that topic next.

Access Modifiers

I'd like you to be familiar with all of the keywords in the program that we've been writing before we leave this module, and we've already talked about keywords like namespace and class. But one keyword we haven't talked about is the public keyword that appears in a few places. C# was designed as an object-oriented language, meaning it has a built-in syntax to make it easy to define and work with objects, like this GradeBook. The class we wrote defines a blueprint for creating objects of type GradeBook. And one fundamental pillar of object-oriented programming is encapsulation. We use objects that encapsulate the behavior in the data that we need the software to perform. Encapsulation means we are enclosing or hiding certain details of how the software works. Since some details will be hidden from me when I use an object, I don't need to worry about those details, and I can be a little more productive. Software has a tendency to become very complex, and some applications are so complex, it's impossible for one person to know all of the details inside of every class. So encapsulation plays an extremely important role in software because I can work with objects that other people have written without knowing the details of how those objects are implemented. Even a simple class like GradeBook, which has an AddGrade method, that encapsulates how the GradeBook is actually storing a grade. When I use a GradeBook object, I don't care if the grade is stored in memory or on disk or in a database in the cloud, the GradeBook actually stores the grades in a list. And as I pointed out in the last clip, I can access this AddGrade method from code inside of my program, but I cannot access the list of grades in code that is outside of this GradeBook class. That's because of the keyword public that appears in front of the AddGrade method. Public is what we call an access modifier. Access modifiers are keywords in C#, and public is one modifier. Another access modifier is private. As the names imply, public makes a class member publicly available so that someone can reach and invoke a public member like AddGrade from outside of this class. But if I don't explicitly specify the access modifier for a member of the class, the default is to make the member private. And that means the member is only usable from code inside of the same class. This is why inside of AddGrade, I can use the grades list, but no one outside of GradeBook can see this field. We can say that the storage for grades is encapsulated inside of the GradeBook. We'll see how this works in code in just a bit. And I want you to know that public and private are just two of the available access modifiers. We'll cover more modifiers later in the course. For now, let's take a closer look at public and private. These are arguably the two most important access modifiers. Inside of our application, let's see what would happen if I were to add the public keyword to my grades field. Now I will tell you, if you make a member public, you typically want to expose that member with an uppercase letter. I'm not going to do that for now because we're not going to leave the public modifier here, but an uppercase letter would be the convention. Now back in Program.cs, I would have the ability to look at the grades through either the book variable or the book2 variable. And this is usually not what you want to do. You typically want to encapsulate your field and encapsulate your data inside of an object. So I'm going to come back to the GradeBook and remove that public access modifier. And now if we take a look at Program.cs, I can see the red squiggly line because GradeBook.grades is inaccessible due to its protection level. These access modifiers you can think about using them to apply protection and encapsulate certain aspects of your objects. If you're defining a member of a class, like AddGrade, and you do not provide an access modifier, that class member will be a private member. So now, I cannot even access AddGrade outside of the GradeBook. So AddGrade is certainly something that I want to be public. I also want the constructor to be public. Otherwise, the code inside of Program.cs wouldn't be able to instantiate a GradeBook. The constructor would be hidden, and many people like to be very explicit when they define a field and use the private keyword so that when you're looking through the code, it's very obvious that grades is going to be a private member of this class. If I did want to hide AddGrade, I could use the private keyword here also. But this is how I want to design the class. I want the constructor and the AddGrade method to be public numbers. I want the grades, the list of float that stores my data, I want that to be private; and that gives me some encapsulation. So we're just about ready to add some more features to our GradeBook, but before we do let's take a look at one more keyword.

Statics

One more keyword I want to make you aware of in C# is the static keyword. The static keyword is a bit of an advanced topic, which we'll return to in a later module to see in more detail. But I want to give you a basic introduction now to explain some of the code that we've seen already and some of the code that we still need to write. Members of a class can be marked as static, meaning static is a keyword that you can apply to a method or field. The code on the screen, imagine it inside of the GradeBook class. It is defining two publicly available fields, one called minimum grade and one called maximum grade. And it's using that field initializer syntax to initialize these fields to zero and 100, respectively. These fields are static fields, and here's what's important about a static field. A static field or method is something you can access in code without creating an instance of a class. Generally speaking, to do any useful work with a class, you need to use the new keyword to call a constructor and create an instance of the class, but there are classes out there with static members that can do work without creating an instance. Instead, you reference the field or the method using the type name, and then the name of the field or the method. So GradeBook.MaximumGrade is an expression that returned 100. And I don't need an instance of GradeBook to use that. This is how Console.WriteLine works. Console is a class, but I don't need to create an instance of console to use the class. It has static methods that I can reach and invoke, like WriteLines. I just use the name of the class and then a dot. So Console.WriteLine. I will warn you now that you have to be a little bit careful about using statics. They can have some unfortunate and negative impacts on the design of your software. We'll talk about some of the ramifications of static later in the course, but right now I wanted to make you aware of what was happening with that static keyword and how we were invoking code like Console.WriteLine. And we'll use this knowledge in the next clip when we add some more features to the GradeBook.

Statistics

What I'd like to do next is figure out how to get statistics out of the GradeBook. Remember the requirements wanting to know for a given set of grades, what's the highest score, the lowest score and the average score? Sometimes, when I'm not sure what to do, I make stuff up and then I see if I can get it to work. For example, I'm thinking if I want a GradeBook to compute statistics, then that phrase, ComputeStatistics, it's a pretty good verb-oriented behavior that I can add to a GradeBook as a method. It's very clear when I look at a piece of code like this what the GradeBook will be doing. But what will the GradeBook do with those statistics? Will it store those statistics internally? Will it expose them somehow so I could see something like the lowest grade that is associated with the GradeBook? But if I can walk up to a GradeBook at any time and look at the lowest grade, then why doesn't the GradeBook just compute statistics for me all of the time after each grade is added? This is where you just have to think about how are people going to use your objects? How do people want to use your classes? And here's how I think I would want to solve this problem. I do want to call a method called ComputeStatistics. I do want that word to be explicit because the program has reached a point where all of the grades are entered and now, I want to generate those statistics so I can display them to the user. But I don't want those statistics to be part of the GradeBook, and I don't want something called lowest score to be part of the GradeBook. I'd rather have ComputeStatistics return statistics to me or have that method return some object to me that will hold the statistics that I need. That way, the GradeBook is just responsible for storing the grades and computing the statistics. And I have another object that is responsible for and encapsulates the statistical results themselves. Sometimes, we talk about encapsulation as hiding things and certainly, this method, ComputeStatistics will hide the algorithms that I need to compute the statistics, and that's nice. But encapsulation can also be the concept of surrounding something, putting information together into a single context and into one place, and that's what I want the statistics to be. In other words, perhaps what I really want here is to write a new class, GradeStatistics so that I can define a variable. Let's call it stats. And when I call ComputeStatistics, I can store a reference to the computed results inside of the stats variable. This gives me a separation between the active computing statistics and the result of those calculations. It does mean I'm going to have to create another class, GradeStatistics, but many times you can reduce the complexity of an application by adding more classes. The GradeBook will now hold the grades. This GradeStatistics class will hold statistical information. So Let's see if we can get this to run or at least compile. So I'll come into the grades project and add another class. So select class and this add new item dialog. This will be called GradeStatistics.CS. I don't actually have to put the .cs into this dialog box. Visual Studio will do that for me. Now I have this class. If I come back to Program.cs, you can see I don't have an error anymore. Visual Studio now knows what GradeStatistics is, but we still don't have a ComputeStatistics on our GradeBook. So let's add that. I will expect this to be a public method so I can invoke it from outside of GradeBook. And I expect this method to return an object of type GradeStatistics. That's another key that we haven't talked about yet, but public is an access modifier and then just before the method name, you always have to describe what a method returns. In this case, I'm going to have a method named ComputeStatistics, and this method will return an object of type GradeStatistics. If a method doesn't need to return anything, you can use the void keyword to say that this method doesn't return a value. So now we've learned another keyword in the C# language. And when you write a constructor, that's the only method that you ever write where you do not specify a return type. It's just an access modifier and then the name of the constructor, which is always the same as the name of the class. That makes constructors look a little bit different. So AddGrade doesn't return anything. Compute statistics will return a GradeStatistics object. And right now, Visual Studio will give me an error because ComputeStatistics does not return a value. It's an error to say you'll return GradeStatistics but then not have a return statement inside of the method. For right now, let's just return a new instance of GradeStatistics. We'll need to populate this and do some computations. But for right now, I'm just trying to get the program to build, and I should be able to, at this point, build the solution. We are not actually computing any statistics, but that's okay. Sometimes in software, you just have to feel your way through to the final solution, and I think, looking at this code, that we're on the right track to computing some statistics. In the next clip, we can take a closer look at this method and figure out how we actually are going to do these computations.

Computation

Inside of ComputeStatistics in the GradeBook, I need to be able to work with this object of type GradeStatistics. I need to do some calculations and ultimately, I will need to add some fields to that class so that I can store the calculation somewhere. So instead of returning an object immediately, let me create a variable of type GradeStatistics. We can call it stats, point it to that new instance of GradeStatistics. Then we'll need to write some code to compute the statistics and then ultimately, here at the bottom of the method, we will return those statistics. I know I need to find the highest grade, the lowest grade and the average grade, so let's start by computing the average grade. We all know that to compute an average, I need to sum all of the grades in the grades list and then divided by the total number of grades. So let me create a variable. Let's call it sum and initialize it to zero. This will represent the sum of all the grades in the GradeBook, and now I need to go to each grade that is in that GradeBook and add it to the sum. There's an easy way to do this in C#, and that is to use a foreach statement. We will look at the statement in a little more depth later in this course, but what I can do with a foreach is say foreach grade in the grade collection, please take that grade and put it into a variable for me. And I can actually declare this variable inside of the foreach statement. Let's declare the variable, its name will be grade. And I say foreach grade in this field grades, then I apply some curly braces and here's what will happen. Any code that I put inside of these curly braces will execute once for each grade that is in the grades collection. If I have the grades 93, 85 and 80, I'll execute the code inside of this foreach once with the value 93 inside of grade, and then with an 85 and then with an 80. So we are looping over this code once for each grade. And what I need to do with each grade is add that grade to the sum, so I can say sum = sum plus the current grade that I'm looking at. And there's actually a shortcut syntax for this in C#. I can say sum = sum + grade, or I can say sum += grade, and those two statements are equivalent. So sum = sum + grade or sum += grade. That will add the value of the grade into that sum variable, and then I can compute the average just by taking the sum and dividing it by the total number of grades that are in the list, which I can get easily because the list will tell me how many items it holds. But where do I store that value? That number, the AverageGrade, is part of the statistics that I want to publish. So it's probably something that I want to add to the GradeStatistics class. Let's come over there, and I'm going to give this class three fields. The AverageGrade, and I also need to store the HighestGrade and the LowestGrade. So these are three fields that will be present for every instance of GradeStatistics. And over in the GradeBook, I ultimately want to say stats.AverageGrade equals the average, except I don't have access to AverageGrade because AverageGrade, remember, if I don't specify an access modifier for a field or method, the default is for that class member to be private. So AverageGrade is only available inside of the class, GradeStatistics. I need to add public in front of all three of these fields. Now earlier, I said you typically want to encapsulate fields. But in this case, the entire purpose of GradeStatistics is to collect all those data together and expose it. I'm going to make all three of these public. There's an easy way to do that with Visual Studio. I'm going to hold down the alt key on the keyboard and then click the mouse to select three rows inside of the editor. And now when I type the word public, I'm typing that across all three lines of code. So just hold down the alt key and then click and hold the mouse to select multiple lines of code. So I now have three public fields inside of GradeStatistics, and I should be able to say stats.AverageGrade. I can see I have access to that now. It will equal sum divided by, and this is where I can walk up to that list of float, the grades field, and one of the members that it has in here is a member called Count, which will tell me exactly how many items are in that list. One thing I should be careful about is what happens if there are no grades that have been entered? What if I tried to divide by zero because grades.Count is zero? That would be a runtime error and something that would crash the program. This will be a line of code that I need to be careful about. We're going to talk about error handling in a later module of this course. For now, we're just going to assume that the user knows what they're doing and they'll always add at least one grade to the gradebook before they call ComputeStatistics. If the user doesn't enter a grade, the program will crash and say that it tried to divide something by zero. But now we have the average grade computer. What about the highest grade and the lowest grade? In order to compute that, I'm going to need to keep track of what is the highest grade that I've seen so far. So as I'm looking at each grade inside of a foreach loop, I need to compare that grade to some sort of record that I've kept about the current highest grade. And one way to do that would just be to keep a running record of what is the highest grade that I've seen so far. I can do that directly on the stats class and say let's initialize stats.HighestGrade to a very small value, like zero, so that as we're executing the code inside of here, we can always check to see if the current grade is greater than stats.HighestGrade. But many times, I want to examine a piece of code and really think a minute about the responsibilities about the line of code. Where does this code belong? Where should I initialize highest grade? And I'm thinking that the initialization of the highest grade and the lowest grade members will ideally be inside of the GradeStatistics class itself. I could do that by adding a constructor to this class. So once again, the code snippet, ctor, press tab twice, and I can now say inside of here that HighestGrade = 0. And notice I don't have to say stats or access highest grade through some variable. When you're inside of a class, you can always access a member of that class without going through some sort of variable. More on that later, but HighestGrade now starts as a very small value, and I need to initialize LowestGrade ideally to some really high value. Perhaps I could just initialize LowestGrade to 100. I know all of my grades are between zero and 100, but I do want to show you that on this float type, there are some static members. I can see that if I just type float., the IntelliSense window shows me some static members that are available on the float type. And one of the static members is max value. That's the largest possible number that you could fit into a variable of type float. So I'm going to make LowestGrade this really high value, and now I can come back to the GradeBook and as I inspect each grade, I can see if that grade is higher than the highest grade or lower than the lowest grade. I could do that with an if statement. I could say if the grade is greater than stats.HighestGrade, only then will I execute the following code. We've talked about if statements and branching execution earlier in the course. It's inside of here where I would say okay, the new highest grade for stats will be the grade that I'm currently looking at. This is one way to write the code. But let me show you another approach. I'm going to remove the if statement, and now I'm going to use another class of the .NET framework, the Math class. Math also has some static members, members that make it easy to compute a cosine or a sine, raise a number to a power and so forth. It also has these static members, max and min. These are methods that I can invoke. And what I do when I invoke Math.Max is I pass in two numbers, and Math.Max will return the highest or the maximum of those two numbers. So if I just pass in grade and stats.HighestGrade and assign the result of this operation to stats.HighestGrade, stats.HighestGrade will contain the highest number of these two. I can also do this to set the lowest grade. So the lowest grade would equal Math.Min, or the minimum value between grade and stats.LowestGrade. And now we have some code that will loop over all of the grades in our grade collection, keep track of the highest grade its seen, the lowest grade its seen; and also compute a sum so that it can compute an average. Once all those numbers are put together inside of the GradeStatistics object, we'll return it from ComputeStatistics, and now I should be able to come over into my program and use those statistics. Let's remove some of those code we added earlier, and I just want to write out the stats. First I will also add another grade. Let's add a grade of 75, then we will compute statistics. And I want to write out the average, the highest and the lowest. One way to do a Console.WriteLine really quickly is to use another code snippet, a cw snippet. All I need to do is type the characters cw, press tab twice, and I now have a line of code to invoke Console.WriteLine. Let's write out stats.AverageGrade and then Console.WriteLine, stats.HighestGrade and Console.WriteLine, stats.LowestGrade. I want to run this program without the debugger so Control + F5 will do that, or go to the Debug menu. And the results I get out would show me that the average grade is an 85.16. The highest grade is a 91, the lowest grade is a 75, this whole looks correct. I should change the output so that I put some additional text in front of these numbers to tell the user exactly what numbers they're seeing, but it does look like the gradebook is doing the right computations, and that's all thanks to a couple of classes that we've implemented: the GradeBook and GradeStatistics. Also, thanks to some static members on types in the .NET Framework, things like Float.MaxValue and Math.Min. And we now have a GradeBook with some minimal features but it's something that we can build on throughout the rest of this course.

Summary

In this module, we looked at quite a few features of the C# language. We learned how to create a class definition and give a class a constructor. A constructor is a special method used when we create an instance of the class using the new keyword. We also learned how we can construct multiple instances of the class, and we can have variables that point to these instances, these objects. Two variables can point to the same object, but also point to two different objects. We also learned about the public and private access modifiers. Those play an important role in encapsulation. And most importantly, we talked about taking some requirements for a GradeBook and using those requirements to create classes like GradeBook and GradeBook statistics. Over time, you'll figure out that these syntax of a programming language, while it can be challenging to learn, can always be mastered over time. What's a little more difficult is learning good programming practices. That requires you to always think about the responsibilities of each class and method and which class is going to encapsulate and be responsible for which feature. We're going to continue to build on our GradeBook and touch on those topics throughout the rest of the course.

Assemblies

Introduction

Hi this is Scott, and in this module we are going to focus on an important topic in C# development. The topic is Assemblies. Assemblies are the files the C# compiler creates for us, and inside of an assembly is the code we've written for our application. It is nearly impossible to write a C# programming using only a single assembly, so in this module we will learn how to build assemblies and reference other assemblies provided by the .NET Framework, as well as third-party assemblies in general. Along the way, we'll learn about another vital topic in software development. The topic is unit testing, and we will learn to write some tests to verify the behavior and functionality of our GradeBook class.

Assemblies

Earlier in this course I showed you how to use the C# compiler from the command line. Remember, the compiler's name is csc.exe, and I can pass one or more C# source code files to csc, and the compiler will produce an executable that I can run in a command window. That's how we wrote a hello world program in the first module. Now technically what the C# compiler produces is called an assembly. A .NET assembly is a file that contains our compiled code, code that can execute under the supervision of the Common Language Runtime. When we are writing a simple program like the Grade Book program that we've been working on, we don't need to think about assemblies. We can just compile and run our program. But on more sophisticated projects, we do need to learn a bit more about how to make and also use other assemblies. .NET assemblies are just files that you will store on disk with a .exe or .dll extension. Exe is short of executable. An exe file is a file that you can execute directly by double-clicking on the file in Windows or using the name of the program from the command line. The .dll extension is short for dynamic-link library. A dll is a file that you cannot execute directly, but another program can load a dll and use the code inside, which means one reason to put code inside of a dll is when you are writing code that you want to reuse in multiple applications. A good example of a reuse is the .NET Framework itself. Some of the classes we've been using, classes like Console and DateTime, they live inside an assembly that .NET provides. The assembly's name is MSCorLib.dll. It is a core library that contains core types. And many of this cor .NET assemblies like MSCorLib, they live inside a place known as the Global Assembly Cache on a Windows machine. You will find the Global Assembly Cache underneath your Windows folder where Windows installs inside a folder named Assembly. Inside of there you'll see additional folders beginning with the letters G-A-C, GAC for short. That's what we call the Global Assembly Cache, the GAC. The assemblies stored in the GAC are available to use from any .NET program that runs on a machine. That's why popular assemblies like MSCorLib, which has the Console and DateTime classes, as well as classes like String, these assemblies live in the GAC, so there's only one copy for the entire machine. And now that we know that our GradeBook program is a .NET assembly and that we use classes from other assemblies like MSCorLib, let's take a look in Visual Studio to explore this in more detail.

Browsing Assemblies

In this module we're going to continue to work with the GradeBook that we created in the last video module, and here inside of Visual Studio I want to point out some features that relate to creating and using other assemblies. First of all, we know now that when I do a build in Visual Studio all of my source code files, all of the .cs files will be collected together and built into an assembly, and we can find that assembly if we go to the location where we stored this project on disk and open up a command prompt. The compiler by default will build an assembly into the bin, for binaries, Debug directory. And inside of here if I list the files, I told you before there's a number of files in here that are related to just debugging information, but Grades.exe that is the assembly that the C# compiler produced, and that is an assembly that I can run because it's an executable, and it prints out statistical information about the grades that I've entered into the GradeBook. Now what rules does the C# compiler use to produce Grades.exe? Why does it pick that name? Why does it pick that extension, .exe? I'm going to right-click on the project node Grades and go to Properties, and under Properties I want to go to the Application tab. Now back in the last module when we created this project with File, New, Project, I told Visual Studio that I wanted to create a console application name Grades, so by default Visual Studio just configured a number of settings for me. For example, it configured the assembly name to have the same name as my project, so the assembly name is going to be Grades. But how does Visual Studio and the C# compiler then know whether to put on an .exe or a .dll extension? The extension is controlled by this Output type setting. It's in here where I can select if I want this to be an application, Console Application or Windows Application. A Windows Application would be an application that puts up windows on the screen. Since we're running this from the command line, we have Console Application selected. But I just want to show you what would happen if I selected Class Library instead. A Class Library produces a dll, and if I build this project and I come back out to the console window, let's do a directory again, and now I can see I have Grades.dll. Unfortunately, Grades.dll is not something that I can execute. Windows will give me an error and says it doesn't know what to do with this .dll file. I would get the same sort of error if I came into Visual Studio and tried to run this with the debugger or even without the debugger. Visual Studio will tell me a project with an output type of Class Library cannot be started directly. So a dynamic-length library that is a .dll file, or what we would more commonly call inside of Visual Studio a class library, that is an assembly, but it's not an assembly that can execute directly. It has to be loaded into some other program, which will use the classes inside of that dll to do work. So let me come back and change this back to being a Console Application, and then if I try to run with or without the debugger, Visual Studio will rebuild that project, and I have a working executable again. So Grades.exe is again an assembly that I have on disk that I can execute directly. And this is not the only assembly involved in the execution of this program. I'm also relying on other assemblies like MSCorLib to give me classes like Console and Math. We used the Math class in the last module to help compute some of our statistics like highest grade and lowest grade. That was inside of GradeBook.cs. Here you can see I'm using the Math type. Whenever you're using a class from the .NET Framework, or really any other third-party assembly, you can always place the cursor on the name of that class and press the F12 key. What Visual Studio will do is open up an editor window with what looks like the source code to that particular class. It's not really the full source code, Visual Studio is just trying to show you what's available on the Math class, and here I can see there are methods to call to get an absolute number and an arctangent and a logarithm. What I just want to point out here is at the very top of the file Visual Studio will tell me what assembly this type lives in. So the Math class that has static methods we can invoke directly, it lives in the assembly mscorlib. And if I want to see all of the assemblies that I might be using during execution of my program, I can come into the Solution Explorer window and open this References node. All of the little block icons in here are specifying the names of other assemblies that my project references. So there's a couple of things to note here. One, by default when you create a new project with Visual Studio, Visual Studio will give you a number of assembly references. These are common assemblies that many applications use, but our application doesn't actually use all of the assemblies that are listed here. And that's okay. It's not an error to reference an assembly that you don't use. In fact, there may not even be a performance overhead to that because .NET will only load an assembly when you actually start to use a class from that assembly inside of a program. But an assembly like System.Net.Http, that's an assembly that I could use to make calls over the network using the HTTP protocol. It's not something that my program actually does. I can right-click this assembly and Remove, and I'll still be able to build the program and everything works. If you remove an assembly that has a class that you are using, you will get a build error. Now one assembly that you might notice is not here is MSCorLib, and that's because MSCorLib is such an essential assembly that nearly every .NET application has to have that Visual Studio doesn't even list that assembly in the references. It's just implied that you'll be using MSCorLib. Now one additional feature that I want to point out is quite often you'll want to be able to see what inside of an assembly. You just want to be able to explore and see what classes might be available. That's the job of the Object Browser. So if I come to the View menu one, of the options here will be the Object Browser window. There's actually a couple of ways to open this. I can get to it from the View menu. I can also right-click an assembly over here and say View in Object Browser. That will open the Object Browser and put the focus right on that assembly inside the Object Browser. So the Object Browser allows you to look through all of the namespaces and all of the types that are inside of an assembly. So I can see here's my Grades assembly. What's inside of my Grades assembly? There is a Grades namespace, and inside of that namespace I have three classes, the GradeBook Class, and the GradeStatistics, and the Program classes. Those are all classes that we implemented. And what's inside of mscorlib? Inside of mscorlib you'll find dozens of namespaces, and inside of each namespace can be dozens, maybe even over a hundred different types. So here inside of mscorlib inside of the System namespace, this is where I will find classes like Console. And if I click on Console, the Object Browser goes one step further. Over here on the right hand side I can see all of the methods that are available on that Console class. So I can see that there is a ReadLine, which is a method we used in the first module of this course to read a user's name and find out how much sleep they had the previous evening. Also inside of here would be the Math class, so that's another way I could look and explore what can I do with this Math class that is in mscorlib. Now so far inside of our Grades program we haven't needed any classes from assemblies that we don't have referenced. That is when Visual Studio set up this project, it gave us access to all of the classes that we'd ever need for this GradeBook. Most of things that we use are in mscorlib or in System. But in the next clip let's try something a little bit different and see what we have to do if we need to use a class that is in an assembly that we don't currently have referenced.

Referencing Assemblies

When we are executing a program and we want to use a class or a type defined in another assembly, we must have that assembly loaded into memory with our program, and this can happen automatically with the .NET runtime. The easiest way for assembly loading to happen is to establish what we call an assembly reference. We can do this inside of Visual Studio and have an assembly appear in that references node that we were just looking at. When you right-click that node, you can select an option that says Add Reference, which will bring up a dialog box, which will allow you to select assemblies from the .NET Framework, as well as assemblies defined by other projects that you've created in solution or even just assemblies that are just lying around somewhere on the disk. But the important part is once I've established a reference inside of a project with Visual Studio, I can start using the types inside, and the .NET Framework will automatically load that assembly when I start using pieces from it during runtime. Let's take a look and see how that works. Inside of the GradeBook application, I want to try a little experiment with speech and see if I can get our program to speak a greeting and perhaps even the grades that are inside of the GradeBook. And to do this, I've read about a class on MSDN, the Microsoft Developer Network, that has a lot of the C# documentation. The class is called SpeechSynthesizer. And the problem right now is that class lives in an assembly that I don't reference. So not only would my program not run, it currently won't build because I have to have all of my assembly references in place for the classes that I'm using before the C# compiler will even build my project. And Visual Studio's trying to give me a clue about this. It tells me that the type or the namespace SpeechSynthesizer could not be found. Are you missing a using directive or an assembly reference? And in this case the problem is an assembly reference. So let me right-click on the References node and say Add Reference. Inside of this dialog box under Assemblies I can see a list of all of the framework assemblies that are installed on this machine, and there are a number of different ways to establish an assembly reference including just browsing to an assembly that is living on my file system somewhere. But the assembly I want for the SpeechSynthesizer, it is an assembly in the .NET Framework, so I'll come up to the text box here in the upper right of the screen and just search for speech, and I can see there is a System.Speech assembly. If I select that checkbox and say OK, I can now see that System.Speech is added to my list of assembly references. I can even right-click this assembly, view it in the Object Browser, and inside of the Object Browser I can see there's a System.Speech.Synthesis namespace, and it's actually inside of here where I would find the SpeechSynthesizer class that I want. And this class has a large number of methods that allow you to select different voices and do all sorts of tweaks to the sound and the speech that it's going to produce, but one of the easiest methods to use is just a method called Speak, which takes a string, and the synthesizer will speak the contents of that string. This is not a static method, so I do need to instantiate the SpeechSynthesizer. But now when I come back to my program, I still have an error that I might be missing a using directive or an assembly reference, but this time I have the assembly reference. I just need to add a using statement so that the compiler knows this is the System.Speech.Synthesis.SpeechSynthesizer class. And now I can create a variable called synth. Let's set that equal to a new instance of the SpeechSynthesizer class, and let's say synth.Speak ("Hello this is the grade book program.") And now when I run the application, that assembly will be loaded into my program; I'll be able to instantiate that class. And if I run this without the debugger, which is Ctrl+F5, that's the shortcut, hello this is the grade book program, then I have now successfully used the speech synthesizer. If I were to come back into Visual Studio and remove this reference, now I will start to have errors appear as the compiler, when I do a build, no longer knows where SpeechSynthesizer comes from. I get an error not only trying to use SpeechSynthesizer, but also just trying to use System.Speech.Synthesis. That's not a namespace that the compiler sees in any of the assemblies that I have referenced. So for most projects that you work on, the default assembly references will not be enough to get the job done. Quite often you're going to have some feature like talking to a database or executing business algorithms that someone else in your company has written and produced into an assembly. There are going to be some other features that you need to grab by referencing other assemblies. Another place where you will have to learn to manage assembly references is when you have multiple projects in the solution, and one project depends on another type of project. Let me clean up this program by removing code that will produce an error, and then we'll take a look at that topic as I introduce you to unit testing with C#.

Unit Testing

In software development, we often need to run our program to see if it is working correctly, but why run and inspect the results yourself when you can automate a test and have the computer verify the results? This is one advantage to writing unit tests. A unit test is where I write some C# code to test my other C# code in an automatic manner. Pluralsight has several courses that cover unit testing in more detail, so in this course I'm going to stick to some brute force information to get you started. Visual Studio provides a special project type dedicated to unit test code. As a software developer, I can use this project to write tests for my classes and verify that they're behaving correctly. The unit test project produces an assembly with my test code, and my test assembly typically has to reference another assembly with the code that is being tested. For example, if I want to make sure that the GradeBook computes the proper statistics, I'd create a new test project and write some test code where that test project will reference the assembly with the GradeBook. That way inside of a unit test I can use the GradeBook, I can instantiate that class, I can give it different grades and look at the output. Let's take a look and see how this works and start writing some tests, which throughout the rest of this course you'll learn not only how to verify the behavior of your code, but I'll show you how you can use unit tests to experiment and learn about the C# language. Inside of Visual Studio, before I can begin testing my GradeBook, I have to be set up with a unit testing project. There are many ways to run unit tests on the .NET Framework. I'm going to show you one way to do this with Visual Studio. I'm going to go to the Solution Explorer window and right-click on the Solution, the Grades Solution, because what I want to do is add another project to the Solution. One of the nice things about solutions in Visual Studio is they can contain multiple projects. Each project has its own set of source code for a particular piece of the application. I'm going to Add a New Project that will be a unit testing project. So instead of selecting Console Application, which we did for the GradeBook, I'm going to go to this Test node and select Unit Test Project, and let's call this project Grades.UnitTests, or perhaps let's just call it Grades.Test. So that will be the name of my project and also the name of the assembly that this project produces, Grades.Tests.dll. This assembly will just contain the compiled test code. There will be a different tool, a different program that will load this library and execute the tests inside and show me the results. And once I select OK, Visual Studio will create this project, add it to my solution, and any time I do a build I'll be building both the Grades assembly and the Grades.Tests assembly. Now before we even write any code, let me go to the Test menu in Visual Studio, and I'm going to say Run All the Tests. This will launch a test runner that is included in Visual Studio, and after building both of my projects, this test runner will go looking for tests that are in Grades.Tests. And I can see in this Test Explorer window that popped up on the left hand side there's a single method, TestMethod1, and the green checkmark tells me that test passed. Of course we're not really testing any functionality yet, and before we do I just want to run through some of the basics of a unit test. And one of the first things I'm going to do is actually drab this Test Explorer window and dock it down here beneath my Solution Explorer just because I always prefer my code to be on the left hand side of the screen. And now let me introduce you to some of the code that is inside of a file here. This file is called UnitTest1.cs, and inside of here is a class, UnitTest1, and a method, TestMethod1. We also have a new syntax feature of C#, a syntax feature that allows us to tell a test runner what methods are tests methods, that is methods that should be executed and checked to see if they passed or failed, and also a piece of information to identify a class that has test methods. So this syntax with the square brackets, these are known as attributes in C#. We're going to talk about attributes in more detail later in the course, but for now you can think of an attribute as a piece of data that is associated with a class or a method. You can actually associate an attribute with all sorts of different types and members in a C# application, but again that's later in the course. For right now, just know that if you're going to write a test that the test runner will run for you, you want to put that code inside of a method that has a TestMethod attribute with the square brackets around it, and that method goes into a class, a public class that has this TestClass attribute, and these attributes just sit directly on top of the language element that they are associated with. So TestClass is associated with a class; TestMethod is associated with a method. And what the test runner will do is just find all of your test classes, instantiate each one, execute the methods that are inside of each one, and then determine if a method passes or fails. How does the test runner know if a method passed or failed? Well, if there was no error that occurs inside of test method, the test runner will assume that the test has passed. But I can use a class that is in this namespace, Microsoft.VisualStudio.TestTools.UnitTesting. This class is called a Assert, and I can use this Assert class to make assertions about a particular piece of data or a particular facet of my program. And if those assertions don't hold true, they will raise an error and fail my test. In other words, once I dot into this Assert class, I can see all sorts of methods that are available like AreEqual, AreNotSame, AreSame, Fail, IsFalse, IsTrue, so I can try to make an assertion like are 3 and 4 equal? And if I run all of my tests again, the Test Explorer will tell me that no I have a failing test. I know that now because of all the red that shows up. And I can actually click on TestMethod1, and I can see some more detail here on the right side, AreEqual failed. Expected 3, Actual 4. That means I expected a value 3, I expected that to match the value 4, but we all know that 3 is not equal to 4, so this test failed. And if I double-click on this method, Visual Studio will actually place the cursor inside of that method. That way if a test fails and I don't have the file open, it's very easy to double-click a test and go directly to the source code. If I change Assert.AreEqual where I expect a 3 and the result to compare it to is a 3, now if I run all the tests, I am back to having a passing test. And so the ultimate goal with my unit test will be this: I want to make sure that the GradeBook is behaving correctly, so I want to write one or more test methods that will feed some data into the GradeBook and then make assertions about the GradeStatistics that the GradeBook returns. Did it find the correct high grade, the correct low grade? Did it compute the correct average? In order to do that, I'm going to create a new test class with new test methods, and for now I'm going to get rid of UnitTest1. This is really just sort of a sample file that Visual Studio gives you so that you can see the proper syntax for writing a unit test. But now that we know that syntax, we can create a source code file with a better name and better tests name inside, test names that are related to the GradeBook. Let's do that next.

Tests and Access Modifiers

I want to be able to write some tests that will test the functionality of my GradeBook, so I'm going to right-click on Grades.Tests on that project, and let's Add a Class because tests are nothing more than code that exists inside of test methods that are inside of a test class. So I will call this class GradeBookTests and press Enter. Visual Studio will add that class to the project. I want this to be a test class, and in order to use that attribute I'm going to need the namespace that we talked about earlier, Microsoft.VisualStudio.TestTools.UnitTesting. And the easiest way to add that is to click on the lightbulb and then select that option. I now have that using statement in place, and I can write a TestMethod, my first TestMethod. So there are various philosophies about how to name your test classes, how to name your test methods, how much code to put inside of a method and a class. I'm going to leave it up to all the other Pluralsight video's about unit testing to talk about the different perspectives and subtleties of how to organize test codes. For right now, I'm just going to brute force my way, and here's what I want to do. I want to be able to instantiate a GradeBook, I want to be able to give it some data, and I want to write assertions to make sure that the GradeBook computes the correct highest grade. And to do that I'm going to write a public method that does not return anything, so I'll use the void keyword. This method I'll just name it ComputesHighestGrade, and inside of the method I want to use the GradeBook. Right now there are a couple of obstacles that will prevent me from using the GradeBook. One obstacle is that Grades.Test, this assembly doesn't know about the other project, the Grades project. Even though they're in the same solution, I'm not going to be able to use GradeBook until I establish a reference from Grades.Test to the Grades. So just like I did with the speech synthesizer, let me right-click References and select Add Reference, but this time instead of selecting a framework assembly I'm going to go to this Projects node. The Projects node will list all of the other projects that are available in a solution, which makes it very easy to just come in and select a checkbox and say yes, I want to reference the assembly that is produced by this other project, the Grades assembly. That will give me a reference to that other project, but I still have another obstacle. If I look at the error that Visual Studio is giving me, it's telling me that GradeBook is inaccessible due to its protection level. So when you start working with multiple assemblies, you need to know a little bit more about protection levels than I've described so far. Let's look at the GradeBook. Protection levels are established by those access modifiers that we talked about in the last module, access modifiers like public and private. We know that if I mark a field or any class member as private that that field is not available to the code that is outside of this class. That's one way to achieve encapsulation in C#. And anything I make public will be available to anyone who writes code who has an instance of GradeBook around. So we've seen these keywords on class members, but what I didn't tell you is that there are also access modifiers available at the class level. And by default if you don't specify the access level for a class, by default it will be internal, and there's actually a C# keyword that I could place here to make that very explicit. This is an internal class, and internal class can only be used by code that is inside of the same project. So when a grade book is internal, I can use this in other places inside of the same project, so I can use the GradeBook from Program.cs, it's part of the same assembly, but I will not be able to use GradeBook from GradeBookTests. It's essentially hidden from this project. If I want to make GradeBook available, I need to explicitly mark this class as public. That means I can use this GradeBook inside of this assembly, the Grades assembly, as well from any assembly that references the Grades assembly. And yes, Grades is an .exe file, which we don't typically think of as a library that someone else would consume, but in .NET it's perfectly legal to reference a dll or an exe file. So the Test project is referencing the Grades project. It will now have access to this GradeBook class. It will be able to instantiate it except the C# compiler is going to check the access levels of all the classes that are involved with the GradeBook, and you can see right now I have an error. This error is an inconsistent accessibility error. It's telling me that GradeStatistics is less accessible then the method ComputeStatistics. It's a complicated error message, but it's actually easy to reason through this one. ComputeStatistics is available to anyone who has access to a GradeBook, but ComputeStatistics returns an object that is of type GradeStatistics. And if we look at GradeStatistics, the problem is that this class, by default, is an internal class, it's not visible outside of the project, so it doesn't make sense to give access to a method that anyone can use if it returns a type that no one outside can see. And there are a couple of different ways to solve this problem. One way to solve this problem is that I can use that internal keyword to mark just this method as internal, and that means anyone will be able to see this class even outside assemblies, but only code inside of the same assembly will be able to see and invoke this method. But I consider this part of the public API for our GradeBook, and certainly for my unit testing project I want to be able to instantiate a GradeBook and give it some data and then ask it to compute statistics, so I want this to be a public method. And because I'm returning something that is of GradeStatistics, the other way to solve this problem is to make this class public also. Now anyone who references the assembly can reach the GradeBook, they can reach GradeStatistics, they can invoke ComputeStatistics, everything should work for me. So inside of GradeBooksTests all I need now is my namespace, Grades, and I should be able to declare a variable of type GradeBook and instantiate a GradeBook, tell the book to add a grade, let's choose a grade of 10, and let's choose a grade of 90. And now let's get some statistics, so GradeStatistics the result. That is what happens when I call book.ComputeStatistics. And now I want to write an assertion. I want to assert that the following two things are equal: I expect a value of 90 when I ask for result.HighestGrade. And with that assert in place, let me go to Test and say run all the tests, Visual Studio will build the project, and then you'll notice a funny thing here. It doesn't seem to execute the test; it doesn't seem to find that test. Over here it says one test passed, but that was the last test run, and I don't see a test listing in this window. That's because the test runner, it's only going to execute the test code that is inside of a class marked with TestClass, that attribute, and it also has to be a public class. By default this class was internal. It was only visible to code that was inside of the same project. Now I've made it public. Let me try to run the test one more time, and I can see that that test is passing, and my GradeBook is producing the right result. What happens if someone comes into the GradeBook and they manipulate code to the point where the GradeBook no longer works properly? That's when my tests should fail. Slash, Slash, by the way, is a way to comment out a single line of code in C# so it doesn't execute. And now anytime I make changes to ComputeStatistics, I at least of have one test in place that will make sure the GradeBook is doing part of its job correctly. Let's write just a few more tests and see if we can make this a little more robust.

Tests and Floats

Let's write some tests to make sure that the GradeBook is computing the proper lowest grade and proper average grade. To do this, I'm going to make a copy of ComputesHighestGrade by selecting that method, pressing Ctrl+C, and then Ctrl+V to paste it in. Anytime you do a copy, paste operation in code, you should really take a step back and make sure that that's the proper approach to solving a problem. Copy and paste is duplicating code throughout the software, and that's generally something that we try to avoid. However, inside of a unit test we often allow for duplicate code because it makes the tests a little more explicit and clear, and that's what I'm going to do here. I'm going to duplicate a lot of code, but I am also going to change the name of this method because now we're going to check that we compute the lowest grade properly. I'll still add the same grades to the GradeBook, but now I want to have an assertion that 10 is result.LowestGrade. Now I can run all tests by going the test menu or by pressing Ctrl+R and then the A key that will run all tests. And I now have two passing tests. Let me paste a copy of ComputesHighestGrade, which I still have in my clipboard, only this time we will check to see if we compute the average grade. And this time I want to add some slightly different data to the GradeBook to make things a little more interesting. So instead of adding 10 and 90, let's add the same grades that we are adding inside of Program.cs. So I will take that code and copy and paste it inside of here. Then we can compute the statistics, and this time I want to check the result.AverageGrade. And if I enter those results into a calculator, the calculator will tell me that the average of those three numbers is an 85 followed by 1 and then 12 6's, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, and then a 7. Let me run all the tests again, Ctrl+R and then A, and I now have a failing test, which will teach us an interesting lesson. Let me click on that test, and I will see that this 85.16 number is not equal to an 85.16 number that is slightly different. And the important lesson is that it's very difficult to make assertions about floating point numbers and say that two numbers are going to be exactly equal because there can always be a little bit of imprecision inside of the computer because of the way that it represents floating point numbers. This could be a topic that we could spend a lot of time on, but let me just show you a couple different solutions. One is you might remember there are two ways to represent a floating point number in C#. There's the double type and there's the float type. Double is double-precision floating-point, and the float type is single-precision floating-point. You might remember from an earlier module when I tried to assign a number like this to a variable of type float the C# compiler wouldn't allow me to do that because by default a number like this will be treated as a double-precision floating-point number. And really what's happening here is I'm comparing a double-precision floating-point number to a single- precision floating-point number, and just like I did in a previous module I could append an f to this literal number, and now at least the C# compiler will treat that as a single-precision floating-point number and compare it to another single-precision floating-point number. But more commonly what you want to do is this: I don't particularly need the GradeBook to store this many digits after the decimal. Perhaps I really only care about two digits after the decimal. And any time you compare floating-point numbers or double-precision floating-point numbers inside of a unit test with things like AreEqual, there's typically an option that allows you to specify are these two numbers close enough? And you can see in this IntelliSense window when I Assert.AreEqual on types of double or of float, I would find that inside of here also. I can specify the expected value, what the actual computed value is, and then a delta, which allows those two numbers to vary by that delta amount. Let me specify a delta of 0.01 and run these tests. And I'm back to three passing tests, and I now know that the GradeBook is going to compute the proper average with the right amount of precision that I need for whatever application that I'm building with this GradeBook.

Summary

In this module we learned that Visual Studio and the C# compiler will compile our code into an assembly. By default the assembly name will have the same name as the project, and then we'll have a dll or exe extension depending on if you were building a class library or a program to execute directly. We also learned that we need more than one assembly for most applications, and we now know how to add references to other assemblies, both .NET assemblies, as well as other assemblies in our solution. In our solution we had to add a reference from the testing project to the grades project so that the test could see the GradeBook. Remember we also had to mark our Grade and our GradeStatistics classes as public so that the test project could use the GradeBook and the statistics that it computes. So in .NET all the types we create will live in an assembly, and the classes that we've built they are one specific type that we can create in .NET. In the next module we'll see additional types that we create and understand two fundamental categories of types in .NET.

Types

Introduction

Hi, this is Scott Allen, and this module is about the different Types in C#. Specifically I want to make sure that you know how every C# type falls into one of two categories. Every type is either a reference type or a value type, and it's very important to understand how these different types behave. We will look at reference types versus value types and also see how to create these different types of types, all of this and more in this fourth module of the course.

Reference Types

Reference types in C# are types created from class definitions, like the GradeBook that we created in the second module of this course. Any time I write a class I'm creating a new reference type, and we talked a little bit about the behavior of reference types in the second video module. I told you that when I have a variable typed as GradeBook, which is a reference type, the variable holds a reference or a pointer to an object. What's inside the variable is literally an address that tells the runtime where to find the object in memory, and I can have multiple variables all pointing to the exact same object instance, and I can have multiple objects, and I can have multiple variables pointing to all different objects. I can even take a variable and reassign the object that it's referencing, so it points to a new object, a different object then what it started with. Let's do some more experiments in Visual Studio to see how this works. Let's pick up in the grade solution that we were working on in the last two modules, and I want to do a few different experiments with the GradeBook, and before I start what I want to do is temporarily comment out this code so that this code doesn't execute, and there's a couple different ways to comment out these multiple lines. One is I could go to the Edit menu, I can select this command Comment Selection, that will comment out each line of code that I have selected with the curser, and there's a hot key combination that you can use to do that, Ctrl+K, Ctrl+C, I'll select this option, and now if I run the program nothing will happen because I don't really have any substantial code inside of my main method, it's just going to start, and exit, and the program's done, and that's thanks to this single line comment, which is a //. Any where you put a // you can add text, or you can comment out code, or you can have a note about something that is in your code. Another way to do this would be to make it a multiline comment, so first I'm going to uncomment the selection, which is Ctrl+ KU, you can also get to that command from the Edit Advanced menu. And now I'm going to use a /*, this is a multiline comment in C#, everything after /* is going to be commented out and not execute until I put in a */ to end that comment. So now that we have that code marked to not execute, let me go into the GradeBook itself, and I want to give the GradeBook the ability to have a name so I can identify the GradeBooks with some friendly identifier, and one easy way to do that is just to give this class a public field of type string, and let's call it Name. I'll use an uppercase N just because public class members typically start with an uppercase letter, whereas private class members like this grades field, it's going to start with a lowercase G. And now that I have a name let me go into Program.cs, and what I want to do is to create two GradeBooks. We'll call the first GradeBook g1, that's a not a great variable name, but this is just for experimental purposes, I typically want to have a more descriptive name. And then let's create a second variable g2, and give it a copy of what is in g1 because GradeBook is a class, and it's a reference type. The value that is inside of that g1 variable is going to be a pointer, so I'm copying that pointer from g1 into g2, and that means if I set the name of the GradeBook through the g1 variable, and let's call it Scott's grade book, and then I Console.write g2.Name. What I should see when I run this program by hitting Ctrl+F5 is Scott's GradeBook. That's because I have two variables that are pointing to the exact same GradeBook object. Now if I exit this command prompt, and I come into the program, and just before assigning name I say g1 equals another new grade book, now if I run the program when I write out g2.Name I don't have any output, that's because there are two GradeBook objects floating around in memory, and by the time we reach this g1.Name line of code, g1 is pointing to a different GradeBook than g2, g2 is still pointing to this original GradeBook, which we haven't given a name. Now one way to do these types of experiments is just to write some code inside of a console application, and run the program, and look at the output. That can be useful, and it's a good way to learn C#, and some of the topics like we're talking about now, reference types, how do they behave, but an even better way to do this I think is to use unit tests. Generally you're going to write unit tests to prove the correctness of your program, and make sure it's behaving correctly, but when I'm learning a topic like a new library, or a new API, or a new language, I find unit tests to be an invaluable way to create some experiments, and test some hypotheses, and see if my understanding of a particular behavior is correct. Since we already have a unit testing project that we created in the last module, Grades.Test, let's take advantage of that, and put some code inside of here that is really code that you can use to test yourself and experiment with the language. I'm going to Add a New Folder to this test project, and I will give it the name Types, and I can place all of the C# code related to my experiments with reference types inside of this folder, as well as other types that we're going to be creating, so inside of here let me add a Class, and let's just call this ReferenceTypeTests. I'll click Add, Visual Studio will add a class for me. Remember I want to make this a public class, and I want to give this class the attribute TestClass, which means I need to bring in the namespace, which is Microsoft.VisualStudio.TestTools.UnitTesting. Any this light bulb appears you can open up that light bulb by pressing Ctrl and period. That's really handy if you want to keep your hands-on the keyboard and not use the mouse to select the light bulb. I'm going to press Ctrl+ period, I'm going to select the first option here by just pressing Enter, which is to add that namespace to the top of the file for me, and now I can write a TestMethod, so first the attribute TestMethod, and this will be a public void returning method, let's call it VariablesHoldAReference, and now let me go back to Program.cs, select this code that I have here, and cut it out, come back into my Test, and paste it in, and really what I want to do in this Test is just some experiments, so my first experiment will be I want to instantiate a new GradeBook, I want to have two variables that I think are pointing to the same GradeBook, so I'll set the name through one variable, g1, and then I want to make an assertion, I want to Assert that the following two things are equal, I want to assert that g1's name, which I just set, is the same as g2's name because g2 is pointing to the same object, and when I look at g2.Name I will see that the name has been set by that previous line of code, and now back in the program I just want to clean things up a little bit, so let's get rid of our console.write line here, and let me get rid of the comment so that we put our program back in a correct state. I'm not interested in running the program right now, I'm more interested in running this test, so let me hit Ctrl+R and then A, and our Test Explorer pops up, and I can see that test passed, so my understanding of reference types seems to be working. Now what you can do inside of this Test Project is do different experiments with different variables, and write some assertions based on what you believe should happen, and then run the test to see if your beliefs are true. We'll continue writing some tests throughout the rest module also.

Value Types

As I mentioned earlier, every type in .NET falls into one of two categories. Every time is either a reference type or a value type. A variable that is typed as a value type does not hold a memory address or a pointer, it holds a value itself. For example, integers and floats are value types in .NET. If I have a variable called x1, and it's of type int, and I use it as a variable inside of a method, if I give that variable the value 100, the value 100 is literally stored inside the memory location of variable x1. There's no pointer here, the value is wholly inside that variable. I can have another variable of type int, let's call it x2, and I can assign it the value 4, and that value 4 is inside the variable, this is unlike the GradeBook variables we've created, g1 and g2, because those variables hold pointers to an object. Now why do we have these two different types? Well value types exist because they are generally faster to allocate in memory than reference types, that's one reason for the distinction. Creating an object is more expensive than creating a value type like an integer, and some programs need lots of value types to exist, millions of number for example in a mathematically-oriented program. So value types are very fast, and they are also usually small. It takes a lot less memory to store an integer than it does to store an entire GradeBook. Many primitive types in .NET are value types, primitive types being those low-level primitives that we can't program without, types like integers and floating point numbers, these are small values that store themselves directly in a variable. And one thing we'll revisit later is that value types are typically immutable, meaning you cannot change the value of a value type. That doesn't mean I cannot change the value inside of a variable, I can always walk up to an integer variable named x2 and give it a different value, I could change it from a 4 to a 3, but that value 4 and that value 3, those values I cannot change, the value 4 is always the value 4, the value 3 is always the value 3. And an obvious question at this point would be how do you know when you're working with a value type, and how do you know when you're working with a reference type, and how do you create your own value types, we've seen how to create reference types. Any time we create a class like the GradeBook we're creating a reference type, but what about value types, we'll answer these questions very soon, but first let's jump into Visual Studio, and do some more experiments. Inside of Visual Studio we're doing some experiments with types inside of unit tests, and so far we've written a test that says variables hold a reference, but now we know this is only true if the variable is typed as a reference type, which is the case for GradeBook, it's a reference type. So let's be a little more explicit with this test name, and say that GradeBookVariablesHoldAReference, and now write a test that looks very similar, but with a value type. I'm going to create a new test by using a code snippet, we've use d code snippets before, in this case the code snippet is testm, I just need to type those characters, and press Tab twice, Visual Studio will generate a test method for me, so press Tab twice, and now after inserting the snippet the name of this method is selected by the editor, I can immediately start typing to change the name, so let's name this method IntVariablesHoldavalue. And I want to write a test that is very similar to our other test, I want to create one variable, let's call it x1, and we'll give it the value 100, create a second variable x2, and copy the value that is inside of x1 into x2. We did the same thing with the GradeBook, but in the case of the GradeBook the value that is inside the variable is a pointer, so with GradeBooks we have two variables pointing to the same object. The question is with integers, if I make a change to x1, and give it the value 4, can I still assert that x1 and x2 are equal? Let's press Ctrl+ RA to run all the tests and find out, and the answer is no, that test failed because x1 now holds the value 4, x2 still holds the value 100 that I copied into it. So with the GradeBook variables I can point two variables to the same object, and then make a change to that object through either of those variables, and the change will be visible through the other variable, but that's not the case with value types. If I copy a different value into the x2 variable, that's completely independent from the storage location of x1, so I don't see that change reflected here, I would have to assert that these two are not equal, and then run the test, it should pass, which it does. Now if you want a good exercise to test yourself and really grasp this concept of reference types versus values types, try to figure out what would happen if I add this line of code inside of GradeBookVariablesHoldAReference. I'm going to say just before assigning g1.Name g1 equals a new GradeBook. What you should do is pause the video, and then think about if any other changes are required inside of this test method to make the test pass. That is do you have to change the assert from are equal to are not equal? And hopefully you have tried that, hopefully you came up with the correct answer. The correct answer is that I would have to change the assert because I have assigned a new value into g1, I have given it a pointer to a new GradeBook, a second GradeBook object. I'm changing the name of that second GradeBook, but g2 is still pointing to the first GradeBook that I created, therefore that first GradeBook doesn't have a name, and that assert.AreEqual g1.Name, g2.Name, that would fail. So these are the kinds of tests and experiments that you can do inside of Visual Studio with unit tests to really see if you are understanding some of the language concepts and features. And now that we've seen how these two behave, let's answer those questions of how do I know I'm working with a value type, and how do I create a value type.

struct and enum

One way to create a value type with C# is to create a structure using the struct keyword. A struct definition looks just like a class definition. A struct has a name, it has an opening and a closing curly brace, and everything inside of those braces will be a member of the structure. You can even apply an access modifier like public or internal, really the only syntactical difference is the keyword that's being used, struct or class, which leads to the next obvious question, when should I write a struct, and when should I write a class. The general rule of thumb is that you want to write a class by default. Structs are meant for special cases when you need to write an abstraction that represents a single value, like a DateTime that is inside of the .NET Framework that represents a single value even though you can break a DateTime down into small constituent pieces like the current hour, or the current day, or the current year, a DateTime does represent something that we can reason about as a single value, and it's a value that represents a point in time. Other value types in the .NET Framework, types like int, very obviously hold only a single value, but over the years I've built many custom value types using struct, and I've done this to represent things like complex numbers, or a point in two or three demential space, or a currency amount, which consists of a monetary value and a currency symbol, all of those abstractions represent single values conceptually, and the other characteristic that those value types have in common is that they are all small. Structs do best when they contain a small amount of data because as we'll see value types get copied around in memory frequently. A value type like int in C#, that not only requires 4 bytes of data to store, and most CPUs will copy that data just using a single CPU cycle, but more on that later. Another way to create a value type in C# is to use the enum keyword. An enum creates a type that will only hold specific numerical values. An enum, which is short for enumeration, and it's a good way to create named constants in your software. So here's a scenario, let's say we're building an application to pay employees, and we already have an employee class. One attribute we need to tract for each employee is how they are paid, are they paid on an hourly basis, are they salaried, are they an executive, one way to represent those categories would be to give each category a number, so an hourly employee has a payroll type of 4, and a salaried employee has a payroll type of 2. The problem is if we actually use those numbers in our source code they become what we call magic numbers. You look at the source code and you see a 2, what does that represent, is that employee hourly or salaried, I'm not sure, those are the types of things that you forget about 24 hours after you write the code. An enum can turn those magical numbers into symbols, so instead of using the value 4 for an hourly employee, I can use the code Payroll.Type.Hourly, so an enum isn't something that I have to instantiate to use, I can just use the name of the enum, and then one of the members of the enum that I have defined like .constractor, .salaried, and so forth. So in the if statement we're looking at using an employee object, every employee object has a field named Role that is defined of type PayrollType, so instead of saying .Role=2 or .Role=3, I can involve this enum, and the code is a little bit clear. Defining an enum is very simple, you use the enum keyword, give the enum a name, there's an opening and closing curly brace just like a class, but what is inside are your symbols. Here we have Contractor, Salaried, Executive, and Hourly. By default the first entry in an enum will carry the value 0 because behind the scenes this enum is represented as an integer value like 1, or 2, or 3. Inside the enum you can explicitly assign values as we've done here when we say Contractor = 1. What the C# complier will do is automatically assign the next numerical value if I don't explicitly provide one, so Salaried would be a 2, Executive would be a 3, Hourly would be a 4, and this code we'll just use the defaults there, but we could've explicitly overwritten that and said hourly = 128 if we wanted to. Let's take a look at this in code. In Visual Studio let me first show you an easy way to figure out if you're working with a reference type or a value type. When I declare a variable like g1, which is of type GradeBook, how do I know that's a reference type? One way to do this is to put the curse on the GradeBook symbol and use the F12 key, we've used this before, that will take me to the source code if Visual Studio has the source code available, and when I come to the source code for GradeBook I can see it's defined as a class, therefore this is a reference type, and g1 will hold a pointer. What about integers? I can use the same trick here. I can press F12, integer is part of the .NET Framework, but what Visual Studio will do is recreate the structure of that type from metadata, so this is the metadata view we used this earlier in the course. We can see that his is part of MSCorLib. So that's where the int type lives. Now you'll notice the actual name of this type is system.In32, it's not int, and that's just because in C# int is a C# keyword that will give you an in32, so I could define these variables using either the C# keyword int or the type system.in32, it's all going to come out the same in the end, those two are completely equivalent. I prefer to use the C# keyword int, but you can see here that int, AKA an in32, it is a struct, therefore an int is a value type. If I looked at the DateTime type in .NET I would see it as also a struct, and this metadata view, by the way, can be very useful if you're trying to figure out what something can do for you, I can look at this in32 type, and I can see that I can convert an int to a string, I can compare integer values, I can parse an integer out of a string, we will look at some of those features later in the course. For right now I'd also like to show you how to write or use an enum that's built-in to the .NET Framework, so let me create a new test method. This time what we're going to be experimenting with is StringComparisons. So first I'll declare a variable, let's call it name1, and it's going to point to value Scott with an uppercase S. So is string a value type or a reference type in .NET? If I press F12 I can see clearly that string is a reference type, don't let anyone ever tell you anything different, however string is a little bit magical, and we'll talk about that later in this module. So string is a reference type, name1 points to the string Scott. Let me also declare name 2, and I want this to point to scott, but without an uppercase S, and now what I'd like to do is do a StringComparison that will tell me these two strings are equivalent, so I need to do a StringComparison that ignores the case of the individual characters, so an uppercase S should be equivalent to a lowercase S. Let me declare another variable of type bool, so we can hold the value true or false. What is bool by the way? Bool, also a value type, it's a struct. I'm going to say that result = String.Equals, and I want to compare name1 and name 2, and there's an optional third parameter here where I can specify the type of StringComparison to do, and StringComparison is an enum, so if I say StringComparison., Visual Studio will show me the various StringComparisions I can do. I can compare strings and take into effect the CurrentCulture, my CurrentCulture is set up for English. I can also ask for InvariantCulture, so it doesn't matter whether my machine is set up for English, or Spanish, or French, or Norwegian, and I'm going to select this option, InvariantCultureIgnoreCase. And I want to assert it IsTrue this result because if I'm ignoring the case when I compare these two strings I should get a true out, and I now have six passing tests, so that has worked. Let's press F12 on StringComparison, and go to the metadata view, and here I can see how that enum is defined. I'm using StringComparison.InvarientCultureIgnoreCase, which holds the value 3, that would actually be the value that's passed around behind the scenes, but if I try to put a 3 in here you'll notice I do get the red underline, which indicates there is an error, so even though that underlying value is a 3, I cannot pass the integer value 3 into this method. The C# complier wants to see something that is one of these StringComparison values. That's another benefit of using strong typing and using enums instead of just magic numbers. And speaking of passing parameters to a method, another topic that we want to make that we're comfortable with is how these different types, these reference types or value types, how they behave when we pass them to another method.

Passing Parameters

Understanding the difference between how reference types and value types behave becomes extremely important when you write methods and pass parameters to a method. In C# the default is to pass parameters by value. This means when you call a method that takes a parameter, by default the value in the variable you pass will be copied into the variable that is a parameter to the method, and what you pass is always a copy unless you add some additional keywords, which we will talk about, but you hardly ever want to use these keywords, you want to use the default of pass by value, and that means for reference types you are passing a copy of a reference, a copy of the pointer that is inside the variable, and when I pass a value type to a method, a value type like an int, or a double float, or DateTime, I am passing a copy of the value, a copy of the value that is inside the variable. So if I have a method that takes a GradeBook parameter, and I pass the method of variable from my code, the method gets a copy of the pointer to a GradeBook, so both the calling code and the method that is being called, they will both have pointers to the exact same object, and this has profound implications for what happens inside the method, and what changes I can see when a method exits and returns control to the caller. Let's take a look in Visual Studio. Inside of our testing project we're really branching out beyond just reference type tests, so let's rename our test class to just TypeTests. The name of a test class really doesn't matter except in the output of the test explorer, and what I want to do now is write a couple test methods that I can use to explore the difference between value types and reference types when it comes to calling methods. The truth is there really is no difference, we're always passing something by value, but behavior may appear differently, let's just take a look. Let me create another test method with a code snippet, and let's name this method ReferenceTypesPassByValue, and what I want inside of here is code that is similar to some of the other code that we've written. I want to create a new GradeBook, and I want to have two variables that point to that GradeBook, so book2 will equal book1, what is this line of code doing, it's copying the reference that is inside of book1 into book2, so now I have two variables both pointing to the same object, and now let's call a method. I'm going to write a private method, GiveBookAName. Since this method is private and doesn't have a test method attribute, it's not going to be a method that the test runner tries to invoke to see if something is going to pass or fail, and simply a method that I can use inside of my tests, and this method I want it to take a GradeBook parameter, and I want it to set the name of the GradeBook, so book.Name = A GradeBook, and so back in my test method I want to invoke this method, GiveBookAName, I want to pass in book2, and then I want to write an assertion that will pass that will look at book1's name, and I'm going to paste in that string A GradeBook. We're going to see if book1.Name is equal to a GradeBook, Ctrl+ RA to run all the tests, and I now have seven passing tests, so I can see that test worked because when I invoke GiveBookAName, the value inside of book2 is copied into the parameter book, and that value is a pointer, so there is a period of time during the execution of these tests where I have three variables that are pointing to the same GradeBook object, book1, book2, and this parameter book, and any changes that I make to the GradeBook through any of those variables, they will be visible if I look at that object through any of the other variables. Now let's try a similar experiment, but with value types. So let me create a test method, we'll call it ValueTypesPassedByValue, and in this method I want to just try some things with a simple integer value, so let's say that x = 46, and again let me create a private method, let's say that we'll increment a number that is passed in, so this method expects an integer parameter, we can call it the number, and all I will do inside of here is say number = number + 1. Another way to write that in C# is to say number += 1, so that's a way of saying take this value, add 1 to it, and assign it back to the variable. And now the question is inside of this test method is I invoke IncrementNumber, and I pass in x, should I assert that x is a 46 or a 47, let's say that we expect a 46 to be the value inside of x, I will run all the tests, and that is also one of my passing tests. So what is happening here is that I take this 46 that is inside of x, it's being copied into number when I invoke method, but since this is a copy of that value I can make any changes that I want with this number variable. I can add 1, subtract 1, divide by 3, multiple by 6, it really doesn't matter what I do to this number inside of here. The changes I make are only visible inside of the code that is inside of IncrementNumber, it just has a copy of that integer value, there's nothing I can do with number that could make a change that would be visible from the code inside of ValueTypesPassByValue, and if that's a little bit confusing that's okay, it takes some time for this to sink in, and that's one of the reasons that I wanted you to set up a unit test project so you could explore some different scenarios with PassByValue, and write some tests, and see what tests pass, and what tests fail, and become more comfortable with this behavior, but one thing that might make this a little bit more clear is this, the only reason that I can call GiveBookAName, and see changes to A GradeBook object from outside of this method is because I am working with a reference type, and I have a reference to an object, and I'm making to the estate of some object, and that change is visible because there's three different variables that can all hold a pointer to that same object, but just like with the integer experiment above, there's no change that I can make to this book variable itself that would change the value that is inside of book1 or book2. So for example, down here if I said book = new GradeBook, this is not going to change the pointer or the reference inside of book2, it's only going to change the value that is stored inside of this book variable inside of GiveBookAName, so that particular variable will be pointing to a new GradeBook, but the variables that are back in the calling method, book1 and book2, they won't be changed at all, and if I run this test I will find I have a failing test because we will no longer be setting the name of this GradeBook that we created, we're creating a second GradeBook and setting its name. So the way to think about this really is that both tests demonstrate that C# uses PassByValue, and in both cases when I pass a parameter to a method, there's no way that the method that I call can make a change to the value that I hold inside of my variable, but if what I'm holding is a pointer to an object, that method can always make changes to an object that are visible to me as a caller. Now there is a way in C# to make changes to the variable, the value of that variable when I invoke a method, it's a rare scenario, but let's talk about that next.

ref and out

In C# there are two keywords that can change this default behavior of PassByValue, these two keywords are ref and out. I'm going to show you how they work, but I will say that in 15 years of developing with C# I rarely if ever use these keywords. There's a few special methods that Microsoft provides in the .NET Framework where I have to use these keywords, but I rarely if ever use these keywords in methods and classes that I build. I will cover these key words for those of you that want to get a complete picture of the C# language, but feel free to skip this clip and move to the next one if this something that doesn't interest you. So the two keywords are ref and out. Let's go back to the situation where I am saying book = new GradeBook inside of GiveBookAName, and I've already demonstrated that this test will fail now because when I change the value inside of book that does not change the value inside of book2, therefore book2 still pointing to the original GradeBook, and I'm only changing the name on a new GradeBook that is created here inside of GiveBookAName, but all that can change if I use on of these two keywords, ref or out. These keywords go in front of the type for the parameter, and this is the ref keyword, and the way to think about it now is what I'm receiving inside of the book parameter is a reference to the variable in the calling code, and there's a couple observations to make. For those of you with a computer science background, yes, you can think of book as a pointer to a pointer, but the syntax that I use inside of the method doesn't have to change. If I assign a new value to this parameter you can think of that value being written into the book2 variable, but the way I access the GradeBook doesn't change, I can still just say book., and I get to any instance member of that object. The next observation to make is that I have a complier error. When the C# complier see you're invoking a method that has a ref parameter, it also wants to see the ref keyword in front of the parameter when you invoke the method. That just makes it very explicit when you're calling another method, that you are passing this variable by reference, and it's quite possible that the method you are calling can change the underlying value inside of book2. So I'm about to run the tests, and I want you to take a guess whether the test will pass or fail. Let me give you a little bit of a hint, the assertion right now is still looking at book1.Name, so if I run the test, the test is still failing because when I say book = new GradeBook down here, yes, I'm writing a new value into book2, but that doesn't influence book1, I don't have a reference into that variable, I have a reference into book2, so book1 is still pointing to the original GradeBook, but book2 now, let's write an assertion against that, and just to make this clearer perhaps, let's get rid of the ref keyword for just a second. I'm going to run all the tests, that test should still fail because in this scenario when I say book = new GradeBook, we're back into the scenario that we previously looked at where I am writing a new value into this book parameter, but there's nothing I can do here that can change the value that is inside of book2, so book2 is still pointing to the original GradeBook. Let's change this back to ref, and I'm writing the assertion against book2.Name, let's run all the tests, and the tests now passes because when I say book = new GradeBook inside of GiveBookAName, I can think of this book as pointing to the new GradeBook, and because this is a by ref parameter I've also changed where book2 is pointing, so it's pointing to that new GradeBook also. The ref keyword, I can also use this against value types, so we've already seen if I call IncrementNumber on x, there's nothing I can do inside of IncrementNumber that will actually change the value that is inside of x, but that's all different if I use the ref keyword. If I use the ref keyword, and I also use it here where I am invoking the method, I can think of number as a reference to this variable location, the x, so any changes that I make to that value like incrementing the number, that change will be reflected inside of x, so Ctrl+ RA to run the tests, I expected a 46, but now the actual is 47, I did increment that number. Let's change the assert, run all the tests, and now we have a passing test. Let me show you the other keyword, the out keyword that also changes the behavior of PassByValue, and the out keyword is pretty much identical to ref. Let me just change both the method and the calling of that method to use the out keyword, and here we will see what the real difference is between ref and out, with out the C# complier assumes that you are creating an output here. Most methods produce an output by returning a value, but when you use the out keyword, the semantics are that you are producing an output through this parameter, and one of the things the C# complier wants to see is a definite assignment to that parameter. Right now the error is Use of unassigned out parameter number, that's because in order to add 1 to number, and say number += 1, I first have to read the number, and then add 1 to it, but the C# complier is saying since this is an output I cannot guarantee that the caller gave you an initialized value that you can use, and so for this scenario I have to use the ref keyword if I want to increment an existing number, and with ref the initialization rules are just on the other side of the fence. So with the ref keyword if I did not have a definite assignment to the variable x, now I would get an error in this method that I'm using an unassigned local variable. So with the ref keyword the C# complier will make sure that you initialize a variable before you call a method. If I have the out parameter here I wouldn't need this initialization statement, I could just say int x, and invoke a method that passes x as an out parameter. And that's the story with the ref and out keywords. Again these are keywords that I rarely use, there's usually a better way to design a method than by taking a ref or an out parameter, but hopefully I've given you enough information if you do encounter one of those keywords you'll know what to do, and you can always explore and experiment with unit tests like this to make sure that you understand the behavior correctly.

Immutability

One special behavior that I need to point out about value types is that value types are typically immutable, which means they cannot change, and certainly the value types that Microsoft provides as primitives for us to work with from the .NET Framewrk, those value types are immutable, and that means that once you create a value you cannot change the value. That doesn't mean that the value stored in a variable cannot change. We call them variables because the data inside can vary, but the actual value of the value type cannot change. So for example you cannot change the value of the integer value 4, that seems obvious, but it also means that once you've constructed a DateTime, which is a value type, that particular value cannot change. So with this in mind I want to cover two common errors that new C# developers frequently run into, one error with a DateTime value type, and one error with a string type. Once you construct a DataTime, and yes, you can use the new operator, you can construct a DateTime, and set that DateTime value to August 11, of the year 2002, which is what the code on the screen is doing. That's because the DateTime constructor takes the year, the month, and the day. Once I create this value I cannot change it, I can assign a different value into that date variable even though the DateTime exposes members like AddDays, which makes it look like I can add one day to an existing DateTime value, but this code has a problem because AddDays will never change the underlying DateTime value. Instead what AddDays will do is return a new DateTime instance, so I need to assign the return value of AddDays into a variable if I really want to capture the date. The string type in .NET also has these qualities. What's interesting about string is that string is a reference type, and as I said before, don't let anyone tell you that string is not a reference type. When working with strings your variables will be a reference that point to a sequence of characters, and that makes it easy to pass strings around to different methods because we pass a reference instead of copying the entire value of the string, and that's good because strings can contain millions of characters and can be quite large. A string is a reference type then, but it behaves like a value type in many ways because a string is immutable. One of the methods on a string is a Trim method. What Trim will do is remove the leading or trailing white space from a string, so the space characters before it and after the value Scott should be removed, but Trim does not modify the string that I am pointing to, instead Trim will create a new string with the characters removed, and return that new string. If all I do is just call Trim, and I don't assign the return value of that method call to a variable, I've lost all the work that the Trim method performed, and so the code on the screen is all wrong, don't use it, instead use the code that I'll show you now. Inside of Visual Studio let's experiment with the code that was just on the slide, so first I will write a new test method, this test method will test how to add days to a DateTime. So first I will need a DateTime variable, let's just call it date, and I could assign to that variable DateTime.Now, we've seen that earlier in the course, that will give me the current time as this program is executing, but instead let's use a specific date. I can do that using the new keyword, and there is a constructor for DateTime where I can pass in the year, let's say 2015, and then the month, let's just use January, and then the day of the month, let's just use the first day, and there's also constructors that would allow me to construct that day with a specific time during the day, but let's go with that value, and now say DateTime.AddDays1, and like I say it's very easy to think that now you have a DateTime that represents January 2, but if I write an assert, and I try to assert that the following two things are equal, the value 2, and date.Day, I will find this test will fail. Before I do that I'll just point out that there's all sorts of ways to look at various different pieces of the date, I could look at the specific hour, or the specific millisecond, but I just want to look at the day, and if I run the test the failing test will tell me that I expected a 2, but the actual value is 1, so Date.Day is still a 1, and that's because AddDays will construct a new DateTime, so let me assign that new DateTime into the date variable, and run the test again, and now we have a passing test. Next let's try something with a string, so another test method, and let's test how to uppercase a string. So if I have a string variable, let's call it name, and I point it to the string scott, with all lowercase characters, and yes, I do point it to that string value because if I press F12 on string I do see that it is a class defined inside of MSCorLib, and you'll notice the class name is actually uppercase S, it just so happens that once again C# provides a magic keyword, string with a lowercase letter, that will map to that stystem.stringtype, so the two are equivalent. C# is a case sensitive language, so if I didn't have that keyword in C# I would have to stay String uppercase S, but now that we know that let's try to do something with our name. Ultimately what I want to do is invoke a ToUpper method, which is one of many methods on the string type that looks like it would change the underlying string, so you can Trim a string, you can Trim from the start, or Trim just from the end. You can say ToUpper, ToLower, but if I write an assertion here, and try to assert that the value I expect is SCOTT, all uppercase, and compare that to the actual value, which is the value in name, if I run this test I will find that it fails because even though string is a reference type, it behaves very much like a value type, and I can see that I expected an all uppercase SCOTT, but I actually got an all lowercase scott, and that's because all of these methods like Trim, and ToUpper, and ToLower, they don't modify the string that I'm pointing to, instead they create a new string, and return that string from the method, so I really need to capture that by assigning a reference to that new string back into my name variable, and once I do that, and I run all the tests I should find that this passes, which it does, and hopefully this will save you some time in the future. Always remember when working with a value type that the value type might be immutable, but methods you see on that value type might be methods that return a new value or a new instance, and not change the underlying value, and that rule also applies to string, which behaves like a value type.

Arrays

One more reference type that I want to cover in more depth is the array. The array is a simple data structure to manage a collection of multiple objects or multiple values, and the array itself is always a reference type. Now you might remember that in our GradeBook we are managing a collection of multiple floating point values, those values represent the grades in the GradeBook, but we are using a list to store those grades in the GradeBook, not an array, primarily because arrays have a fixed size, that means when I create an array I have to specify the size of the array, which is how many items the array can hold, and that size, although you can change it, changing the size of an array can be a relatively expensive operation. In our program if we new exactly how many grades we might need to store, or at least the maximum number of grades, then it might make sense to use an array instead of a list, but since we don't know how many grades someone might want to store we use a list because a list will just grow automatically, and grab the space needed to keep storing new items every time we call Add on that list, but one thing both the list and the array have in common is that they are both 0 indexed, meaning the first item in a list or an array is at index 0, which is sometimes confusing because we tend to think of the first item being in position 1, but in C# and many other languages actually, the first item is position 0. You might remember we encountered this indexing already when we worked with the args array passed to our program in the first module, the args array contained the command line parameters, and the first parameter to the program was in position 0. Here in this code snippet we see the syntax for declaring an array. First is a const int variable. The const keyword is something that you can add to a variable if that variable if that variable is going to hold a constant value. Once I've declared and initialized the variable, the value of that variable cannot be changed. And in this code we will store the final score for four students, so students so the syntax for declaring an array is to use the type that the array is going to hold, followed by square brackets. What we're declaring here is an array called scores, it's going to hold integers. We will construct a new array that can hold exactly four integers, and this is all strongly typed, so if I try to assign a string or a floating point number into one of the positions of the aray, I would get a complier error. The array can only store integer values. And then we have a foreach loop very similar to the foreach loop that we have inside of the GradeBook when we're computing statistics. It's going to look at each integer value in that array of scores, and add that score to another variable where we're keeping track of the total score. Let's work with arrays a bit inside of our unit tests. Inside of our test project let me set you up with a test method that you can use to start experimenting with arrays. So let's just call this test UsingArrays, and I'll need to declare an array, so let's create an array of floating point numbers, that means I need to use the float keyword, and then I need to use the square brackets, that tells the C# complier this is an array. Let's just call the array grades, and now instead of initializing that variable immediately, let me just declare the variable because right now I have a variable that can point to any array of floating point numbers, it doesn't matter what the size is. In order to effectively use that variable, however, I will need to point it to a specific array, so let's assign a reference to a new floating point array. This time when I use the square brackets I need to specify the size of that array. Let's give the array the ability to store three numbers, then let's call a method that will add grades into that array, so a method that doesn't exist yet, it will be called AddGrades, and I'll pass in the grades, and then I'll want to write an assertion, I want to Assert, let's say, that the value 89.1 is in array index sub1. So we need to create this method AddGrades, and let me show you a trick. Visual Studio is smart enough that if you've written a method that doesn't exist yet, Visual Studio has the ability to create that method for you, it doesn't know how you want to implement that method, but if I go to the light bulb, and select generate the method, I now have a private void method called AddGrades that takes as a parameter a reference to an array of floating point numbers. The code that is inside this method right now, I want to remove that, and I want to be able to say that grades sub 1 = 89.1 , the floating point number. Again you do have to be very careful when comparing numbers for strict equality, that will always work for integers, but for floating point numbers you can sometimes run into trouble as we saw earlier, but you might be wondering since float is a value type, will the calling method using arrays actually see this value placed into the array, and the answer is yes because an array is a reference type, and even though I'm dealing with a value type, which is a floating point number, that number is stored inside the array, and both the grades variable inside of using arrays and the grades variable that is the parameter to add grades, those are both references to the exact same array. If I run the test with Ctrl+ RA I will see that is a passing test, and let's recreate a scenario that we were looking at earlier. What happens here on the first line of code, if I say grades = a new array of floating point number, let's say of size 5, what happens when I run the test now? Well the test will fail because now I've created a new array, I've placed this value inside of that new array, the grades variable that is inside of using arrays, that's still pointing to the original array of floating point number that we had, and this method AddGrades no longer uses that. This is not placing the value into the array that we need, so let me remove that line of code, rerun the test, leave you with all passing tests, and now I encourage you to experiment with the code that is inside of this unit test project, try some different scenarios passing around value types and reference types, and using arrays, and using strings, and with every little bit of code that you write you'll become more comfortable with the C# language.

Summary

What we've seen in this module is that every type falls into one of two categories, every type is a value type or a reference type. You can use the struct keyword to create a new value type, but the majority of what you'll be creating in day-to-day software is reference types, and you'll do that using a class keyword. We also looked a little bit at strings and arrays, these are both reference types, but remember the string behaves like a value type because strings are immutable, and you cannot change a string value that already exists, you can only build new strings. In the next module we're going to build on this knowledge, and we're going to start adding some additional features to our GradeBook. We'll add those features by adding new members to our GradeBook, class members like methods, but we're also going to look at some different types of members, members like properties and events.

Methods, Fields, Events, and Properties

Introduction

Hi, this is Scott, and in this module we're going to look at the members that you can attach to a type in the C# programming language. This includes some familiar members we've already used, members like methods and fields, we've attached these to classes and structs. We're going to go into more detail on those members, but also introduce new members that you can use, the new members being properties and events.

Methods

Let's start this module by reviewing a few things that we know about methods. Methods define behavior, they are our place where we can write code, and we can invoke a method to execute that code inside. Every method has an access modifier, the default is private where the method is only available to other code inside of the same class, but we can mark a method as internal to make it available to all the code inside of the same project, or use the public keyword to make the method available everywhere. Every method also has a return type, the method that we are looking at on the screen has a return type of void, meaning the method doesn't return a value to the caller, it executes the code inside, but it doesn't need a return statement to give anything back. Then we have the method name, and then 0 or more parameters, which are listed in the parentheses after the name. This method takes one parameter, a numerical value of type int, and the parameter is then a variable that is available throughout the rest of the method. The method we are looking at takes this integer and passes it through to another method, the static GetBytes method of the BitCoverter class. This BitConverter has a number of methods available to turn values into bytes, and once we have the byte for our integer we will write out each byte to the console using some special formatting symbols that know how to write out those values as hexadecimal numbers. More on the formatting symbols in just a bit. Now here's a couple of new concepts about methods, first there is a params keyword I want to show you in the demo. The params keyword allows you to take a variable number of arguments because sometimes you might not know how many parameters a method will need. Params is not typically something that you use on a regular basis, but it's extremely useful in some scenarios. Another concept I want to introduce you to in the demo is the concept of a method signature. You can think of a method signature as the unique identifier for a method. The signature consists of the name of the method, as well as the number and the types of the parameters that the method takes. The method signature allows the C# complier to distinguish between a method named WriteAsBytes that takes a single int and another method with the same name, WriteAsBytes, but it takes a parameter of type string. Those are two different methods, and I can have both methods in my class, and really I could have as many methods named WriteAsBytes as I need, as long as the parameter lists are unique because parameter lists are part of the signature. This is a feature in C# known as method overloading, and I do want to point out that the return type of a method is not part of the method signature, let's take a closer look. In this module we're going to continue to work with the GradeBook project that we created earlier in the course, and if I run this project with Ctrl+F5 you can see we are outputting statistics, but without any descriptive text for these numbers. So while you might be able to infer what is the average, the highest, and the lowest grades, it would be nice if we added some text to make that more descriptive. So each time I write out a result, I also want to write out a description of what that result is, and to do that I'm going to create a helper method, a method that I can invoke from the main method of the program class. Let's call this method WriteResult, I'll use the void keyword because this method doesn't need to return a value, and this has to be a static method because I want to invoke this method from another static method, and when you are inside a static member of a type you can only reach other static members of that same type, so this has to be a static method that's called WriteResult. Every time I invoke this method I want to pass in a description of the result that I'm going to write, and then the value of the result itself. And inside of here let's just do a Console.WriteLine, I'll do that with the code snippet in Visual Studio CW, press Tab and Tab, I want to write out the description, and let's just do some string concatenation to format the output, so description plus a colon and a space, and then the result. Let's try this out just with the average grade for right now, so I want to WriteResult, pass in the text Average, and then the AverageGrade itself. Let's give that a quick run with Ctrl+F5, and that looks like the type of output that I want, so I can change over some of the other values. Before I do, let me take this WriteResult method, and make a copy of that with Ctrl+C, and then paste it with Ctrl+V, and as soon as I do that Visual Studio will tell me that the C# complier sees an error, and the error is that I cannot have two methods on a type with the same signature, so now I have two methods, they're both called WriteResult, they both take two parameters of type string and float, so this is illegal, but what happens if I change this version of WriteResult to take an integer value instead. Now the C# complier sees two different methods, one that takes a string and an int, one that takes a string and a float. So when I call write result here, which method will the C# complier choose, well generally speaking the C# complier will choose the method that makes the most sense. So if I am invoking WriteResult, and I'm passing a string and a floating point number, if the C# complier sees a method signature that matches those parameter types exactly, that's the version of the overloaded method that it's going to invoke. Now there are some subtleties and some crazy edge cases where sometimes the C# complier can choose a method that you didn't expect, but for the most part the C# complier is going to do something sensible, so you can see just based on the highlighting in Visual Studio that the version of WriteResult I'll be invoking is the one that takes a string and a float. Now let's change over highest grade, and what I want to do is a WriteResult, and I'll pass in the text Highest, and this time I want to take this highest grade and do an explicit conversion to an integer, so this syntax in C# where you have a type name, or in this case the keyword int, which maps to a type, the int 32 type, this is a type corrosion, some people would call this a type cast, this is explicitly telling the C# complier I want to take this floating point number and convert that value into an integer, and when you do this at runtime the floating point number will just be truncated. If you actually wanted to do some rounding when you do the conversion there are some methods on the math class that will allow you to round a number, but this time when I call WriteResult you can see based on the highlighting the C# complier will choose the method that takes a string and an int. So for the most part, the C# complier is just going to match up the parameters and their types so that everything works together. And let's do this one more time, I want to WriteResult on the LowestGrade by passing in lowest, and now if I run the program I have some nice output. And this is the essence of method overloading in C#. Typically when you overload methods to take these different parameter types it's because you want to do something different with those parameter types, in this case all we're really doing is just doing a Console.WriteLine, but I want to show you the Console.WriteLine itself, it is an overloaded method. So if I remove and retype the opening parenthesis that will bring up the IntellSense window that shows me all of the different overloads of Console.WriteLine. Here's one that takes a bool, one that takes a character, I can navigate through this using the arrow keys, here's a character array, a decimal value, a double value. I want to show you a special version of WriteLine that is in here, the fifteenth overload of WriteLine, this one takes a string and then an object array. Notice that object array has the params keywords in front. That params keyword means that you can pass a variable number of arguments to this method, and a parameter to a method that is marked with this params keyword, it's always the last parameter to a method because what the C# complier will do as you start to pass parameters to this method, everything after the initial string, the C# complier is just going to take all those parameters, package them up into an array, and pass them to the method that you are invoking. So in other words, just as an experiment, if I used the params keyword here, then my result would not be a single floating point number, instead it would be an array of floating point number, and now what I can do is I can pass just a single value, but I could also continue to pass values in here, so I could pass the lowest grade, and then a 2, and a 3, and a 4, and of course inside of WriteResult what we'd have to do then is loop through this array, and display each result, this isn't really what we want to do, I just want to demonstrate how you would use the params keyword, we just want a single floating point result, so let me change this back, but what I do want to do is use this version of WriteLine that takes what's known as a formatting string, and then a variable number of parameters because you'll see this quite commonly in C# code. A formatting string looks like this, let's say I want to display the description, and then a colon, and a space, and then the result. One way to do that is with string concatenation, another way to do that is to use a formatting string like so, and you can think of the pieces inside of the curly braces as placeholders, so I have placeholders 0 and placeholder 1, and then the values that I pass here, that runtime will be placed into those placeholders. In other words if I pass description and result, then at runtime instead of displaying curly brace 0 curly brace, the runtime is going to go off looking for the first element in the array of parameters that I have passed, so these two parameters, they are packaged up into an array, the first element would be description, so description goes here. Now we have some literal text, which is the colon and the space, and then here's another placeholder where I want array index 1 placed into here, so this will take the result and place it here. If I run this program again, you'll see I still get the same output, which is quite often it's sometimes easier to work with a formatting string than it is string concatenation because you can think of that formatting string as a template, and it's sometimes a little bit easier to see the resulting string that you're hoping to build. Now as the slide eluded to, there's also some special formatting characters that you can add to these placeholders. I am not going to go into detail on all of the formatting options that are available, you can go to your favorite search engine, and search for C# string formatting, and you'll find lots of documentation because there are many formatting options. There are all sorts of pneumonics to format DateTime values in a specific way, or to take this floating point number and format it as a currency or in scientific notation. Here's an example, if I place a colon and a F2, what I'm asking the runtime to do is to take my number, the result, and format it as a floating point number with two digits after the decimal place, so you can see now instead of getting 85.166666, I get 85.17. So this has even rounded the number for me. I can also place a C in here to format that value as a currency. Notice that highest isn't formatted that way because when we displayed the highest grade we were displaying it using this version of WriteResult that takes an integer. And now one more quick tip, if you're using Visual Studio 2015 and the C# 6 complier, there's a new feature in C# version 6 called string interpolation, it works like this. Instead of using these formatting strings, which can sometimes create trouble because you forget that you really need two parameters in here, and you only pass one, a new feature of C# 6 string interpolation allows you to place a dollar sign in front of the opening quote for this formatting string, and instead of using numbers to index into an array, I can use the variable name directly, so this is a way of saying please write out the description, whatever that string value is, and then the literal text colon space, and now I want to write out the result, and I can still use a formatting string, so I want it to write out as a floating point number with two digits after the decimal, and if we run this we're still getting the output that we desire. So the key take-aways are that you can have overloaded methods in C#, that is methods that have the same name, but different signatures, or the signature consists not only of the method name, but also the number and the types of parameters, and the easy way to think about it is when you write code to invoke WriteResult, will there be a way to distinguish between these two different methods, and in this case since they both take two parameters, fortunately the last parameter has different types, so the C# complier will choose the int method or the float method depending on the type of the value that you have to pass in.

Fields and Properties

Another type of member we've already been using is the field. Fields define the variables inside of a class, so they define the state or the data that you want to hold as part of an object. Previously we added a name field to our GradeBook class, and we made that field public, so anyone could go to the GradeBook and change the name at anytime, but it is more common to make fields private and hide them, so that no code outside of the class has access to the field. Data is something you typically want to protect and validate, you don't want just anyone to be able to change the data inside of an object, so the code on the screen is using a private field of type string, the name of the field is _name, the underscore isn't required for private fields, that's just a naming convention that some developers use for private fields, you don't have to use that convention, but this field is inside of a class named Animal, and in the constructor for Animal we force someone to construct an animal by passing a name, and the constructor saves the name in the private field, so it's available for the rest of the object to use. Notice this field has a readonly keyword attached, that means the code inside of this class can only assign a name in the constructor, or when the field is defined with a field initializer, so I could say private readonly string _name = and some string value. If I try to set name to a new value in any other method other than the constructor, the C# complier will give me an error for this class. Now you might wonder how could I let code outside of my class get to the value of this field like the name, do I have to write a method to return that value for other people to be able to read the name, and the answer is no, that's where properties come in. A property is similar to a field because it controls state and data associated with an object, but unlike a field a property has a special syntax we can use to control what happens when someone reads the data or writes the data. These are known as the get and set accessors, and these accessors can contain code, you can almost think of them as methods, and we can do things like computations or validation. In this code snippet we have a field called _name again, it is private, so I can only access the field directly from code inside of the same class, but I also have a property called Name, and that's capitalized because the naming guidelines for C# tell us to capitalize property names, as well as method names, and I know this is a property because it has get and set accessors. Inside of a get accessor I have some code, it's inside of curly braces just like the code inside of a method. I can write as much code as I want inside of the get accessor, but ultimately I have to return a value, and that value has to be of type string because that's the type of property that I'm inside, and this code is just returning the same string that I already have in _name, but I could also return the name as uppercased, or lowercased, or just the first three letters, whatever I want as long as I return a string. Even more important here is the set accessor, inside of set, this is the code that will be invoked any time someone tries to write a value into this name property, and whatever value someone is trying to write, that will be passed to me implicitly through a variable called value. You can think of this almost as a parameter to this set accessor if you're thinking of it as a method. So I can take that value and store it directly under _name, but first do some validation to make sure that someone's not trying to set name to null or to an empty string. I want to make sure that the name actually has some characters, and that's a common use of set logic, to validate an incoming value to make sure it meets some standards before you accept that value into your object. There's another type of property in C# known as the auto-implemented property, this is a property that just has the keywords get and set inside, there's semicolons after get and set, there's no curly braces or code, and it's known as an auto-implemented property because behind the scenes the C# complier will automatically create a field to store the value for this property, and it will automatically read that field during a get operation, and write to that field during a set operation, but I never have to write that field or the code explicitly, the C# complier will do that for me behind the scenes. Let's take a closer look at this in code. Inside of our program let's open up the GradeBook, so I can remind you about the public field that we added to this class earlier in the course, it's a field called Name, and I have capitalized this member because it is a public member, and that's the typical convention in the C# program. Inside of Program.cs I can make an assignment to that Name field just by saying book.Name = Scott's GradeBook, so you can think of that as writing a reference into that field, a reference to a string that says Scott's GradeBook, and I can read that value just by using the .operator and saying book.Name. That will write out the name of the GradeBook when I run the program, and now I can see Scott's GradeBook. Now let's change this over to being a property, and I'll start by implementing an auto-implemented property, that's where I just have get and set with semicolons immediately after the keywords, there's no code involved, but I have now changed this member of the GradeBook class from being a field to a property, and you might be wondering what is the difference, well from a client's perspective, that is someone who's using the Gradebook, there is no difference, I still say book.Name = to assign to that property, that will call the setter, and I still use book.Name to retrieve the value of that property, and read the property, that will call the getter, and behind the scenes the C# complier has automatically created a backing field for this property, that's what we would call the field behind a property that actually stores the value. So this change hasn't made a huge difference in my code, but I will tell you there are some parts to the .NET Framework and other frameworks that treat properties and fields differently, specifically if you're doing serialization, that is if you're taking an object, and you're serializing it into XML, or JSON, or saving it to a database, there are some frameworks that only look at properties when they do the serialization, they do not look at fields by default. There are also data-binding features in the .NET Framework, these are features where you assign an object to some part of your user interface, and the data-binding features will automatically move data from an object onto the screen, and some of these data-binding features will only move properties, they won't look at fields, so again there can be a very subtle difference between fields and properties, and I would say in general in you're going to make the member publically available, we typically do that through a property instead of a field. In other words I will keep the grades field as a field and keep that private, I only want to be able to change grades inside of this class, but names, since I'm making that publically available, I will make that a property, and I will make it a capitalized member of the type, although it is perfectly legal to have private properties or internal properties, but I would say you just don't see them that often. But what if we wanted to protect against this situation, what if we wanted to protect against someone saying book.Name = an empty string, or book.Name = null, so null is a keyword in C#, and as we talked about before a field or a variable that holds a null value, it doesn't point to anything, it doesn't reference anything, there's no object, or there's no string there now to interact with, and currently if I run the program, if I try to Console.WriteLine that null value it just comes out as blank. I want to prevent that, and that means I won't be able to use an auto-implemented property, I'm going to need to add some logic to my setter to perform some validation, and as soon as I start to add code to the setter then I either need to get rid of my getter or also add code to the getter, and because I'm not using an auto-implemented property anymore I'm going to need to create a field explicitly that will be able to hold that string value, so I will create a private field called _name, and when someone wants to read the name property I'll just return name, but again I could do anything that I wanted to in here. I could return a new string that was uppercased, or lowercased, or a sub string, I'll just return _name, and when someone's trying to write to this property I want to check to see if the string is null or empty, so I can write String.IsNullOrEmpty, that is a static method on the string class. I will pass in value, which is the implicit variable that I have inside of a setter that will contain the value that someone is trying to write into my property, and then IsNullOrEmpty will return true is value IsNullOrEmpty. If I put an exclamation point here, that is a logical not operation that would turn that true into a false, so I'm saying if the string is not null or empty only then will I assign that value into the name, otherwise I will ignore this value. What I'd really like to do is create an error condition if someone gives me an empty name, that way I can let the caller know that they did something wrong, but we'll talk about error conditions like that more in the next module when we talk about exceptions. For right now I just want to show you when I run the program, this assignment Book.Name = null, we should be ignoring that value, we'll stick with Scott's GradeBook, and that's the real power of properties. You can write logic inside of a get accessor and a set accessor. The get accessor can perform computations, or just retrieve some field value, and return it, the set accessor can perform validations, and it can protect the internal state of your object, and make sure that someone isn't giving you a value that you don't want. So properties are really all about state, methods are still all about behavior, and next let's turn our attention to one more type of member that we can add to a type.

Events

Another type of member that you can have in a class is an event. To understand events we need to delve into some new concepts in C# and .NET, but before we do let me give you a high-level overview of why events are useful. Many times in software development we need to interact with or keep track of components that do interesting things at unpredictable times. For example, a button on a screen is a component that we want to keep track of, and we want to know when a user clicks on this button. We don't know exactly when the user will click on the button, but we do need to be notified because when the user does click we typically need to then execute some code. Sometimes we need to save data to a file or read data from a database, and this isn't just about components on the screen like a button. We might need to also keep track of a directory on the hard drive and be notified when a user places a new file on that directory, or when a timer expires because I want to execute some code every 60 seconds, and refresh some data, like refreshing stock quotes. All these are examples of when events are useful. Events allow an object, like an object that represents a button, events allow that object to announce to anyone who is listening that something interesting happened, like when the user clicks on that button. We call the announcement an event, and we say that the button publishes this event. The code that is interested in the click event is code that subscribes to the event. You can have multiple subscribers listening to a single click event, so that when the user clicks a button 0 or more independent pieces of code will execute. One piece of code might save data to a file, another piece might change the color of the screen, another piece might log information to a database, those are three independent pieces of code all executing off of the same event, and the beauty of events is that the button object itself, it doesn't need to keep track of who is subscribing, and the subscribers don't need to know about each other. This is all done through the magic of delegates in C#, so in order to understand events we really need to understand delegates first.

Delegates

Imagine that you want to declare a variable that references a method, so not a variable to hold an integer, or point to a string, or point to any class object, you want to declare a variable, and point the variable to a method, that means you'll have a variable that encapsulates executable code, and you can invoke the variable just like you would invoke a method by using parentheses and optionally passing some arguments along. In order for this to work you'll need to create a delegate type, so a delegate is a type just like we used the class keyword to create a type, or the struct keyword to create a type, there is a delegate keyword in the C# language, and that keyword will allow me to create a type that is dedicated to referencing methods, and that means the type definition for a delegate looks much different than a class definition. The type definition looks almost like a method definition, the type definition describes the methods that I want to call. In this code snippet I'm creating a delegate called Writer. I know this is a delegate because I can see the delegate keyword, and a variable of this type will point to a method that returns void and takes a string parameter. There's no curly braces here, I'm not defining a method with executable code, I just end the statement with a semicolon. I am defining a type that I can use to create variables, and point those variables to methods that have this same signature and same return type. Again the name of this type is Writer. Now imagine I have a class called Logger. I can instantiate a Logger, and once I have a Logger I can invoke a WriteMessage method, and have the Logger do something interesting like print a message to the screen. I can also write a bit of code that instantiates a Logger and then instantiates a delegate that references the WriteMessage method itself of the Logger object. That's what this bit of code here is doing. Notice I'm not invoking logger.WriteMessage, there are no parentheses after WriteMessage, this code is literally creating a new instance of a delegate and passing the WriteMessage method to this writer delegate. That delegate is saved into a variable named Writer, and I can now invoke logger.WriteMessage just by invoking this variable, all I need to do is apply parentheses to the variable and pass the string parameter that I want the Logger to use. Now depending on what programming background you have, this information might be a bit foreign. If you come from a C or C++ background you can think of a delegate as a way of creating a type save function pointer, and if you come from any functional language like JavaScript, the idea of having a variable that points to a function, that's not new, it's just going to be the C# syntax and all the type checking that you'll need to get used to because the C# complier is very picky about the methods that I can point to with a delegate. Like in this example, a writer delegate will only work with methods that return void and take a single string parameter. Notice the name of the method doesn't matter, I can have the delegate called Writer, and reference a method called WriteMessage, or any other name as long as that method returns void and takes a string. Let's take a look at this in Visual Studio. Back inside of the GradeBook let's look at a scenario where something else in the application needs to know when the name of the GradeBook is changing. Maybe that something else is a data-binding framework that needs to update the screen with the new GradeBook name whenever the name changes. We don't know, we just know that the only place in the entire application that knows exactly when the GradeBook name is changing is the code that is inside of the setter for the name property itself. If from inside of here I could announce somehow that the name is changing and invoke some other code, that would satisfy my requirements that I need to call something else in the application when the name changes, but I don't know what. That's the perfect scenario for delegates because delegates essentially allow you to have a variable that points to a method, and because it's a variable it can point to different methods it can be assigned to, and that's what I need inside of my setter, I need to know when the name is changing, perhaps I could have an additional if check here to say if _name is not equal to the incoming value, so I know for a fact that the name is changing, that I want to be able to invoke some arbitrary code. Let's say I have a delegate called NameChanged. I want to be able to invoke that, perhaps I pass in the existing name, and the new value that will be assigned to the name, and that will fulfill my responsibility to the outside world that I've made this announcement, my name is changing. In order to pull this off I'm going to need a delegate, so let me right-click on the GradeBook project, and I'm going to say Add, Class even though what I really want is a delegate, this is the easiest way to get a .cs file into the project. I will call this NameChangedDelegate, and press Add. Visual Studio will assume I want something with a .cs extension, and no, I don't want a class, and I don't want the curly braces. What I do want is a new type, a public type that I'll create with delegate, and now I need to describe the types of methods that this can invoke. I don't care about the return value from this method, all I know is it's going to need to take two string values, so let me create this delegate by saying the method will return void, and the method will take two string parameters, let's call them existingName and newName. Just remember that the names of these parameters are arbitrary. When the C# complier is checking to make sure this delegate points to the proper method it doesn't check the parameter names to make sure they match, it's only going to check the type, so a method that returns void and takes two strings, that's the type of method that I can point this delegate to. And so with this delegate back in the GradeBook I can now create a public field using that delegate type, so public NameChangedDelegate, let's call it NameChanged, and I now have a public member that other areas of the application can walk up, and assign to this delegate, and give it the code that needs to be invoked out there somewhere in the outside world. All I need to do in my GradeBook is just invoke that delegate at the appropriate time when the name has changed. Now just so we get some interesting output let's initialize _name to something inside of the constructor for the GradeBook just so there is always some value there. Let's just use the text Empty, and now what I want to do back in my program is take advantage of this new feature to execute arbitrary code when the name of the GradeBook changes. So back in Program.cs at some point after I create the book I want to be able to say book.NameChanged = a new instance of the NameChangedDelegate, and then pass in a method that can be invoked. I currently don't have a method that returns void and takes two strings, so before we finish that line of code, let's write something. This will have to be a static method so that I can reach it from the main method. It has to be a method that returns void. I can call it anything I want, let's call it OnNameChanged, and I just have to take two string parameters, the names don't matter, but I think existingName and newName, those are pretty good parameter names, so we will stick with those, and when this method is invoked I want to write out some information. Let's use some string interpolation, and say Grade book changing name from existingName to newName, and that should be everything that I need, so let me take this method name, and copy it, and I should be able to paste it here, and the delegate will be happy and say ah, you want me to call OnNameChanged whenever someone invokes this delegate. Let's try it, Ctrl+F5 to run, and I can see Grade book changing name from Empty to Scott's Grade Book, and this should happen anytime the name changes, so I should be able to say book.Name = Scott's Grade Book, and let's say book.Name = just Grade Book. We should see that method fire twice, and it does. It goes from Empty to Scott's Grade Book and then Scott's to just Grade Book, and this is the type of situation where you want to use a delegate, so going back to the UI example that we talked about earlier, let's say you're writing your class that's going to have a button associated with it because it's a part of a user interface, and your class, the code inside of it will know when the button is clicked, but how can your class announce to the rest of the world when that button is clicked because chances are it might not be just you that is interested in that button click, you might need to tell other pieces of the application when the button is clicked. How can you do that? Ultimately it's done with events that build on top of delegates, and right now we're just focusing on the delegate part. So let me show you a few other things that are interesting about delegates. Let's come back to Program.cs, and let me create a copy of OnNameChanged, and I'm going to paste it, and we know now that will create a complier error because we have two methods with the exact same signature, but I will change the second one to be OnNameChanged2, and let's do something simple inside of here like write out three asterix, and now back up at the top, what happens when if I say book.NameChanged = this new NameChangedDelegate OnNameChanged, and then right after that line of code I assign again with OnNameChanged2. Well if I run the program what we'll see is that we're only outputting asterixs now, and that's because I've effectively overwritten the information inside of that delegate that would allow me to call OnNameChanged, I've overwritten that delegate, I'm now calling OnNameChanged2 only. However the interesting thing about delegates in C# is they can reference multiple methods, we call them MutlicastDelegates because when I invoke a delegate that might call one method, but a delegate can also hold references to multiple methods, so invoking NameChanged might actually call 10 different methods because there might be 10 different pieces of the application that are interested in knowing when the name of a GradeBook has changed, and the way I can get that to work is instead of doing an assignment I can use the += operation. You might remember += from some of the mathematical operations we did with integers. I can say some variable += 3, an integer variable, and that will take whatever is in that integer variable, and add 3 to it, it's like saying x = x+3. This is the same concept, I'm saying take whatever is in NameChanged, and add this additional delegate, and then add this additional delegate, so that now when I run the program each time the name changes, not only do I invoke OnNameChanged, but I also invoke OnNameChanged2, and just so you know there's also a -= operation to remove a reference to a method, that would effectively be a way of saying I don't care about the NameChanged operation anymore, please remove me from your list of methods that you call, but this capability of being able to invoke multiple methods, this is ideal again for situations like building a UI component, or there might be multiple people, or multiple components that are interested in that button click event, and although I could do that with delegates, delegates don't quite offer enough encapsulation because someone can always walk up to book.NameChanged, and say I'm going to set this to null, which is empty it out, and that effectively overwrites all the previous delegates that were in there, and that's not something that I want to happen if I want different areas of the application to be able to independently subscribe to this event that the GradeBook name is changing. I want to prevent lines of code like this somehow, and that's exactly what I can do by using events instead of delegates, let's look at that next.

Events Revisited

Once you have a handle on how delegates work, it's very easy to understand events because events are based on and use delegates. The only thing I need to do to make NameChanged a proper event is to add the C# keyword here event, and now there is no code that I need to change inside of the GradeBook because events are based on delegates, and I can still invoke NameChanged. The C# complier will still check to make sure that I pass along two parameters, both of type string, and there's nothing that has to change inside of the GradeBook. The reason that events are preferred to just exposing delegates is because of the error that we see inside of Program.cs. The error is that NameChanged can only appear on the left-hand side of += or -=. That means from outside of the GradeBook the only thing that other pieces of code can do is add a subscriber to event, or remove a subscriber to this event, and it's no longer possible to do an assignment, and wipe out everything that was inside, wipe out all the other subscriptions. This is what we want for events because we want independent pieces of code being able to subscribe and unsubscribe, and not interfere with others, so this line of code is now an error, I will remove that line of code, and just show you that I can use += as many times as I want, I can even wire up the same method twice. Now you can see every time the name changes I get two sets of asterix, and I will also point out now that the C# complier is pretty intelligent when it comes to using Events and delegates, and the syntax that I'm currently using to wire up a subscriber for that event is a little bit verbose. I can actually remove new NameChangedDelegate, I can remove that from all three lines of code, and then once I get rid of the parentheses at the end I will still have legal C# code, because the C# complier is smart enough to look at NameChanged, and the method that I'm trying to add as a subscriber, and it can figure out that those two things are compatible, and it will just automatically create that delegate instance for me behind the scenes, I don't have to explicitly say new and then the name of some delegate. So this code is a little bit easier on the eyes, and just as a quick quiz, what happens if I add another line of code here with a -= operation, so now I'm subscribing OnNameChanged2 twice, and then unsubscribing once. The question is will -= wipe out all of the subscriptions for OnNameChanged2 or just one of them, and if I run the program we'll see I now have just one set of asterix, so OnNameChanged2 was subscribed twice, removed once, and then that result was one subscription, therefore that method fires once every time the name changes. Now I also want to point out that we're doing something unconventional with our event, and that is that we're passing two string parameters along with this event. There is a convention in .NET, it's not a convention that you have to follow, but it's a convention that 99.9% of all events in the .NET Framework follow. It's a convention where an event always passes along two parameters, the first parameter is going to be the sender of the event, in other words if the GradeBook is announcing that the name has changed, it's going to send itself as the first parameter, and then the second parameter always contains all of the arguments or all of the needed information about that event, which means I'm going to need to build a custom class to put together the existing name and the new name into a single object so I can pass that object along as the arguments. Let's make this change. I'm going to go to the GradeBook project, and add another class, I'll call this class NameChangedEventArgs, which is another convention when you are working with events. The parameter that passes along the argument for the event, the name of its type will always end with the words EventArgs. So now I have my class, let me add the public keyword here to make this a public class, and now I need properties for the existing name and the new name. The easiest way to add a property when you're using Visual Studio is to use a code snippet p, r, o, p, I'll just type that and press Tab twice, now I can fill in the type for my property, and then Tab twice over to the name, and fill out the name of my property, and Visual Studio will give me an auto-implemented property. Let me go to the next line of code and p, r, o, p again, this time I want the NewName property to be here. So this will give me my EventArgs class, and something that we'll talk about in the Object Oriented Programming module of this course is how a class can inherent from another class. If you haven't worked with inheritance before then you can just wait till we get to that module for me to explain this in more detail, but in .NET anything that's going to pass along arguments inside of an event, it should derive or inherent from an EventArgs base class that the .NET Framework provides. That's what this syntax is doing, it's specifying an inheritance relationship where NameChangedEventArgs derives from EventArgs. Again, more on inheritance later. Now I want to change over my delegate so it's not taking two string parameters any longer. Instead, it needs to take the sender of this event, and then the NameChangedEventArgs, an object of that type. Why am I specifying sender as an object? Object is another one of those topics that we'll talk a little more about when we talk about object-oriented programming, but this is another convention in .NET around events, and when I have a parameter typed in as an object, that means I can pass anything as a parameter here. I can pass an integer value, or a string, or a GradeBook instance, and if the GradeBook is the sender of this event, GradeBook is what I want to pass here, but I will type it as object because that's a common convention. Now that I've changed the delegate around I will have some complier errors both in Program.cs and in GradeBook.cs. In GradeBook.cs I need to pass EventArgs and the sender here instead of two strings. So first let's create an instance of NameChangedEventArgs, I will just call it args, and initialize a new instance, and say that the ExistingName equals the value that I currently have in _name, and the NewName that will equal the incoming value, and now when I invoke NameChanged, I should really pass along myself and then these arguments. How do I pass along myself? Well inside of every non-static method in a C# class or struct, there is an implicit variable called this, and this will reference the object that I'm inside of, so this will reference the GradeBook object that we're currently operating on. I just need to pass along this and args, and just to show you if I type this., here you can see all of the members of the GradeBook, so there's _Name, there's the property name, there's the private field grades, I can see private fields through this because I'm using code that is inside of the same class, so this is a variable that you can use anywhere in your C# code inside of an instance member if you need to refer to yourself, or pass yourself along as another parameter, and now I will need to change Program.cs because delegates are very type safe, and now the C# complier sees that I'm using these methods that no longer take the parameters that the delegate is describing, so I wrote these methods as taking two strings, and now this delegate is trying to pass an object and a NameChangedEventArgs, so I'm going to need to change these around. Let's actually get rid of OnNameChanged2 all together, that makes this a little less work, and up here OnNameChanged, I will change this around so that it can take a sender parameter, and then an instance of NameChangedEventArgs, and down here I will just need to change these to use args.ExistingName, and args.NewName, then let's remove the subscription to OnNameChanged2, that method no longer exists, run the GradeBook, I can still see it's behaving correctly, and this is the magic of events in .NET. Not all programming environments use events, but they are quite common if you're doing some sort of desktop program, that is a C# application that runs under Windows or runs on a mobile phone. It's quite common that your user interface elements will have events to let your code know when something was clicked on or if something was hovered over, and now you'll know that you can subscribe to those events using += and a method that accepts the parameters that event will raise.

Summary

In this module we looked at the different members that you can add to a class. We looked at fields and properties, which can hold an exposed state. We also looked at methods again, this time seeing how you can overload methods by writing multiple methods with the same name, but different signatures. Remember the signature is defined not only by the name of the method, but also the types and the number of parameters to that method. And finally we looked at events, which allow subscribers to listen for interesting things that might happen in an object. We saw how events are based on delegates, which are useful in other places in .NET programming too. If you want more information on events and delegates I do spend some time on them in both my C# Generics course and my Linq Fundamentals course. The whole goal of seeing fields, properties, methods, constructors, and events all together is to know what tools are available when you want to build an abstraction in C#. In this case we've built a GradeBook that encapsulates the behavior of the GradeBook. It can computer statistics and raise events when important state changes happen. We'll continue seeing how to build abstractions when we talk about object-oriented programming, but first we will in the next module look at flow control in C#, which is how to branch, and loop, and both create, and catch runtime errors.

Control Flow

Introduction

Hi, this is Scott Allen, and in this module we're going to look at Control Flow in a C# application. Specifically we're going to look at the keywords and constructs available in the language to perform branching, looping, and to jump to different points in an execution path. And finally, we'll look at error handling, that is how to throw errors, and how to catch errors, and potentially resolve those errors.

Branching

Conditional branching is something that we're already using in this course, but we really haven't stopped to dig into the details of the if statement, which is one way to branch execution. And by branching, I mean we have some code where we want to go in one of two directions, it's like getting into the branches of a tree where one branch sprouts out to the left, and one branch to the right, which direction do we go? That's what an if statement can do. The if statement selects a statement for execution based on the value of some Boolean expression. So, in the first if statement on the screen, if age is less than or equal to a 2, that's a Boolean expression that we'll return true or false. If the expression returns true, the if statement will execute the statement that immediately follows the if. If the expression is false, we'll skip that statement. Notice that I don't need to use curly braces to surround the call to ServeMilk, but it is a considered a good coding style to use curly braces, because curly braces make the code easier to maintain and a little more readable. The curly braces are required if I want to execute multiple statements when the expression returns true. I need to use the curly braces to create a block of code, and that block can enclose multiple method invocations, multiple statements, inside of the if. Without the curly braces, I will only execute the statement that immediately follows the if. Now if the first expression inside of an if statement returns false, let's say that age is a 10, we will not invoke ServeMilk, and instead we'll jump to the next if statement, because this code snippet includes else statements. It's like saying I need to check to see if the age is less than or equal to 2, if it's not, then I need to go and check to see if the age is less than 21. And if both of the tasks were to return false, we will fall into the final else statement and invoke a method ServeDrink. You don't need to include an else statement after every if that you write, but you can have as many else ifs as you want after an if test. Notice that the curly braces are not required around ServeDrink either because it's just a single statement, but again I believe it makes the code a little more readable. And speaking of readability, it's also possible to nest if statements. So any code that I would place where the comment is in the middle of the second code snippet, that code will only execute if the age variable is less than or equal to 2 and the name variable is equal to Scott. You have to be careful nesting too many statements together like this, because the code can become hard to read when you have if statements inside of if statements inside of if statements. Closely related to the if statement is the conditional operator. It's also sometimes referred to as the ternary operator because it comes in three pieces. The first piece is an expression that needs to return true or false, so age greater than 20. And then the conditional operator will return one of two values based on the evaluation of that expression. If the expression returns true, we'll return the value that is on the left-hand side of the colon. And if the expression returns false, we'll return the value on the right-hand side of the colon. So, for example, if the age variable contained the value 19, the expression will return false, and the string pass would be assigned the value, nopass. This conditional operator is sometimes useful when you just need a really quick conditional check to assign one of two different values. You can write the exact same logic with an if statement, but with a conditional statement there's fewer characters to type. You do have to be careful with the conditional operator because again, sometimes it can make the code difficult to read. Let's take a look at branching in our Grade Book. Let's take a look at branching using the Grades project that we've been working on throughout the course. The first thing I'm going to do, just to simplify some of the output is remove some of the code that we used to experiment with events. So I'm going to remove everything related to the Grade Book name, and changing the name, and that includes writing out the name, and also this event handler that we had to print out some output when the Grade Book name changed. Again just trying to simplify the program and I'm trying to make all the changes to the code here in the video so you can follow along. I can also get rid of one of these WriteResults if I remove that cast to an int that we placed here in the previous module, and we did that just see an example of method overloading, but I'll give you another example of method overloading here in just a bit. Here's what I'm thinking we could do, I want the GradeStatistics class to compute a letter grade. What is a letter grade? Well here in the States when I was growing up, my school teachers would grade all of my assignments, quizzes, and tests on a scale of 0 to 100, where 100 was a perfect score, and then periodically they would take all my scores and compute an average, and from that average, compute a letter grade. It was the letter grade that was sent home to my parents to tell them how I was doing in school. And when I was growing up the letter grades were A, B, C, D, and F. An A meant that you were doing wonderfully in a class, it was the best letter grade you could get. And then there was a B, and then there was a C, a C was considered average, then there was a D, and then there was an F. An F meant that you were failing a class. And I think I can get the Grade Book statistics to compute this logic just using some simple if else statements. So let's add another property to GradeStatistics, this is something the statistics can do all on their own, given an average grade. So let's create a property called LetterGrade. For this property, I'm only going to use a get accessor, that effectively makes this a read-only property, no one will be able to assign to it, which is just what I want, I want the letter grade to be computed from the average grade, there's reason to set the letter grade. And the letter grades work like this, if your average grade was greater than or equal to a 90, then that was a letter grade of A. And you might want to use something like math.round, so that a student with a score of 89.9 would also have an A, but I'll leave that as an exercise for you to try out. But now if the average grade is less than 90, I need to handle that situation too, so let me write an else if. Else if the AverageGrade is greater than or equal to 80, that would be a letter grade of a B. Now, generally speaking, I try to maintain a coding style where I only have a single return statement inside of a method or a property. That's not always possible, but it does make the code sometimes easier to read. I'm going to reach that goal, I'm going to try to do that by declaring a local variable result, and in this case not even initialize that because I expect to initialize it in the logic that is inside of this property, and instead of immediately returning, let me just say result = A, and result = B, and at the bottom whatever we have computed for result, that is what we will return. Currently we have an error because the C# compiler is smart enough to realize that you might be returning an unassigned local variable. If the average grade right now is lower than an 80, then we never make an assignment to result, and the C# compiler won't let us get away with that. So let's continue writing out some of our logic. If the letter grade is less than an 80, we won't branch in to assign a result of A, and we won't branch in to assign a result of B, so now we will have to check if the average grade is greater than a 70, and if so the result is a C. And notice one thing that I don't have to do here is I don't have to check that the average grade is greater than 70 and the average grade is less than 80. Technically that is the rule to get a letter grade of C, your average grade has to be greater than or equal to 70, or less than 80, but the way the if else statements work, I know that this test I don't really need this, because if the average grade was greater than 80 we already would have assigned a result here and skipped over this else if statement, we would never evaluate this. We'll need one more else if to check for a letter grade of D, which would be an average grade greater than or equal to 60, in that case, the letter grade is a D, and then finally, if I haven't branched into any of those if statements, then I know that the average grade is less than a 60, and the result should be a failing letter grade, a letter grade of F. And if I come back into the program, let's write out the letter grade, let's try to do a WriteResult of Grade, with stats.LetterGrade, and this is one of those situations where the C# compiler says, oh you're passing a string here, I don't see a version of WriteResult that takes a string, so let me copy this method and paste it in here, and create a version a WriteResult that takes two strings, one is the description, one is the result. I do not need to format result a floating point number, so let me take off the :F2 here, and run the program, and I can see that the average grade is an 85 and the letter grade is a B, so I think my logic is working correctly. Of course I should write a unit test to make sure, but again I'll leave that as an exercise for you to try.

Switching

The C# language also includes a switch statement. What the switch statement allows you to do is branch the execution of a program to a set of statements that are inside of a case label, which you create with the keyword case. The switch statement does this by matching the value inside the switch against the values that you specify in each case label. These values for each case statement, they must be compile-time constants, and we can see in the code on the screen, we're checking a variable to see if the name is equal to one of the string literals, Scott or Alex. If the name is Scott, we execute the method ServeSoda, and then we break out of the switch, that is we jump to the line of code following the switch. So we only execute the code inside of a single case. You can have multiple statements and multiple lines of code inside of a case, but you also must have a break statement in each case, that's a little bit different form other languages like C++ where you can fall through from one case to the next. Now if the value you are switching on does not match any of the values in the case statements, then the default path can be chosen, but you don't need to have a default label, so that's entirely optional. Let's take a look in code. Back in the Grades project, it might be useful to provide a textual description of the letter grade, that is a grade of A should produce text like excellent, while a grade of F should produce text like failing. This type of logic I could also add to GradeStatistics, and I could do this as another property. So in addition to the LetterGrade property, here is another public property of type string, let's call it Description, and just like LetterGrade, this will have only a get accessor. And inside of here, I could look at the average grade, but I could also look at the letter grade. I could say okay, if the letter grade is an A, let's produce this text, and if it's a B let's produce this text, and that's the type of logic I could do with if else statements, but since we're looking at switch, let's do a switch on LetterGrade instead. A switch statement is very much like a series of if else if statements, and what I can do case the letter grade is the string A, let's execute the following code. And what I want to do ultimately is compute some result, just like I did with LetterGrade, and then return that result at the bottom of the property. So when we have a capital A, let's say that the result = Excellent, and then you can think about this as else, if I have the sting B, the result would be equal to Good, or we could say Above Average, and notice I have a compiler error right now because it's illegal to fall through from one case label to another. And there's a couple ways to solve that error, but by far the most common approach is to use a break statement, and what the break statement will do is allow me to execute as many lines of code as I want inside of that case label, but once I hit the break statement, I'll be jumping out of the switch. And if we have a letter grade of B we can then break, of course a C, the result for a C would be Average, and then we break. We also need to handle the D case, and for the result there we could say Below average, and then break, and now I have a choice, I could either write another case statement and say, case letter grade is an F, or I could have a default label, in which case if the letter grade is anything but an A, B, C, or D, we will end up inside of here, and I can say the result is Failing, and once again I will still need a break. Let's try this out in the program. Instead of writing out the text Grade, let's write out stats.Description. I will run this program, and I can see that a B is a Good grade, so my switch statement appears to be working. So switch is the type of logic that you could also implement using if and else if statements, but note that I would not be able to implement LetterGrade using a switch statement. In a switch statement I cannot write an expression like AverageGrade greater than or equal to 90, all I'd be able to do is switch on AverageGrade, and have a case when AverageGrade is 90 exactly. So switch statements, not so useful for evaluating ranges, but sometimes useful for replacing if else if statements.

Iterating

There are four different statements for iterating in the C# language, iterating being a fancy term for looping over code and executing a block of code repeatedly. Typically you want to loop because you want to execute some code for each item in a collection, like printing out each number in an array of integers, and one statement we've already used is the foreach statement. This is where you use the foreach keyword, and declare a variable before the keyword in. The code on the screen has a variable named value, and I want to point out that this value variable, it's only available inside the block of code for the foreach loop, so once you exit the foreach loop and you've moved beyond that closing curly brace you can no longer access the variable named value. The code inside this loop, it will see each number in the array, and the variable value will hold each item once. So the first time through the loop we'll see the value 2, and the last time through the loop we see the value 100. This ages variable, by the way, it is an array of integers and we are initializing that variable using a collection initializer syntax in C#. This is where we just place objects or values between curly braces on the right-hand side of an assignment, and the C# compiler is smart enough to say yes, I can create an array from those values. Another looping construct in C# is the for statement. You can think of the for statement as being more explicit about the starting and ending conditions for looping, because with foreach you basically say, loop once for each item, but with a for loop, you have to say I'm going to start at 0 and I'm going to go to the number 4, because I know I have an array that has 5 items inside. To operate at this lower level, the for statement includes three pieces of information, there's the initializer, the condition, and the iterator. This is the same as the for loop in C, C++, Java, JavaScript, and many other languages. The for statement begins execution by executing any statements that are specified in the initializer, and these statements are only executed once, no matter how many times you're looping, that only executes once, then before any statements are executed inside of this for loop, the condition is evaluated, the condition appears after the first semicolon. The condition is always a Boolean expression that has to return true of false. If the expression returns false, then we do not execute anything inside of the for loop, and we stop looping and continue with the next statement after the for statement. But if the condition evaluates to true, we'll execute the statements that are inside of the for statement, that is everything inside the curly braces, and for that reason you could say that a for loop will execute 0 or more times because the program does test this condition before the first pass through the loop, and if it returns false on the first test, we don't execute any code inside, but then after each execution of the code inside, the iterator executes. In this case the iterator is incrementing the variable i, and then we come back and check the condition, if it returns true, we execute again. So the iterator is typically used to increment or decrement some sort of index variable, and I'm using a variable named i, i is short for index, that's a fairly common convention in C# programming. The while statement, this is another way to loop 0 or more times in a C# application. In this case the while statement evaluates an expression, and if that expression returns true, the statements inside the while loop will execute. Once the while loop is finished executing, the condition is evaluated again, and at some point, that condition should return false, unless you're trying to write an infinite loop, and infinite loops can be useful in some situations, but when that expression returns false, that's when we finish executing the while loop. And closely related to the while loop is the do while loop. The do while loop always executes one or more times, you're guaranteed to execute the code inside of here at least once, because the primary difference between a while and a do while is that in a do while the condition is checked after the code inside of the statement executes, so you're guaranteed to have control pass through a do while loop at least once. Let's see an example in the Grade project. Inside of the Grades project I'd like to give the GradeBook a new feature, I'd like to be able to walk up to any GradeBook object, and tell it to loop through the available grades that is has and write them to the screen, or write them to some destination. I'd like there to be a little bit of flexibility. For example, I'd like to be able to say something like, GradeBook, please write out the grades, and then pass in a parameter that will allow me to change destinations. Maybe I want it to be on the screen, maybe I want it to be in a file, and fortunately, the .NET Framework contains some abstractions that will allow me to do that. For example if I call WriteGrades, which is a method we still have to implement, but I pass in a static member of the Console class, which is the Out property, what that will do is send an object into that WriteGrades method that the GradeBook can use to write out to the screen. The GradeBook doesn't know it's the screen, but Console.Out, it represents the output stream that goes to this console window, to the screen. We'll see the type of that parameter in just a second. Let me use Visual Studio to generate this method on the GradeBook, I can do that by placing the cursor on WriteGrades and pressing Ctrl., you can see the drop-down option here is to generate a method, GradeBook.WriteGrades, that's exactly what I wanted to do, so I'll press Enter to take that selection, and now if I come over into the GradeBook I should be able to find that method in this class, it is right here. Let's make it a public method, let's get rid of this line of code that is inside the method, we'll replace it with something more useful, and let me change the name of this parameter to destination. But before I do, why is there an @ sign here? The @ sign is here because out is reserved keyword in C#, it's not legal to have a parameter named out, but anytime you want to have a parameter or variable name that has the same name as a C# keyword, you can escape that name using the @ sign. For example, I could also say @class if I wanted this parameter to be called class. But I generally avoid names that require an @ sign, let's call this destination. You'll see this destination is of type TextWriter, and this is a useful abstraction in the .NET Framework because I can write information into a TextWriter, and ultimately I don't know if that's going to a file, or to the console, or over the network, it just so happens that this particular TextWriter is going to be Console.Out so it will send output to the screen, but we'll see later some of the flexibility that this abstraction gives me. Now we've already seen how to use a foreach loop, so let's try using a for loop. There's a code snippet where if I just type for and press Tab, Tab, Visual Studio will generate the skeleton of for loop, it's going to do that by having an initializer i that starts at 0. Before we enter the loop each time we'll check to make sure that i less than some value, that's something we're going to have to change, and each time after the loop executes, we will add 1 to i using i++. So I want to loop from i = 0 to i is less than the number of grades in my list. Fortunately this private variable, grades, it has a Count property, and quite often if you're going to write a for loop against a collection, that collection will be a list which has a Count property, or an array which has a Length property, and you can use those properties in the conditions for your for loop. And now what I can do, is use my destination to write a line, which is grades, and I'm going to index into grades using that i variable to pull out a specific grade, the first grade will be index 0, the last item will essentially be index grades.Count -1. If I run the program, then we're printing out the 3 grades that we entered into the GradeBook, 91, 89.5, 75. Very good. What if we wanted to do them in reverse order? Well then I could start at grades.Count, and I could go and loop while i is greater than 0, and each time through the loop I would decrement i, or subtract one from i. And now because I'm starting this index at grades.Count, I just have to make sure that I subtract 1 from i when I index in to the Grades list. That way I don't try to index in to the Grades list with a value of 3 when Grades only contains 3 items, so now we get the grades in reverse order, 75, 89.5, 91. So the for loop is quite flexible, I prefer to use foreach when I can, and I would certainly use a foreach in this scenario, and I could even use a while loop, like the while loop that we saw on the slide. What I certainly wouldn't want to do is use a do while loop, at least not without writing some additional code, because a do while loop always executes once, and there's a possibility someone might invoke WriteGrades when there are no grades in the GradeBook, in which case we would never want to enter into a loop that tried to index into the grades, that would create a runtime error. We'll be talking more about runtime errors in this module, but next, let's talk about some statements that allow us to jump around in code.

Jumping

C# includes a number of keywords that allow you to unconditionally jump to some target. These keywords include break, continue, goto, return, and throw. We've already seen break, we know that we can use break inside the case label of a switch statement, but you can also use a break inside of a while loop, a do loop, a for loop, or a foreach loop, to break out of a loop and stop looping. For example, here is a foreach statement that's going to loop through some collection of integers, and inside of the code if the age variable holds the value 21, we're going to break out of this loop. So if age is equal to 21, even if there are more items left on that collection, we're going to stop execution of the foreach loop and continue execution on the statement that is after the foreach statement. The continue statement in similar, except that instead of breaking out of the foreach statement, we're going to skip executing any code after the continue statement and go to the next iteration of a loop. So in the code if we encounter an age value equal to 2, we're going to continue the loop, we're not going to execute anything that follows, and we're not going to jump out of the foreach statement. Essentially the continue statement starts the next iteration, and you can use it again inside of a while, a do while, a for, or a foreach statement. And then there is a goto statement in C#. You can use the goto statement to jump to another statement that is marked by a label. So in this version of the foreach loop, if we encounter age equal to 2, we're going to jump execution down to the label with the name of skip, and jump over any code that was in between. I do have to say in over 25 years of programming with various languages, I've never had to use a goto statement, and most programmers avoid goto at all costs, because it does make a program harder to follow. The return statement, this is something that we've also used in the demos of this course, but I do want to point out that you can use a return statement with a void method. So typically what we've done is, we'd have a method that has to return a string or an integer or some type of object like a GradeBook Statistics object, and we used a return statement to return the value of some variable. But it is legal to use return when you have a void method, you're just not allowed to pass a value back to the caller. In that case you just have the return statement. So in this foreach loop, if we encounter an age equal to 21, we are not only going to break out of the loop, we're going to jump out of the method itself. So if there was any additional code before we reach the end of the method, that code wouldn't execute. The last jumping statement that we need to cover is the throw statement, which it means it's time to talk about exceptions.

Throwing

The throw keyword in C# is used to raise an exception. An exception is a signal that an error condition exists, and as the name would imply, an exception should only be raised in exceptional circumstances, that is, you shouldn't use exceptions to change the normal program flow. Use exceptions when your software finds itself in a position where it cannot move forward. Exceptions are what happens when you have a bad input value, or the program is out of memory, or a network is not available for communication. Those are the types of situations that may require exceptions, but not always. When you throw an exception, you are throwing an object, this is why we say exception handling is type safe because every exception with C# is going to be of a known type, and the compiler can help you handle exceptions. We also say that working with exceptions is structured, because you can set up blocks of code to handle exceptions, meaning you can structure your program to anticipate certain exceptions, and try to recover from those error conditions. The reason we use a throw keyword, is you can picture your software throwing some error object, and the error object is going to start travelling back through the program until it is either stopped by an exception handler, which is a piece of code that tries to recover from an exception, or if there are no exception handlers, we have what we call an unhandled exception. With .NET an unhandled exception will terminate your program, which sounds terrible, but in reality it's usually better to shut down a program that has an unhandled error than it is to let the program continue because the program might be in a bad state after an error occurs, and it could save corrupt data, it's much better to fail. In this code snippet, we're checking to see if the age value is equal to 21, and if it is, we'll throw a new ArgumentException. So you can see that an exception object will have a type definition. In this case ArgumentException is a built-in class in the .NET Framework, and we need to create a new instance of that ArgumentException, and when we do, the constructor allows us to pass in a description so we can give some additional information about this error. Now if it is a common occurrence that age could be equal to 21, it's probably not something that you want to generate an exception for, exceptions should be for exceptional circumstances. Let's take a look in our program. Inside of the Grades project, you might remember that we gave the GradeBook a Name property in a previous module, and then the logic for the setter of that property, we added some validation checks to make sure that the incoming NewName value was not going to be null or empty. And currently, if a caller tries to set the name of a GradeBook to something that is null or empty, we silently ignore that assignment. What I'd like to do now is create an error condition so that if a caller tries to set the name to an invalid value, we will create an error condition in this program, we'll do that by throwing an exception. And to do this, I'm going to restructure the setter just a bit, I'm going to remove this if check, actually I'm going to cut it out with Ctrl+X, and remove the curly braces that made that a block of code, now I'm going to press Ctrl+K, followed by Ctrl+D, that allows Visual Studio to reformat that code, and we've removed the indentation that was there, we don't need that indentation any longer. And now what I want to do is have an if check, but this time I will remove the not operator, so this time I want to check if string.IsNullOrEmpty, and I can do that just by going right the string class and invoking the static method, I can also do that through the string keyword that is in C#, and now if value is null or empty, I want to throw a new exception. But what exception should I throw? There are many built-in exceptions in the .NET Framework, you can also create your own custom exception classes. A class that represents an exception that you can throw, it always ends with the word Exception, that is in the class name. And you can see if I just start tying Exception, the IntelliSense window will filter things out so I'm only looking at exception types. And just based on the few namespaces that we have imported right now, you can see there are many built-in exceptions. These exceptions include everything from a DirectoryNotFoundException, to a DivideByZeroException, and there's also some built-in argument exceptions, so there's ArgumentNullException, I could throw this exception if someone passes me an argument and that argument is null and I cannot work with a null value. There's also a slightly more generic ArgumentException, which is just a way of saying something is wrong with one of the arguments. And in the constructor for the particular type of exception, there's an overload of the constructor that allows me to pass in a more explicit message, so I could say, Name cannot be null or empty. This would be one way to do it, and let me hit Ctrl+K, Ctrl+D again to do some reformatting of the code, and let's go back to program.cs, and try to set the book's name to a null value. So using the null keyword in C#, run the program with Ctrl+F5, and I can see that the program has crashed with an unhandled exception, a System.ArgumentException, Name cannot be null or empty. Notice that this error information includes a line of code where this error occurred, and in order for someone to help track down the error and why this occurred, there's a full stack trace printed. So what is a stack? As a program is executing and you call a method, that calls another method, that calls another method, there's a data structure being built internally that we call a stack, and with each method that you call, something is pushed onto the stack. You can imagine almost like a stack of papers on someone's desk, every time we call a method, we write the method name down on a piece of paper, and add it to that stack, and every time a method finishes executing and it returns, we pull a piece of paper off the stack and we can look at that next sheet and know what method we came from, who was the caller, and go back there. A stack trace is showing you how execution arrived at this point in code where the unhandled error occurred. And it's telling us that the exception was thrown from line 53 of GradeBook.cs, but that's not really helpful when you're trying to track down a problem. What's really helpful is usually something further up the stack, and what's further up the stack is Program.cs line 14, and if I close the program and go to line 14, I am on the line of code that is really responsible for creating this error condition because this is the line of code that passed an illegal value. Reading the stack traces that come out in an error message can quite often help you try to locate the piece of code that started all the problems and led to an unhandled error. So now we've seen that an unhandled exception can terminate an application, but let's look at the other side of exceptions now and see how they can handle an exception, and prevent a program from crashing.

Handling

In a C# application you have the option of trying to handle an exception using a try catch statement. A try block is the try keyword followed by some curly braces, and inside the curly braces are the statements that you want to execute that might throw an exception. The try block can be followed up by one or more catch statements. In this case we have one catch statement. If ComputeStatistics were to throw an exception, the runtime will go looking for the closest matching catch statement, and by matching I mean that if ComputeStatistics were to throw a FailNotFoundException, the catch statement that I have here will not catch that exception, because that's a different exception type. This catch statement is looking for a DivideByZeroException. And when I say that the runtime looks for the closest matching type, I mean that the runtime is going to look for the handler with the right type of exception that is nearest to the point where the exception occurred. That doesn't mean closest in the source code, that means closest in the execution of the program. So if ComputeStatistics were to throw an exception, but it already has an exception handler for a DivideByZeroException inside of that method, then this catch statement would not get the opportunity to catch the error, the exception would already be handled. Let's take a look in the program. Inside of my program I know that if I set book.Name equal to null, that will cause the program to crash, and it would be easy enough for me to fix this problem just by giving the GradeBook some name with characters inside. But what if I didn't want to hard code a string, what if I needed to prompt the user for a GradeBook name, and I'll ask them please Enter a name, and then instead of a hardcoded string I use Console.ReadLine. Now I'm in a situation where I don't know when the program runs what value we'll try to write into book.Name, but I do know if the user gives me an invalid value, that will cause the program to crash. Now, ideally what would happen is, I would not assign Console.ReadLine directly into book.Name, instead, I'd save the value into a variable, perform some validation, and only set book.Name if have a valid value, and I might try to do that inside of a loop and continue to prompt the user to enter a name, as long as they're giving me an invalid value. But I'll leave that as an exercise for you to try, and instead what I want to do is just use some exception handling to prevent an application crash. So if I know book.Name will throw an exception that could crash the program, I might use a try catch statement. Inside of the try I can have as many lines of code inside of here as I want, so I could even include the Console.WriteLine, and if any exceptions emerge from any of the statements that are inside of the try, I will have the opportunity to catch those exceptions using a catch statement. With a catch statement I first have to describe the type of exception that I want to catch, in this case it would be an ArgumentException, and then I can optionally provide a variable where the runtime will store the exception object that was thrown. So when book.Name does throw an ArgumentException, I will capture a reference to that object inside of this variable ex. And now I could Console.WriteLine and tell the user that they entered an invalid value, I could also look inside of that exception object, and I can see there are properties like Message, what is the message associated with the exception, even a StackTrace, so I could print out a stack trace if I wanted the user to see things about method names and line numbers and .cs files. But let's just print out a Message, and now run the program with Ctrl+F5, when prompted to enter a name, I can just press the Enter key that will enter in an empty value, but now I'm catching the exception, I'm displaying the text Name cannot be null or empty, that's the exception object's Message property, and now the program can continue to run, there are no unhandled exceptions, and I print out the grades and the statistics. When we get to our next demo, we'll see what dangerous things can happen when I actually enter a valid name.

Chaining

You can follow a try block with multiple catch statements. This is known as chaining the catch statements. And even though we have multiple catch statements, only one of these catch blocks can execute after an exception is thrown from inside of the try block. The catch blocks will be evaluated from top to bottom, and the first one that specifies a matching exception type will be the catch block that executes. And that's why when you chain blocks like this, you want to include the most specific exception types first. And by specific I mean this, DivideByZeroException is specific exception type, but all exception types in .NET derive or inherit from a base exception class with the name just Exception. And we're going to talk more about inheritance and derivation in the next module, for now you can just know that this exception type is special that will catch nearly every type of exception that can be thrown in a C# application, there's just a few very special and very catastrophic exceptions that will always crash a program, you cannot catch them. But because I can catch nearly everything with this exception type, I want to include that catch statement after other catch statements, like a catch statement for DivideByZeroException. If the exception was on the top I'd never get the DivideByZeroException because that is also an instance of an exception type. Let's look at chaining in the demo. Back in Visual Studio let's run the application with the debugger by pressing F5, and now let me enter a name for the GradeBook, and when I press Enter the program generates an unhandled exception. The debugger will automatically stop on a line of code that generates an unhandled exception, and in this case we stopped on the line of code where we are invoking the NameChanged event. And you can see the exception is a NullReferenceException. And what's happened here is that we have declared this public event, NameChanged, but this event currently has the value null because there are no subscribers to this event. And as I've said before, if you try to invoke or use a variable that contains a null reference, you can end up with this NullReferenceException, and currently this exception is unhandled, and this is something to be careful of when you're using events, if no one has subscribed to an event, the event will be null, and that can create a NullReferenceException. This is an unhandled exception because we do not have an exception handler for a NullReferenceException, just an ArgumentException, but let's stop debugging and see if we can prevent the program from crashing. Now the ideal solution to this problem is to make sure that that event is not null before trying to use that NameChanged event. But before we do that, I wanted to use this scenario to show you how you can also catch a NullReferenceException, I can also name this variable ex because it is in a different scope than the ex variable for my ArgumentException, that only exists for the first catch block, and here in the second catch block I can now do a Console.WriteLine, and perhaps just provide a generic error message here like Something went wrong, and you'll notice in this case I'm not even using that variable ex, well the variable is optional, this is a way of telling the C# compiler I want to catch a NullReferenceException, but then I don't need a reference to that exception object, my code has all the logic and data that it needs, I don't need the variable. Now if I run the program, this time I'll run it with Ctrl+F5 without the debugger, enter in some name, and we now get the exception message Something went wrong. I could also try to catch Exception, and let's try to do that first. If I catch Exception, so not ArgumentException but just Exception, both ArgumentException and NullReferenceException, they both are of this exception type, and you can see I even get a complier error that says A previous catch clause already catches all exceptions of this type or a super type. So again more on super types and inheritance in the next module, but if I wanted to catch all exceptions, that catch clause would have to come here at the end. And I could also just use my existing block, and instead of catching a NullReferenceException just catch all exceptions and write out Something went wrong. But I will caution you that that is potentially dangerous, because you won't know if you're catching an exception that is related to security settings, or memory settings, or something went wrong in the input output system, when you catch exception you're catching everything, and we might be allowing the program to continue execution when what really should have let happen is let that exception go unhandled and terminate the program. But when I catch exception I can still enter a name and get that message Something went wrong. And like I say, the proper way to handle this is inside of the GradeBook, and it would actually be rather important to make sure that NameChanged is not a null value before I try to invoke it, and I could do that by adding an additional if statement here, we've talked about nested ifs earlier in this module, or I could also add an additional condition to this Boolean expression. So I could say name is not equal to the existing value, and NameChanged is not equal to null, that way both of those conditions have to be true before we go out and instantiate NameChangedEventArgs and raise this event. And with logic in place, I shouldn't need to catch a NullReferenceException, I should just be able to run the program, enter in a name, and the program continues normally. We're not listening for the NameChanged event, but that's okay, we didn't need any logic in the program to do any sort of processing when that event occurs.

Finally

After a try statement you can optionally include a finally statement. The finally statement allows you to specify a block of code that is always going to execute even if there's an exception inside of the try block. So the finally code executes when there is an exception, and when there is no exception, and that makes the finally block a good place to add finalization code, that is, code that will clean up resources that you might have acquired previously. In .NET we talk about managed resources, but really the only resource being managed by the .NET runtime is memory. The runtime knows what memory you are using and what memory you are no longer using and it cleans things up for you. There are other resources you'll probably need in an application, resources like a data file, or a network socket, or a database connection, and when you're working with these resources it's important to close, or release, or free these resources when you're finished. Otherwise you can leave behind corrupt data or run out of these resources. In this sample we're opening up a file on disk, and we want to make sure it's closed even if there's an exception that's thrown. We can do that with a try finally by putting a file.Close call inside of the finally block, and although I didn't show it in this example, you can also have one or more catch statements in here that try to catch exceptions. Many of the classes in .NET that represent unmanaged resources, that is resources that you have to explicitly close, they all implement a special interface known as IDisposible. We'll talk more about interfaces in the next module too, for now just know that if an object has a disposed method that you can see in IntelliSense, chances are the object is a disposable object, and you can implement the try finally logic in a cleaner way with a using statement. This is not a using statement for namespaces like we saw earlier, this is a using statement that will make sure an object is properly disposed and resources are freed, even if there is an exception. So in the code snippet I'm using two FileStreams, and these FileStreams will be available throughout the code that is inside of the curly braces beneath the using statements, and once we reach the bottom curly brace, the C# compiler will generate code to make that these FileStreams are properly disposed and they're properly closed. That makes sure that all the data that we might have written to a file will be flushed out to disk, and also these files won't be locked and prevent someone else from opening up the file. Let's take a closer look in code. Let's work with a file in the Grades project. What I'd like to do is have the GradeBook write the grades that it stores into a text file, and we already have a WriteGrades method on the GradeBook that allows the caller to set the destination using a parameter. In this case the destination is the Console, so all my program really needs to do is swap Console.Out with an object that will write to a file instead. And this can be fairly easy with the .NET Framework. There is a file class in the .NET Framework, it's in the System.IO namespace, so I'm going to type in file and press Ctrl., that will bring up the action menu that allows me to select this top entry, which says please add a using statement for System.IO at the top of this file. And now on this file class, there's number of static methods that allow me to easily create, and append, and delete files from the file system. I'm going to choose the method CreateText, I need to give this method a string parameter that tells the framework the name of the file that I want to create, and let's call that file Grades.Text, and you can see this method returns an object that is of type StreamWriter, and it turns out that a StreamWriter is compatible with a TextWriter that the WriteGrades methods expects. So if I press F12 to go that method definition, you'll remember we created this method taking a TextWriter, and a StreamWriter is a type of TextWriter. So let me save the return from File.CreateText into a new variable of type StreamWriter, let's call it outputFile, and now what I should be able to do is pass outputFile into the WriteGrades method, and let's try it out by running the program with Ctrl+F5. I'll need to give the GradeBook a name, let's just give it the name Z, and now I no longer see the grades being written to the console, but let's go out and check our Grades.Text file. Since I didn't specify a full path when I did File.CreateText, this file should be created in the same directory where the program is executing, and one easy way to get to that directory is right-click on the Grades project, say Open Folder in File Explorer, and then I can navigate to the folder where the actual assembly lives, so that's the bin, Debug folder, and it's inside of here where I can see a text document, grades.Text, let's open that up and you can see that it is empty. Now this file may not always be empty, it might depend on other things that you're doing in your program, or if you're doing anything with the debugger, but what's happened here is I have written information into a stream, and you have to be a little bit careful with any type of stream, whether it's a FileStream or a NetworkStream, streams have a tendency to buffer information that you write into them, and if you don't properly flush that stream, or close that stream, or dispose that stream, there's a chance your program could exit without the information ever arriving at the actual destination. So this StreamWriter, it does have a Close method, and let's just see what happens if I explicitly invoke this Close method, run the program again, give the GradeBook a simple name, and now come back out to the folder, and open up this text file, and I can see the grades did successfully arrive inside of the text file, so that's good, but typically you don't want to write your code in this style when you're writing a real C# application. Anytime you're working with input and output, there's always a chance for an exception, and you might say well, what types of exceptions? For example, you might be wondering what types of exceptions could File.CreateText throw? And one way to answer that question is to go to the documentation. Since the File class is part of the .NET Framework, I can go to msdn.microsoft.com, the Microsoft Developer Network, and I should be able to find documentation of File.Create. So let me do a search for File.CreateText, and here is that method as the first result in the search list, and as part of the documentation for this method, there will be a list of exceptions that this method could potentially throw. And you can see there might be an UnauthorizedAccessException, or an ArgumentException if I pass an invalid path. The path could also be too long, Windows has a limitation on the maximum length of a path and file name. I could also be trying to create this file in a directory that doesn't exist. So all sorts of things could go wrong. And ideally what I would do, is I would use this StreamWriter inside of a try, catch, finally construct, where inside of the finally I would do something like, outputFile.Close to make sure that no matter what goes wrong inside of creating the file or writing the grades, I'll always be closing this file that I'm creating. But the try and the catch is only useful if I actually want to do some sort of exception handling and process exceptions. And so an alternative approach to making sure this output file is always closed, is to wrap this StreamWriter with a using statement. The using statement is essentially saying I'm going to be using this unmanaged resource, this StreamWriter in the following block of code. So I will use curly braces to contain all the code that's going to be using that resource, and behind the scenes what the C# complier will do is essentially set up a try finally to make sure that if there are any exceptions inside of this block of code, then it will always dispose of this output file. And you can see in the IntelliSense window that there is both a Close method and a Dispose method. And any time you see a Dispose method that's a good indication that you would be able to use this object in a using statement. And many classes in .NET will offer both a Dispose method and then some sort of explicit Close method, and you can think of them as synonyms for one another, and they both ultimately achieve the same effect which is to make sure this unmanaged resources released, and closed, and flushed properly. And since I now have outputFile wrapped with a using statement, I no longer need to explicitly invoke close or dispose, that's going to happen for me. And if book.WriteGrades does throw an exception, it will go unhandled and crash the program, but that's okay, I'm still going to make that these resources are cleaned up. If CreateText throws an exception, that will also be an unhandled exception, I have no try catch block here, and in that situation we'll have to assume that the .NET Framework is properly cleaning things up, because if CreateText throws an exception, I'm not going to get an outputFile object back, I'm not going to get a StreamWriter. So this code should be a little more robust now, and I should be able to still run the program, enter a name for my GradeBook, and come out to the Grades.Text file, and see that it's populated. And any time you're working with an object and you see there is a dispose method, you'll probably want to consider if you should be using a using statement or not. Now there's one more thing that I want to do to this program before we leave, and that's just clean a few things up because we have various bits of code scattered around this main method doing all sorts of different things, and to me the method just feels messy. So one thing I would like to do is highlight the lines of code that try to achieve a specific goal, like getting the name for a GradeBook, and refactor these bits into individual methods that have a name. And one easy way to do that is to select the code, and then press Ctrl., the only option that pops up here is an ExtractMethod option. This is part of the built-in refactoring tools in Visual Studio, and if I just select this option, Visual Studio will create that method for me and I can name this method now, I could name it something like GetBookName, and when I press Enter, Visual Studio will apply changes throughout my source code, I now have a method that I can call GetBookName, which will contain the code that was previously inside of the main method. Let's do this a few more times, let's also use ExtractMethod on these three lines of code, because what these three lines of code are doing are really adding grades to the GradeBook, then, I'm using a few lines of code here to save the grades to the file system, and finally at the end I'm going to extract a method to write the results. And now to me the main method looks much better because we're breaking down the small steps and individual pieces of the program into named methods that have just a little bit of code inside of each one, and to me that's always a better design that is going to be easier to maintain. We're going to be talking more about design in the next module on Object-Oriented Programming.

Summary

In this module we looked at flow control statements in C#. These statements included the conditional branching statements like the if statement. We also looked at looping statements like the for loop and the jumping statements like break and continue. Finally we took a close look at exceptions because exceptions are the error handling mechanism that is built into .NET, and sooner or later you will either need to throw an exception because your program has detected a critical error, or you will need to handle an exception and try to either recover from the error or log the error and prevent the program from terminating. We also saw the importance of cleaning up unmanaged resources like open files and how we can let the C# using keyword help us clean up and free these unmanaged resources.

Object Oriented Programming

Introduction

Hi, this is Scott, and this is the final module in this C# course. In this module I want to give you the concepts and syntax for Object-Oriented Programming in C#. C# is an object-oriented programming language, although you can do more than just object-oriented programming in C#, and I talk about those topics in the C# Programming Paradigms course on Pluralsight. In this module of this course we're going to look at inheritance and polymorphism and how to use abstract classes and interfaces.

The Pillars

The C# language provides the syntax and tools to build on what is known as the three pillars of object-oriented programming. These three pillars are encapsulation, inheritance, and polymorphism. My personal view is that encapsulation is the primary pillar of object-oriented programming, and most classes and training tend to overemphasize inheritance and polymorphism as being more useful than they really in day to day programming. But that's my personal view. We are going to talk about all three pillars however, and understanding how inheritance and polymorphism work in C# is important, even if you don't put those two pillars to work all the time in the software that you write. Encapsulation is the key pillar of OOP, because without encapsulation we could never build large applications or large systems. Encapsulation helps us hide complexity, and it allows me to reason about something like a grade book, which we've been building in this course, and think about what I can do with a grade book, which is add grades and compute statistics. And I don't have to worry about the details, and the data structures, and the calculations involved. So classes are one way to achieve encapsulation in C#, but taking 10 lines of code and putting that code into a method is another form of encapsulation. Instead of knowing the details about those 10 lines of code, I can now think and reason about just the method and what it can do, what inputs does it take, what does it return. And that method even has name that I can use to refer to everything that is happening within those 10 lines of code. Encapsulation then is all about hiding complexity and building models, which logically group together functionality. But inheritance and polymorphism are different, these two pillars of object-oriented programming are about reusing code and reusing data. It's almost never a good idea to have duplicated code inside of an application, and inheritance and polymorphism are two techniques to avoid duplicated code and reuse that code instead. So let's turn our attention to inheritance.

Inheritance

Inheritance is a technique where I can define a relationship between two classes such that one class takes on or inherits the members of another class. So if class A has one method, DoWork, then class B can also have that same method, just by inheriting from class A and not writing any additional code, but reusing the code already in the first class. If class B wanted to have an additional method, it can. The syntax for inheritance is to use a colon after the name of your class, and then you specify the base class, that is the class whose members you are going to inherit. We've already seen some inheritance in this course when we defined a custom event arguments class for the GradeBook's NameChanged event. All events in .NET should be pass an arguments parameter that inherits from EventArgs in the framework class library. You can only inherit from a single class in C#, that is you can only specify a single base class after the colon, but the inheritance chain is unlimited. You can have class C inherit from class B, which inherits from class A, and in that case class C is inheriting all the members from B and A. So class C would also have a DoWork method. You do have to be cautious with inheritance because it does tie up your classes and your code into a tightly bound relationship. I talk about that more in the Programming Paradigms course, for now let's take a look at inheritance in code. Inside the Grades project that we've been working on throughout this course, let's imagine that our users came to us and they've told us that occasionally they want a grade book that will through away the lowest grade before computing statistics. That will allow a student who has a bad day or one bad assignment to not be penalized as much for that one bad grade, and this is something that the users occasionally want to do, they don't want to get rid of the original algorithm for the grade book, they just occasionally want to compute statistics and throw away the lowest grade. Now what are some different approaches to implementing this? Well I could take all of the code in the GradeBook and press Ctrl+A and copy this code and paste it into a new class, perhaps we can call it the ThrowAwayGradeBook, and then I can go in and tweak the code, and tweak ComputeStatistics to throw away the lowest grade before doing the rest of the computations. But this copy and paste approach can lead to a lot of duplicated code inside of an application if that happens too often. So another approach might be to modify the existing GradeBook, perhaps add a public property, ThrowAwayLowest, and if I'm in a situation where the lowest grade needs to be thrown away, I could always instantiate the GradeBook and then set this property to true, and inside of ComputeStatistics check this property, and if it's true run a little bit of code to remove the lowest grade and then continue with the execution that's computing the statistics. That's another approach. And the approach that ultimately I would take really depends on the team that I'm working with and the type of application I'm building, and most importantly the business, where else do I anticipate that the business might want to make changes to the GradeBook or the algorithms that are involved? And in some of those scenarios I would use inheritance to solve this problem, and that's the approach that I'll show you today. Let's go into the Grades project and add a new class. I will call this the ThrowAwayGradeBook, because it will throw away the lowest grade. And I want this to also be a public class, and this is a class that I want to inherit from GradeBook. So at this point, ThrowAwayGradeBook has all of the same capabilities as our regular GradeBook. In fact I can come into Program.cs, and instead of instantiating a GradeBook, I can instantiate a ThrowAwayGradeBook, and I can take that object and assign it to a variable of type GradeBook. We would say that the ThrowAwayGradeBook is a GradeBook, because ThrowAwayGradeBook inherits from GradeBook, it's a specific type of GradeBook. And in C# you can always take a derived type and assign it to a variable of a base type and that's completely legal. At this point I could even run the program, first let me comment out this line of code that would force me to input a GradeBook name, I can run this program with Ctrl+F5, and I can see that we're still outputting the same numbers that we had before, the average is 85.17, and the lowest grade is a 75. So currently, this new ThrowAwayGradeBook object behaves just like a regular GradeBook. Now what I want to do is have ComputeStatistics behave a little bit differently, I want it to throw away the lowest grade. So on the ThrowAwayGradeBook let me create a public method that will return an object of type GradeStatistics, this is also called ComputeStatistics, and inside of here I want to reuse the existing algorithm that is inside of the GradeBook as much as possible, because it's already doing the hard work of the calculations, and I can do this. You might remember earlier in the course we talked about a special implicit variable that's available inside of every instance method, that is a non-static method, and that's the this variable. This is a keyword in C#, and this allows me to reference the object that I'm currently inside of, and I can see in the IntelliSense window I can reach methods that are on my object instance, methods that I've inherited, methods like AddGrade and ComputeStatistics. There's another keyword in C#, a special implicit variable, it's called base, and what base will allow me to do is reach specific methods in a class that I've inherited from. So in this case when I say base.ComputeStatistics, I'm really referring to that ComputeStatistics method that is available from the GradeBook. And ultimately what I could do is just say return whatever that ComputeStatistics method comes up with that will use the existing code inside of the GradeBook. But before I invoke that ComputeStatistics method in my base class, I need to remove the lowest grade. So let's declare a variable of type float, I will call it lowest, and initialize it to float.MaxValue, and what I need to do is loop through each grade that is in my grades collection, except I cannot reach the list of grades from the ThrowAwayGradeBook. Notice the errors that grades is inaccessible due to its protection level. Over in the GradeBook, you might remember that when we created this grades field, this list of grades, we marked this field as private, and the only code that is allowed to access this field is code that inside of the same class, inside of GradeBook.cs. But I do want to give the ThrowAwayGradeBook access to these grades. Now I don't want to make grades public, that would give everyone access to this field, I need something in between, and that in between level of access is protected. So a public member, anyone can access. A private member, only code inside of the same class can access. A protected member, whether it's a field, or an event, or a method, a protected member you can access from code that is in this class, or code that is in a derived class. And by marking grades as protected, I should now have access to that field from any class that ultimately inherits from GradeBook. And I could now say lowest = Math.Min, between the grade that I'm looking at and my existing lowest score, and when that loop is finished I should have the lowest grade in that variable, and now there's a very convenient Remove method that I can use on a list, and I could say grades.Remove this lowest item. Now there's a couple situations I should be careful with in this code, I should be careful if there's only one grade in the grades collection, or if there's no grades in the grades collection, or if someone's going to call ComputeStatistics multiple times and keep removing grades, those are all situations I need to worry about, but I'm just making you aware of those, we want to focus on inheritance and this is about the simplest possible thing I could do to remove the lowest grade. So let's run the application again, and you'll notice I'm getting the same results as I did before, the average is still an 85.17, and the lowest grade is still a 75. What's going wrong? Let's debug this a little bit using Console.WriteLine. Sometimes Console.WriteLine is easier than using the debugger itself. Here I'm going to say that we are inside of ThrowAwayGradeBook: :ComputeStatistics. And I'm going to take this line of code and go to the GradeBook and paste that line of code into ComputeStatistics, just so I know when we are inside of the GradeBook: :ComputeStatistics method. Let me run this program again, and I can see that clearly I'm invoking ComputeStatistics on the GradeBook, even though inside of my program I've instantiated a new ThrowAwayGradeBook. So this isn't quite the behavior that I want, I want to be able to instantiate the ThrowAwayGradeBook, and I want that new version of ComputeStatistics to work when I instantiate that GradeBook. So let's take a look at solving that problem in the next clip, but right now I just want you to know that we have an inheritance relationship now between ThrowAwayGradeBook and GradeBook. Anything that I can do with a GradeBook I can also do with a ThrowAwayGradeBook, and when this program executes I really am executing against a ThrowAwayGradeBook. That's the type of object that I pass to WriteResults, and SaveGrades, and AddGrades, it's just that we need it to work a little bit differently. So let's talk about that next.

Polymorphism

Polymorphism is the third pillar of object-oriented programming, and if you know a little bit about the Greek language, which I don't, you'd know that poly stands for many, and morph stands for shape, and thus we're talking about the concept of many shapes. That's a good description for the behavior that we can achieve with C#. I can have a variable of type GradeBook, and I can point to objects with different shapes, so objects with different types, as long as all those objects inherit from or are a GradeBook, then it's legal. So my GradeBook variable can point to a GradeBook, but it can also point to a ThrowAwayGradeBook because again, another way to think about inheritance is to think about is a relationships. We say that a ThrowAwayGradeBook is a GradeBook, it derives from GradeBook, GradeBook is a base class, and any time you have an inheritance relationship you can have a variable typed as a base class that points to an object derived from that base class. I cannot have a variable typed as string that holds an integer value because those two types have no inheritance relationship, but I can declare a variable typed as object and point it to anything, a string, an integer, a date time, a GradeBook, because System.Object is the ultimate base class for anything and everything in .NET. Everything in .NET ultimately derives from System.Object, so if you declare a class and do not explicitly declare a base class for that class, the base class is System.Object, just like the code on the screen is being very explicit in saying the class A inherits from object. I could leave the :object off and have the same result. And class B inherits from class A, which inherits from Object. So an instance of B is an A and is an object. There's also a keyword in C# to work with System.Object, and that's just the word object with a lowercase O. Now in this code, both class A and class B have a DoWork method, and just like with the GradeBooks that we're working with, we want these two methods to behave differently. Now currently we have a ThrowAwayGradeBook, but we assigned that object to a GradeBook variable, and when I call ComputeStatistics, we saw that we're invoking the ComputeStatistics method in the GradeBook, not the ThrowAwayGradeBook, and that's because the C# compiler without any other information, is going to choose the method to invoke based on the type of the variable. If I define a method or a property with a virtual keyword, then the C# compiler will generate code to invoke that method by looking at the type of object it's working against at runtime. Without the virtual keyword the method we invoke is determined by the type of variable that we're invoking the method through. It's the virtual keyword that gives us polymorphism, because now, I can have a variable that points to different objects, and when I invoke methods or properties on those objects, they can all behave differently. Classes that inherit from class A can override that DoWork to behave differently. Let's get a concrete example with our GradeBook. Currently in the GradeBook project we are not achieving polymorphism. We're not achieving polymorphism because ComputeStatistics in my GradeBook class does not use a virtual keyword, and thus, when the C# compiler sees a call to ComputeStatistics through a variable typed as GradeBook, the C# compiler will determine the method to call based on the type of this variable. So it sees GradeBook.ComputeStatistics, it's going to invoke ComputeStatistics, the one that is defined inside of GradeBook.cs. Now let's do a little bit of an experiment. Let's temporarily say that WriteResults has to take an object of type ThrowAwayGradeBook, which means I also need to type this variable as ThrowAwayGradeBook because WriteResults will no longer accept just a GradeBook, it has to have a more specific type, the ThrowAwayGradeBook, and now if I run the program, I can see I call into ThrowAwayGradeBook: :ComputeStatistics, which calls into GradeBook: :ComputeStatistics, and now the average is up to a 90.25 which is an A, we've thrown away the lowest grade, which is what we wanted to do. But I'd like to achieve the same behavior using polymorphism, I'd like to achieve the same behavior leaving this variable typed as GradeBook, and having WriteResults take an object that is just a GradeBook, because with the magic of polymorphism I can implement WriteResults to take a GradeBook and have many different types of GradeBooks and have those objects behave differently without me doing any additional work inside of WriteResults, or tying myself to a specific type of GradeBook, like the ThrowAwayGradeBook. In fact, I'm even going to take this line of code and press Ctrl+., and tell Visual Studio that I want to extract this into a new method. I'm going to call this method CreateGradeBook, and although it might not make a lot of sense here in a simple application like we have with the GradeBook, but there are many times in software where you want the flexibility of having something created for you via a factory class, or a provider, or some sort of infrastructure that's in your application, you just want something to be created for you, know that it has some type like a GradeBook type, that you don't ultimately want to know exactly what type you're working with. Is it a regular GradeBook, is it a ThrowAwayGradeBook, really all the rest of the code that I have inside of Program.cs doesn't care, so I want to work with variables of type GradeBook, but have polymorphic behavior when I invoke methods like ComputeStatistics, and that's when I have to come into GradeBook.cs and use the virtual keyword, because now when the C# compiler sees me invoke ComputeStatistics through a variable typed as GradeBook, it's no longer going to use the type of variable to figure out which method to call, instead it's going to use the type of object, the type that it sees at runtime. So if it sees ultimately that that GradeBook is a ThrowAwayGradeBook it will go looking to see if the ThrowAwayGradeBook overrides ComputeStatistics. And this doesn't mean that I hide or replace the ComputeStatistics method that is in the GradeBook, I can still access that method using base.ComputeStatistics, it just means that if someone does invoke ComputeStatistics, I have the ability, if we're really working with a ThrowAwayGradeBook to change the behavior of what's going to happen, in this case invoke my method that I've implemented for ComputeStatistics, instead of the method defined in GradeBook. And just to go back and talk about what was on the slide GradeBook, I haven't defined a base class for GradeBook, but technically GradeBook does inherit from System.Object, and that's why inside of Program.cs, any time I'm using IntelliSense against GradeBook, I can see methods that I haven't defined in the GradeBook methods like get GetHashCode, GetType, ToString, those are all methods that are defined on System.Object, and those are all methods that I can override. If I just type override in Visual Studio and press space, Visual Studio is smart enough to figure out which methods that I have my inheritance chain that are virtual that I can override. So if I wanted ToString to behave differently, I can override that method, and provide my own custom implementation of what will happen if someone says book.ToString. But now we're working with variables of type GradeBook, but GradeBook has a virtual method, ComputeStatistics, and ThrowAwayGradeBook, which inherits from GradeBook, it's going to override that behavior, I should be able to achieve polymorphic behavior when I say book.ComputeStatistics. I'm not going to know exactly what happens at this point at compile time, I don't know what ComputeStatistics will be invoked, because the method that is invoked will depend of the type of object that is passed in here, not the type of variable, so Ctrl+F5, and I can see, even though I'm working with a variable of type GradeBook, I am calling ThrowAwayGradeBook, and the lowest grade is an 89.5, which means the low grade has been thrown away, and the letter grade is an A.

Abstract Classes

Earlier I said that inheritance and polymorphism are overrated, and I can qualify that now by saying, inheritance and polymorphism are overrated techniques for code reuse. You can achieve some fantastic designs with polymorphism, which requires some inheritance, you just need to be very careful of the inheritance part. Inheritance binds two classes together into a relationship that cannot be broken, and over the years I've found that inheritance can make software harder to change and harder to understand. Fortunately, there are a couple ways to reduce the amount of rigidity in inheritance, one way is to use abstract classes, and the other way is to use interfaces. Let's talk about abstract classes first. An abstract class is a class that you cannot instantiate because it is not fully implemented. The code on the screen is showing an abstract class to represent a window. So the scenario might be that we're building a UI toolkit, and we need some base type to represent all types of windows on the screen, dialog windows, transparent windows, modal windows, this type is abstract, I know, because it uses the abstract keyword in the type definition, and then the class goes on to define some members. Every window will have a title, every window will have a draw method, and both title and draw have an implementation, they are real working members. If you inherit from window, you don't need to do anything to those members, they are all ready to go, although you can override either the property or the method because they're both virtual. And you could, for example, make the window draw itself using a different piece of code. But then there is the Open method, which is marked abstract, meaning this method has no implementation, it ends with a semicolon, and there is no body defined. To instantiate any kind of window, you will need to derive from this window class and provide an implementation for the Open method. If you don't provide an implementation, you'll be building another abstract class that you cannot instantiate. But a class that derives from window, and provides a definition for Open, that will be what we call a concrete type, it's something that I can instantiate. So there's concrete types and abstract types. You can only instantiate concrete types. If you cannot instantiate an abstract type, why is it useful? It's useful because of polymorphism, because I can declare a variable of type window and use that variable to point to any kind of concrete window that derives from this abstract type. I can interact with any of those windows. I can set the title, I can tell them to draw, I can call open. Those three members are guaranteed to be there if I have a real window object, it must have been created from a concrete derive type. But when I wrote this window class I didn't know how Open needs to behave, that's why it's left as abstract method, I just know there are other pieces of code in the application that need to work with these windows, and they must be able to invoke an Open method to get those windows on the screen. And again this goes back to topic of complexity, somewhere in the code I could be working with window variables, and those window variables are useful because this window type will define everything I need, I don't need to know the specific derived type of window that I'm working with, I don't need to know how it was implemented, of if there are 2 types of windows, or 20 types of windows, I just have code that works with windows, and that's simpler and reduces complexity. Now let's use an example with our GradeBook. Imagine now that the change requests for GradeBook functionality are coming fast and furious. The business is discovering all sorts of different uses for our GradeBook, different ways to compute statistics, different ways to store the grades, people want grades in a database, or in an XML file, they want report cards, they want dashboards, and the implementation of GradeBook.cs is starting to feel a little bit strained, it's not fulfilling all the needs of these different types of GradeBooks. In fact, I might even take a step back and say there's a more general case of we need to track some grades, which is something a GradeBook does, but we're going to add all these other classes that also track grades. And if that's the case I might come in to the project and create a more pure type, a type that defines the things that I need to do without defining the implementation details, so an abstract class, let's call it GradeTracker. In this GradeTracker, I want it to be a public class, but I also want it to be and abstract class, because ultimately I want GradeBooks and ThrowAwayGradeBooks, I want them all to ultimately inherit from GradeTracker. But when I'm building the GradeTracker, I only want to focus on the general capabilities of what these different types of trackers can do, and I have a pretty good idea of what they need to do just based on the program that I've written so far. I know, for instance, that I will need the ability to add a new grade to a GradeTracker, but what I don't know is exactly how that grade is going to be stored, is it going to be in a list, is going to go into a file, is it going to go into a database? I'm going to leave those implementation details to a derive class, so I will mark this method as abstract also. It has no implementation details. And I want to look at the public implementation details for GradeBook, and give a GradeTracker all these capabilities, but without the details. So for example, let's give all GradeTrackers the ability to ComputeStatistics, we're just not going to provide implementation details there. Now this method will no longer be virtual, virtual methods need an implementation, but this method can be abstract and implemented in a derive class. Back in the GradeBook I will also need to do this with WriteGrades, so let me copy that method, the start of that method, paste it here, and this method will also be abstract, and I do need to bring in the System.IO namespace for TextWriter, so Ctrl+., and select System.IO, and then back in the GradeBook, I already have AddGrade as an abstract member, and now this Name property and the NameChanged event, and the logic to track changes, and detect changes, and manage this field, let's say that this is something that will not change throughout all the different GradeTrackers. So what I'm going to do is actually cut this code out of the GradeBook, and add it to the GradeTracker, because as an abstract class, this class is allowed to have some implementation details. So here is a real property that can be used, a Name property, and a NameChanged event, and a private string, _name, I might want to change this to protected, only if I wanted derive classes to directly access _name, that's a decision I have to make, but in this case I'll make it protected. And ultimately the entire purpose of GradeTracker is so that I can work with variables of type GradeTracker in a place like my program, and not worry about the specific type of GradeTracker that I'm actually operating against, just like we did with GradeBook and ThrowAwayGradeBook, but now we're introducing a new type, a type that it even has fewer implementation details in it, and ultimately what I would like to do is work with a GradeTracker here. Now currently CreateGradeBook returns a type that does not derive from GradeTracker. I will need to set up GradeBook so that it inherits from GradeTracker. But before I go over there, let me take this type Name, and I want all these methods, like WriteResults, and CreateGradeBook, I want them to take parameters of type GradeTracker, in the case of Create return something that is a GradeTracker, so that I'm working with this low-level type throughout my program. And I think I've made all the changes there, so let's come back to GradeBook.cs, and now instead of implicitly, or in this case explicitly inheriting from object, let's have this inherit from GradeTracker. And there's just a couple other things that I need to change. You can see I currently have an error, and if I hover over the red squiggly, Visual Studio tells me that GradeBook does not implement the abstract member WriteGrades, or ComputeStatistics, or AddGrade. And the reason is this, when I implement ComputeStatistics and GradeBook, if I want this method to provide an implementation for an abstract method that is in my base class, then I can no longer use the virtual keyword, instead I have to use the override keyword. So an abstract method is implicitly a virtual method, therefore ComputeStatistics is a virtual method in my base class, and I'm not trying to define a new virtual method, I'm trying to override that existing method, I'm also going to have to come to WriteGrades, and use the override keyword here, and with AddGrade, all of these were abstract methods in my base class, therefore they're virtual and I need to override them. And now I should be able to press Shift+Ctrl+B to do a build, and my build is successful, let me press Ctrl+F5 to run the program, and I can still see that the results are the same, and the results are correct, and the lowest grade is an 89.5, this is all good. But now inside of my application, I'm working with this abstract type GradeTracker, and I no longer care when I call ComputeStatistics, or even AddGrade, or WriteGrades what the implementation details are inside of here. And just so you can see the error, if I try to instantiate a new instance of GradeTracker, that will give me an error, I cannot create an instance of an abstract class. So although I can work with GradeTracker throughout this program, when I actually instantiate an object, it needs to be a concrete type, so it needs to be a GradeBook or a ThrowAwayGradeBook.

Interfaces

Building an abstract class is one way to define a type to achieve polymorphism, but another approach is to define an interface. An interface definition uses the interface keyword, and an interface is a type in the .NET Framework. Just like the class, struct, and delegate keywords define types, so does interface. An interface is special because it can never contain any implementation details. When you define an interface you're defining an API for an object, that is any object that implements an interface is guaranteed to have the members an interface describes. The code snippet on the screen if for IWindow, and it's a common naming convention to define interface types with a leading capital I. That's how all the interfaces and the .NET Framework are defined. So any object that implements IWindow must have a title property that is both readable and writeable, it also must have a draw method that takes no parameters and returns void, and it must have an Open method, also a no parameters and returns void. In some ways an interface is like an abstract type, because in order to create a concrete class that implements this interface, I must implement those three members. But there is one huge difference between an abstract class and interface. When I define a class, I can only inherit from a single base class, but I can implement as many interfaces as I like. I can inherit 1 interface, or 10. I can also inherit from a base class N, implement 10 interfaces, as long as I have all the interface members defined. So the interface is the ultimate abstraction, because an interface allows you to define the API your software needs without defining any of the implementation details, and because any class or struct inherit from any interface, interfaces are extremely flexible. People will occasionally ask me if they should be using abstract base classes or interfaces, and I generally favor interfaces. That's just because over the years I've never looked at an interface and said oh, I wish that was an abstract class. But I have looked at an abstract class and said, oh, I wish that was an interface, because abstract classes can be a bit rigid, and make for a complicated inheritance tree. So I prefer interfaces, but we can always debate this. Let me show you some interfaces in code. In the Grades project if I really do have to work with a wide variety of different types of GradeBooks and GradeTrackers, I might decide that I want to work with an interface definition instead of an abstract base class. So instead of a GradeTracker type, I would like an IGradeTracker, where IGradeTracker is an interface that defines a programming API so I can add grades and ComputeStatistics. In Visual Studio if I put the cursor on IGradeTracker and press Ctrl+., Visual Studio will give me an option to generate an interface IGradeTracker in a new file, that's the option I'm going to select, so I press Enter. And now in the project I have an IGradeTracker.cs, it's an interface that currently doesn't define any members, so you'll notice inside of Program.cs, I'm going to have a number of compiler errors, let me go ahead and make some changes so that CreateGradeBook returns something that implements IGradeTracker, and WriteResults takes an IGradeTracker, so does SaveGrades, so does AddGrades, also GetBookName, and that should be all of the changes that I need. Of course currently since this interface does not define any members, I have no ability to WriteGrades, or AddGrades, or do anything useful with an IGradeTracker, so let me borrow some of the code from GradeTracker. I'm going to take these first three lines and paste them into my interface definition. Now inside of an interface, I cannot use an access modifier, so I cannot say that a particular method like AddGrade is public, or protected, or private, and that's because when someone has an object that is an instance of IGradeTracker, AddGrade has to be available, and there's no sense in hiding AddGrade or explicitly saying in the interface definition that it has to be public. Also these methods are implicitly virtual because they're part of an interface, so I do not need to the abstract keyword. And all I'm left with now are these three members, AddGrade, ComputeStatistics, and WriteGrades, and once again I do need to bring in the System.IO namespace for TextWriter. And now I have a choice, I can have GradeTracker implement IGradeTracker, I can have GradeBook implement IGradeTracker, the way you implement an interface is to use a colon, and list the interface name that you want here, so this GradeTracker is now an IGradeTracker, and it's providing those members that IGradeTracker demands, even if they are abstract members, so I'm satisfying the constraint to this interface. But of course what's great about implementing an interface, or inheriting from an interface, is I can also choose a base class that I want to inherit from. And if you do want to derive from a specific class in addition to implementing an interface, the class that you're inheriting from, that has to come first in this list, so I can say object, IGradeTracker, but really no one ever clutters up their code by explicitly saying they inherit from System.Object, that's always implicit, so I'm going to leave that piece off. Now back in Program.cs, I'm still going to have at least one error, because my interface doesn't say anything about this object having a property name. And the C# compiler says, you're passing me an IGradeTracker, but an object that implements this interface isn't guaranteed to have a name property, so it's giving me an error message. I will also need to go my IGradeTracker, and say that anything that implements this interface needs to have a Name property that you can read and write. And now I have an inheritance hierarchy where even my ThrowAwayGradeBook is an IGradeTracker, because ThrowAwayGradeBook inherits from a class, which inherits from a class, which implements this interface IGradeTracker. And now I should be able to build and run the program, and it's still behaving the same, but my program is working through an interface, and that again increases the flexibility of the software. Previously when I was working with the GradeTracker, I could get back any type of object, but it ultimately had to be something that derived from this abstract class GradeTracker. By working with an interface I can work with an even wider variety of objects, objects whose class definition doesn't even inherit from a GradeTracker or a GradeBook. The only guarantee that I need is that the object that's being created and worked with here implements this interface IGradeTracker.

Common Interfaces

Now that we know about interfaces, I wanted to tell you that .NET is full of many useful interface definitions. Because the interfaces are flexible, and because C# allows you to implement multiple interfaces on a type, you'll see interfaces in use to provide many low-level and essential features. For example, one interface we've already used is IDisposible. You might remember in the last module when we talked about exception handling, I showed you that we can have a using statement in C# to automatically close a file, even if there is an exception. The interface that the using statement looks for is IDisposible. Any object that implements IDisposible is an object that needs some help cleaning up. So it opens files, or database connections, or network connections, and in order to keep this system running in a good state, we want to make sure these resources are properly cleaned up, that's the purpose of IDisposible. IDisposible forces an object to have a dispose method that you can call directly, or indirectly through a using statement, and dispose will clean up resources. Another interface is IEnumerable. An object that implements this interface is an object that you can enumerate, that is you can use it as a collection in a foreach statement. There's also INotifyPropertyChanged. This is an interface you'll implement if you get into desktop XAML development, it requires you to raise an event when a property changes its value, much like we're doing in the GradeBook when we raise a NameChangedEvent. The INotifyPropertyChanged interface defines an event that a UI framework can listen to and know when to update the data on the screen. And then there are lots of little interfaces, interfaces like IComparable, IEquatable, these interfaces allow you to compare objects, or check to see if two objects are equal. And these types of interfaces are commonly used by collections, like the sorted list collection, because the sorted list can use methods defined by IComparable to compare objects and keep them in sorted order. Let's take a look. Inside of the WriteResults method let's say that instead of just writing the statistical results to the screen, I also want the ability to write out the individual grades. And ideally what I'd like to be able to do is a foreach statement. So I'd like to be able to say, foreach grade that is in the book, or the tracker, I'd like to be able to Console.WriteLine that grade. But currently the C# compiler is going to give me an error because it knows that book is not something that I can use the foreach statement against. Technically what's happening is an object that implements IGradeTracker is not guaranteed to have a public method GetEnumerator. At the lowest level that's all an object needs, just a method called GetEnumerator. But it's more common if you have a type that you explicitly want to make enumerable, you will say that that type inherits from the IEnumerable interface. So if I swing over to IGradeTracker, I can say that an IGradeTracker is something that is also IEnumerable, and IEnumerable is an interface that is defined in the System.Collections namespace, so I need to have a using statement for System.Collections. And now back in Program.cs, I will have no problem using a foreach statement with an IGradeTracker, because anything that isn't IGradeTracker is guaranteed to have GetEnumerator. But just because I have that interface listed on IGradeTracker doesn't mean I'm completely finished, because now what the C# complier will tell me if I do a build, is that I don't have any implementation of IEnumerable. So GradeTracker, our abstract base class, it has to implement IGradeTracker, it does not define the method GetEnumerator. And where does GetEnumerator come from? Well remember when I'm implementing an interface, I have to provide a definition for all of the members that that interface defines. So IGradeTracker defines four members, IEnumerable, if I go to the definition for that by pressing F12, it's a very simple interface that only defines one method that you have to have, it's a method called GetEnumerator, and GetEnumerator has to return an object that implements another interface, an IEnumerator. Something that implements that interface knows how to step through a collection one object at a time. And this is an extremely powerful interface definition, because you can hide all sorts of work behind an IEnumerable and an IEnumerator. So what I currently need to do is I need to guarantee the GradeTracker implements this interface, so I need to have a method, a public method, that returns an IEnumerator, and it's called GetEnumerator. But the problem is a GradeTracker will not know how to enumerate the grades that it holds. So first, IEnumerator, that's also an interface defined in the System.Collections namespace, I'm going to bring that namespace in. And the problem is now I do not how to implement this method inside of an abstract class GradeTracker. So I will also mark this member as abstract. I don't know how to implement GetEnumerator, because from the perspective of GradeTracker, I don't know where the grades are stored, are they in memory in a list? Are they in a database? Are they behind a web service call? I don't know, but I need to have this member here to satisfy the constraint that I am in IGradeTracker, I'll just mark this member as abstract, so whoever derives from this class will have to provide an implementation. Now before we do that, I just want to show that a GradeTracker could implement as many interfaces as it likes. So it could derive from a specific base class, like object, and then I could go on and say this also implements IGradeTracker, and IDisposible, and IClonable, I could list all sorts of interfaces, or course, I would have to have the members that these interfaces define, but I'm just trying to show you the syntax for how this would work, I can list interfaces, as many I need, and just separate them with commas. So let's go back to being just IGradeTracker, and of course if I do a Build now, my problem is pushed up one class. Now if go to the GradeBook, well I've said that GradeBook is a concrete type, it's not using the abstract keyword here, and therefore I need to provide an implementation for GetEnumerator. And fortunately, a list is something that's also IEnumerable, so all the collection classes in .NET, they implement the IEnumerable interface, and so I could provide an override for GetEnumerator, that simply calls into Grades, and returns Grades.GetEnumerator. That's the easiest way to implement this logic, and so now, inside of Program.cs, when I say foreach across an IGradeTracker, I don't know if I'll be getting those numbers back out of a list, or a database, or a web service call, again that's the great advantage to using interfaces, you can build very powerful abstractions, and hide all sorts of complexity behind simple polymorphism. If I run the program, I am now printing out the grades, as well as the statistics, as well as the letter grade. And hopefully that will demonstrate some of the flexibilities that interfaces can provide.

Where to Go Next

If you enjoyed this course you might enjoy a few of my other courses. I do suggest you watch these to get the complete C# fundamentals experience. First is my C# Generics course, at least watch a couple modules here because generics are an incredibly important feature of the C# language. We just didn't have time to cover generics in this course with the amount of detail they deserve, although we did use a generic type when we declared a list to store our grades. Another important set of features in the C# language are the LINQ features, where LINQ stands for Language Integrated Query. It sounds like something data related, but in truth, LINQ added a number of wonderful features to the C# language, features like extension methods and lambda expressions, and you don't have the full C# experience until you see these features. And finally there is my C# Fundamentals Part 2 course, which is C# programming paradigms, this course includes some additional material on not just object-oriented programming, but also functional programming, and what I call language-oriented programming with C#. I also offer some tips, tricks, and rules to live by as a C# developer.

Summary

In this module we looked at object-oriented programming in C#, we talked about encapsulation, inheritance, and polymorphism, and I showed you how to use abstract classes and interfaces. If all this feels a bit overwhelming, and you're not sure when to use an interface and when to use an abstract class, and when to use an inheritance, I'd say that's normal. I believe object-oriented programming takes years to master. I started my first object-oriented language in 1992 with C++, and with every year that goes by I think I know object-oriented programming just a little bit better. And that's it for C# Fundamentals Part 1. I hope you enjoyed the course, and continue on with the C# language.

Course author

	


