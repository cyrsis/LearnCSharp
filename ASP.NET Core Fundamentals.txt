
ASP.NET Core Fundamentals
by Scott Allen

This course will cover the fundamentals of what you need to know to start building your first ASP.NET Core application with the MVC framework.

Resume CourseBookmark
Table of contents
Description
Transcript
Exercise files
Discussion
Learning Check
Recommended
Course Overview

Course Overview

(Music playing) Hi, this is Scott Allen, and welcome to my course on ASP.NET Core. ASP.NET Core is the new web framework for Microsoft. It's been redesigned from the ground up to be fast, flexible, modern, and work across different platforms. Moving forward, ASP.NET Core is the framework you want to use with web development with .NET. In this course, we will build an application by starting from an empty project so you can see how all the pieces come together. We'll install middleware to build a processing pipeline and then move onto to work with the MVC framework. If you have any experience with MVC or web API over the last few years, you'll notice some familiar features. We still have models, views, and controllers, but I'll also show you what's new as we look at tag helpers, view components, and how dependency injection is a first class design pattern. You'll also see how to work with SQL Server using the new entity framework, implement forms authentication using the .NET identity framework, and install and use CSS and JavaScript libraries like Bootstrap and jQuery. By the end of the course, you'll have everything you need to start using ASP.NET Core and write an application that can create, edit, and view data from a database. I do expect that you are already familiar with the C# programming language, and have some knowledge of HTML and web programming in general. If not, we have lots of C# and HTML courses to choose from on Pluralsight, and after the course, look for new courses covering even more details of programming with ASP.NET Core.

Building Your First ASP.NET Core Application

Introduction

Hi, this is Scott, and this course will help you build your first application with ASP.NET Core. In this course, we'll be using Visual Studio and the new ASP.NET framework to build a web application that can display and edit restaurant information. I'm assuming you already know how to work with the C# language and can get around in Visual Studio. We'll spend our time together focusing on the new ASP.NET. In this first module, I'll show you the environment that I'm using, and we'll get our first project started.

Setup

For this course, I'm going to be programming with the C# language in Visual Studio 2015. If I come into the Help About window for Visual Studio, you can see I'm using the Community Edition, and I have Update 3 installed. The Community Edition is a free version of Visual Studio. If you come to the website www.visualstudio.com, there's a link here to download the Community Edition. I installed the Community Edition with all of the defaults. Once Visual Studio is installed, I can come to the website docs.asp.net. This will contain all of the latest information about ASP.NET Core. Over here on the left-hand side, if I go to the Getting Started link, I will find an additional link that will take me to the latest location where I can download the most recent version of .NET Core. I'm going to follow that link just to show you that you can run .NET Core on Windows, Linux, or on the Mac. Since I'm using Windows, I had the Windows option selected, and here to install the .NET Core SDK, I do need Visual Studio 2015 Update 3. I can follow that link to install the update, and then I can install .NET Core 1.0, and the Visual Studio 2015 Tooling Preview. So yeah, some of the tools that are installed in Visual Studio are in a preview mode, and they might be a little bit different if you're watching this course in the future. But once you have all of these bits installed, you'll be ready to start writing your first ASP.NET Core web application. And that's what we will start doing next.

A New Project

Inside of Visual Studio, I want to start a new application by going to File, New, Project, and under the Visual C# template, what I want to build is a web application, specifically I want to build an ASP.NET Core Web Application. We'll talk about the difference between .NET Core and .NET Framework a little bit later in the course, but right now I want to start this application. I'm going to call it OdeToFood, and I'm going to put this under a development folder that's on my local drive. So once I've selected ASP.NET Core Web application, and I've given this application a name, I'll press the OK button. This will bring me to a dialog that allows me to select a starting template for this ASP.NET application. I can create a full web application or an application that's a little more oriented towards providing just an HTTP-based API, and then there's also the Empty template. We're going to start with the empty template, so we can build this application from scratch and understand all of the pieces involved. I'm going to make sure that host in the cloud is turned off, and then press OK. Visual Studio is going to go out and create this project and slowly populate the Solution Explorer window. And once we have the solution created, Visual Studio will go out and download any additional packages, NuGet packages that are needed, we're going to be looking at NuGet as we work throughout this course. But once the message restoring packages goes away, which it just did, we can try out the application. I can go to the Debug menu and tell this application to Start Without Debugging. I can also do that using the Ctrl+F5 hotkey. This is going to build the application, then launch my web browser, and the only thing that a new empty ASP.NET Core project can do is display the text Hello World! We will dig into this output a bit in this module, and also in the next module, but for right now I want to show you that this project is running on localhost port 51791. The ports are randomly selected, so you might receive a different port number and that's okay. And if I come into Windows and look here in the system tray area, I can see that IIS Express is running. That is the default host for a new ASP.NET Core website that you create with Visual Studio. And here I can see my site running there, OdeToFood. So if you've done any previous programming with ASP.NET, what you've seen so far isn't incredibly new. With previous versions of ASP.NET, you could create a project using Visual Studio, you could run that project, you could see the application running under IIS Express, so all of these things are familiar. What's going to be different, and what I want to take some time to explain in this first module, is how this project appears on the file system and inside of the Solution Explorer window. Let's take a look at that next.

The Project Layout

In the Solution Explorer window of Visual Studio, let's right-click the top level solution node and select Open Folder in File Explorer. What I want to show you is the default file system layout for an ASP.NET Core application. I can see in this root directory there are two files. One is the OdeToFood solution file, the file with the .sln extension. Visual Studio has used this extension for years by default, and if I double-click this file, I can open up the application in Visual Studio and work on it. There is also a global.json file. Let's look at this file in the IDE global.json. I don't want to go into all the details of the settings that are here, but real quickly this version identifier is the version of the tools that Visual Studio will use when it opens this application. So again, we're using a preview of the tooling, and that's just for the tools. What's more interesting is the project setting. The project setting tells ASP.NET where to look for my source code and what folders contain my projects. There are two folders listed here, src for source, and a test folder. Unless my project and my source code are in one of these two folders, the code will not be available to build. I can change these settings if I want, but I'm going to leave the default. Now if I come back to the Windows Explorer view, I can see that I do have an src folder. I don't have a test folder yet, that's okay. When I begin write unit tests for this application, I can place my test projects into that test folder, but I do have an src folder, a source code folder, and inside of the source folder, there is a folder for my project OdeToFood. And if I come into this folder, this folder is the source code for my application OdeToFood. If I compare the folder structure that I see inside of Windows Explorer to the folder structure that I see in the Solution Explorer, I should be able to see that they are identical. That's because in this version of ASP.NET, the file system determines what is in my project. If I add a new file to the disk, the file will automatically be added to the project. If I delete a file, that file is removed from the project. Watch what happens when I delete the Project_Readme file from the file system over into the Solution Explorer window, that file disappears from the project. This is a little bit different than previous from previous versions of ASP.NET where a project file, a file with a .cs project extension, that file contained a manifest of everything that was in the project. Here the file system is the project system, and that's important to understand in this version of ASP.NET. It's also good to know that ASP.NET will compile and build my application when a file changes or a new file appears or a file disappears. As an example, let's open up Startup.cs. I'm going to say that I want to open this file with Notepad. We'll be talking about this file in more detail throughout the course. For right now I want to scroll down to the line that has the text Hello World, because it's actually this line of code that controls the output in the browser. But right now I'm just going to add a few more exclamation points, save this file into Notepad, and then come back to the web browser that is showing the application and simply do a refresh. So I have not gone into Visual Studio. I have edited the file outside of Visual Studio, and I simply refresh the browser and I see new results. My changes are reflected in the browser without me touching Visual Studio, and that's because ASP.NET will monitor the file system and automatically recompile the application when a file changes. I do not need to explicitly build the application in Visual Studio. In fact, I could use a completely different editor if I wanted to. I'd just use Notepad, but I might want to use something a little more robust like Visual Studio Code. All I need to do with Visual Studio is to get the web server started by running without the debugger. So if you just try this experiment, and the web browser said that I couldn't connect to the web server, perhaps that is because you haven't gone into Visual Studio and started without debugging, that will get the web server up and running and keep it running. Once I do that, all I need to do is edit my files, save them, and refresh the browser to see the changes. That's a nice new workflow for building web applications with a compiled language like C#. So now that we know a little bit about the directory structure and the compilation model, let's take a closer look at the files that are here in this project.

The project.json File

Let's take a high-level tour of the files in our web application. First I want to discuss this project.json file. Again, another file like global.json that uses JavaScript object notation to store configuraton information. And it is this file that is really the heart of a .NET application; without this file I would not have an ASP.NET Core project here. I'm going to talk about in this introduction only the two most important features of this file. First, there is the dependencies section. If my application is going to do any useful work, I'm going to need libraries and frameworks to do that work. I'm talking about work like querying a database or rendering complicated HTML. With this version of ASP.NET, my dependencies are all managed by the NuGet Package Manager. NuGet has been around the .NET space for awhile, but NuGet is now the primary way to manage all my dependencies in all the libraries that I need. All of the top-level dependencies and NuGet packages that I need will be listed inside of this project.json file. You can see I have just a few. But part of the reason that my application can only say Hello World right now is because I don't have many features included in the application by way of NuGet packages. When I want to add a new dependency like the Microsoft.AspNetCore.Mvc package in the MVC framework, I can come into project.json, you can see that I get some IntelliSense here. I even have IntelliSense that will help me select a version of the MVC framework that I want to use. I can just type this NuGet Package name and version number into project.json and save the file, and Visual Studio will help me by going out and adding that package to my application automatically downloading it if need be. I'm not going to do that right now, we're going to add the MVC framework as a dependency later in the course, but I do want to show you that in addition to editing project.json directly to add a dependency, I can still right-click on my project and say Manage NuGet Packages. In the user interface that comes up, I can see my installed packages, these will be the same packages that are listed in project.json. But I can also browse for new packages, like the aspnetcore.mvc package. I could also select this package in the UI and click Install. The fact that I have this package installed will be recorded into project.json, but again, I'm not going to do that just yet, we will do that later in the course. Another place where I can see the dependencies that my application uses is under the references node. If I click to expand this, I'm going to see a node here that says .NETCoreApp, version 1, we'll talk about that in just a second, but then here are the top-level dependencies that my application uses. For example, the Microsoft.AspNetCore.Server.IISIntegration package. This is a package that lets me take advantage of some specific IIS features in my ASP.NET application. IIS is the web server in Windows, but ASP.NET Core is not tied to IIS. I don't need to use IIS to host and run my application, I can opt into using IIS, but IIS is the default host when I create a project with templates in Visual Studio like we have done. I can further expand one of these NuGet packages to see the NuGet packages that it depends on. So the IIS integration package depends on things like Microsoft.AspNetCore.Http, which in turn will depend on some additional NuGet packages. Now what is this top node, .NetCoreApp Version 1? To understand this, we have to come over to the other important of project.json and look at the framework section. This section describes which .NET framework my application will use. In this file, because we selected a .NET Core application template from the File New Project dialog, this says that my application uses netcoreapp1.0. Netcoreapp1.0 is what we call a target framework moniker, where moniker is a fancy word for name. And the name netcoreapp1.0 means we want to target the .NET Core framework. Other target framework monikers that you might see here include net45 or net46. Those two monikers are monikers for the traditional full .NET framework, the .NET framework version 4.5 or version 4.6. These are the frameworks that we've used with Visual Studio and Windows for years now, so frameworks like Windows presentation foundation and Windows communication foundation, they are in Net 4.6, so it's a huge framework, and it's a framework that only works on the Windows operating system. We can use net45 and net46 when we build an ASP.NET Core application, it can run on those frameworks, but we will stick with just netcoreapp1.0. We will use dotnetcore. Dotnetcore is a brand-new framework. It is a cross-platform framework, so it can run on various platforms, not just Windows, but also Mac OS and Linux. The .NET Core framework has fewer featuers than the full .NET 46 framework, but it does have all the features that we will need for ASP.NET development in this course. One reason you might want to go back or switch to net 46 is if you need features that only the full .NET framework provides. Moving forward, there should be fewer and fewer features like that, so I would expect most ASP.NET applications to only target .NET Core in a few years. Let's also talk about some of the other files and folders that are in this project, as well as some of the files that are not in this project. A folder that you will see here that is new in this version of ASP.NET is a folder called wwwroot. This is a folder that I will call the webroot, because from a hosting perspective, this is the root of the website. In other words, if I have files that I want to serve over HTTP, static files that are on the file system like image files, style sheets, and JavaScript files, by default I need to place these files into this webroot folder to make them available. We'll come back to the webroot folder in the next module and see how to serve up a simple HTML file. Another file in this project is the Startup.cs file. Now, if you've worked with previous versions of ASP.NET, you probably expect to see a global.asax file somewhere in this project. That was one place where I could write code to execute during the startup of an ASP.NET application. That file is gone in ASP.NET Core. Instead, a lot of the configuration and startup code are loaded from this file, Startup.cs. Inside of this file there is a class, Startup. This is a class that ASP.NET will look for by convention, and it is inside of here where I will configure my application and even configure my configuration sources. We'll be looking at that in more detail in the next module. But I what I want to talk about now just to get started is that first there's two methods inside of Startup. There is ConfigureServices and there is Configure. The Configure method that is at the bottom of the class. This is where I will build my HTTP processing pipeline. This defines how my application will respond to incoming requests. Right now my application can only say Hello World to every request. It doesn't matter what that request is for. If I want the application to behave differently, I'm going to need to change this pipeline and add additional code in this Configure method. So if I want to serve up static files like an index.html file, I will need to add some code to this Configure method and we will look at those exact steps in the next module, I promise. I also have this ConfigureServices method. This is a place where I can configure components for my application. To be more specific, Configure is a place to setup the inversion of control container for my application. If you aren't familiar with inversion of control and dependency injection in those terms, we will cover them briefly in this course. There are other Pluralsight courses, especially in the design patterns library that you can go and view and see much more detail on these topics. For now I just want to tell you that dependency injection is a technique that I can use to get a lot of flexibility and extensibility out of my software. ASP.NET uses dependency injection everywhere and that gives us a lot of flexibility on how an application will behave. With dependency injection, I can have my code ask for dependencies instead of instantiating dependencies directly and being tied to a specific component. That sounds very abstract, so let's get an understanding of this by making some changes to how this application behaves. Right now we have a hard-coded string for every response, Hello World! So instead of hard-coding the string, I want to load this string from some component that knows the text of the greeting that I want to display. This other component might load that greeting text from a database or call a web service or read a JSON file. It doesn't matter where exactly this greeting comes from, I just want to set up a scenario so that I don't have to hard-code this string. So what I'm about to do will be overkill for this simple example, but it will help us understand how to configure any ASP.NET application for real work and give us something useful to build on moving forward.

Adding a Configuration Source

Currently my application still displays Hello World when I run it, but I want to build something that is more flexible. The first step in making this application more flexible is to move this hard-coded string Hello World into a configuration file where I can change this greeting whenever I want without changing the source code. Now in previous versions of ASP.NET, we always used web.config for application configuration. And although there is a web.config file in my project, ASP.NET no longer uses the web.config file for configuration. The only purpose of this web.config file in this project is to give instructions to IIS about what it should do when it receives an HTTP request. And essentially what this configuration file will do is tell IIS to hand off everything that it receives over to an HTTP handler known as ASP.NET Core. That ultimately sends every request into my application, so the important part to remember here is that web.config is no longer a viable configuration source for ASP.NET. ASP.NET will know nothing about that file by default. So I'm going to add a new file and configure my application to use this new configuration source. So, right-click on the project, I want to add a new item. Inside of this dialog I am going to search for JSON. And I could pick the JSON file option and start with a plain empty JSON file, but I'm going to pick the ASP.NET configuration file. This is still just a JSON File, but when I use this template, the file will not be empty, instead the file will have a database connection string in the file. We're not going to use that yet, but I'm going to leave it in here. We'll use it later in the course. What I want to do is create a new property on the JSON object, a Greeting property, and have it set to the text A configuration hello! So the goal is for my ASP.NET Core application to open up this appsettings.json file and retrieve this configuration information so I can use it at runtime. And the first thing we'll do is read the greeting and use this greeting instead of the hard-coded greeting. In order to do this, I need to make a few changes to Startup.cs and also to the dependencies of my application. What I'm going to do in startup is add another method, I'll use a code snippet here, ctor in Visual Studio, and then hit Tab twice, that will expand the code snippet into a constructor. And what I want to do is execute a little bit of code before ConfigureServices and Configure execute. What I want to do inside of the constructor is tell ASP.NET about my configuration file appsettings.json, so I can read it in. And the way I can do that is by using and creating an instance of a class called ConfigurationBuilder. Now this class is in a namespace that we are not using by default, but if I put the cursor on ConfigurationBuilder, or the red squiggly up here and press Ctrl+Period Visual Studio can find the namespace for this class and automatically add it when I select this top option here, so that will add a using statement for Microsoft.Extensions.Configuration, and I can now use a ConfigurationBuilder. Now when I went to use the ConfigurationBuilder to read files that are in my web project, then I need to tell the ConfigurationBuilder about my base path, that is, where is it going to go looking for files by default. And in order to do even the simple task, I'm going to need to go out to my project.json file and bring in a new dependency. The dependency that I want to bring in is the Microsoft.Extensions.Configuration.FileExtensions package. I'm going to bring in version 1 of this package. When I save project.json, ASP.NET and Visual Studio will go out and bring that package down from a NuGet server, put it onto my file system, and I can now come over to Startup.cs, and I should be able to tell the ConfigurationBuilder, which has a bit of a fluent chaining API to set the base path, and now I need to tell it where my project is. Well, I certainly don't want to hard-code anything here, and fortunately for me, ASP.NET when it instantiates the Startup class, it can pass in an object that implements the IHostingEnvironment interface. And one of the things that I can do with a class that implements IHostingEnvironment is ask for the ContentRootPath. So wherever my project is on the file system or on the server's file system, this hosting environment will be able to tell me where that is, and I can tell the ConfigurationBuilder to set this base path. Now I want to tell the ConfigurationBuilder about my appsettings.json file. This is also going to require another NuGet package, but I want to show you a little trick in Visual Studio. The API that I want to use I know is AddJsonFile. I invoke that method, say that I want to use a json file call appsettings.json, and ASP.NET will be able to read that file and read the settings that are inside. However, currently the C# compiler doesn't know anything about AddJsonFile, and that's because I'm missing a dependency. If I press Ctrl+period, I want to show you that Visual Studio is smart enough to say, you're trying to use a method AddJsonFile, which is an extension method that is defined in a package that you currently don't reference. Microsoft.Extensions.Configuration.Json. I am going to select that option, and what that will do is add that dependency to project.json for me. You can see it added this line here, and we were just restoring packages in Visual Studio, and now this method is available for me to use. Now I can continue to add configuration sources to this configuration builder, this is one of the neat things about ASP.NET Core. I can add environment variables as a configuration source, I can add a second json file as a second configuration source. Remember web.config is gone, but we have a very flexible configuration system now. And when I finish adding all of these configuration sources, ASP.NET will have the ability to look them through all when I ask for some configuration parameter. How do I ask for the configuration parameter? Well, I can tell this builder to go out and build a configuration for me that will return an object that implements IConfiguration and I should probably save that object off so I have access to it in the rest of my Startup class. So let me define a property with the prop code snippet, type prop and press Tab twice. I want a property that is of type IConfiguration, and we will call it Configuration. Now when I build the configuration, I can say Configuration = builder.Build. And now what I'm going to do inside of configure, instead of this hard-coded string, let's go out and see if we can read that greeting from appsettings.json. I can do that by going to the configuration property that I saved, and then I can index into that object to read the different properties that are here. So I can index in to get connection strings and index in with a string to get the greeting. That's the one that I need, so inside of double quotes let me paste Greeting in here. That will pull the message out for me. And now let's replace Hello World with the message, save all of my files, come back to the browser and refresh, and I now have a message in the browser, a configurable hello, so I change my configuration file to change that message without changing any code. And again, the way we did that was to use a ConfigurationBuilder. Since I am using files on the file system, I have to tell the ConfigurationBuilder about my base path. I can get that from the IHostingEnvironment that's passed in. Then I add my json file, appsettings.json, build my configuration, and I can retrieve any settings that I want. To get that done, we also needed two new packages, the Microsoft.Extensions.Configuration.Json, and the Microsoft.Extensions.Configuration.FileExtensions package. Next up I want to take another step, so that I am actually retrieving this greeting from a component instead of going to the configuration source directly. To do that, I'm going to need to set up some services for my application.

Creating a Greeting Service

Ultimately in this application, I do not want the code inside of the Configure method to access the configuration source directly. I want this method to go through some application service or application component, some object that will retrieve the greeting information. That object might go to a database or a JSON file. This method isn't going to care. In order to get this to happen, let's go ahead and create the service that I am envisioning. So I'm going to right-click on the project, say that I want to add a class. This time I'm going to add a class called Greeter, so Greeter.cs. And before I even start writing code inside of the class, I'm going to write an interface that will describe the capabilities of every greeter, because ultimately I want my configure method to use a component that is described by an interface, so it's not tied to some concrete implementation of a greeter. The Configure method won't know if this is a greeter that uses a JSON file or it calls an XML web service. Again, the method isn't going to care. All it cares about is that every greeter will have the ability to get a greeting. That is the one method that I will put on this interface, so my class will implement IGreeter, and I will use Ctrl+period in Visual Studio and select implement interface to have that method placed into my class as a public method. And just to see if we can get this working, let's return a simple string, Hello from the Greeter. Before we're finished, we will use the configuration source to get this greeting, but I just want to demonstrate a few things about ASP.NET before we start using the configuration source. So over in Startup.cs, here's what I envision happening. In addition to this method taking an IApplicationBuilder and an IHostingEnvironment, and an ILoggerFactory, I also want this method to take an IGreeter. Let's call that greeter. And down here instead of going to my configuration source, I'm going to get the greeting from this greeter and that is the message that I will write into every HTTP response. At this point, if I save all of my files and come back to the browser and refresh, what I will see is not my new message, but an error. No service for type IGreeter has been registered. This is ASP.NET's way of saying I can see that your Configure method needs an IGreeter, but I don't know what to pass as a parameter there. And you might be saying, well, where do these other things come from, ILoggerFactory, IHostingEnvironment, IApplicationBuilder, ASP.NET must know about those, but I don't see anything registered here. I haven't configured any of those into the application. While there are some built-in services that ASP.NET will provide by default, let me put a breakpoint here at the start of the ConfigureServices method, and I'm going to ruin this application with the debugger by pressing F5. And once I arrive on this breakpoint, I can take a look at the Autos window, here's my services parameter to ConfigureServices. I can see there are already 16 services available. This IServiceCollection object, it already contains 16 services, and those services include these things that I see in the results view. So things like the ILoggerFactory and the IHostingEnvironment, the configure depends on. I get all of those for free, ASP.NET registers those before my application even starts running, or at least the code inside of my startup project. Where does the hosting environment come from in my constructor? That's also a service that ASP.NET has created and registered. It's available here in the services collection. So once I have a service that implements IGreeter registered in the services collection, ASP.NET will also be able to pass that along to any component or any method that needs it. Or at least the ones that are controlled by ASP.NET and invoked by ASP.NET. Let's stop debugging and see if we can get our Greeter class registered. So there is an API available on the IServiceCollection. It allows me to add services with different lifetimes. So, for example, AddTransient is a method I can call to add a service to the service collection with a transient lifetime. Any time that service is required by a method or component, that service will be re-instantiated. So everybody sees a different instance of that service. AddSingleton allows me to add a single instance of a service that is used throughout the application, everyone sees the same instance. And AddScoped is an API that allows me to add a service instance that will be scoped to an HTTP request. So all of the components inside of a single request will see the same instance, but across two different HTTP requests, there will be two different instances. For the Greeter class it's very easy for me to use AddSingleton. I don't need this class to be scoped or a transient service. And you can see, AddSingleton has nine different overloads. So there is a very flexible API for registering services with ASP.NET. I'm going to use a version that relies entirely on generic type parameters. I'm going to tell ASP.NET whenever you see something that needs an IGreeter, then this is the concrete class that you need to instantiate and pass in as the IGreeter. Now throughout the course I'll point out other places where we can have services injected automatically for us by ASP.NET, and the benefit here is that again inside of the Configure method, I don't need to know about the concrete type that's being used. All throughout my application I can just ask ASP.NET for an IGreeter, and I have the flexibility for using different types of greeters, ones that talk to a database or a JSON file, the rest of the application doesn't care. The only place that knows the ultimate type of greeter is this line of code inside of ConfigureServices. And now if I save all my files and use Ctrl+F5 to relaunch the application, relaunch the web server host, now I can see that we have successfully avoided all the errors, and I am now able to see that hard-coded greeting that's in the Greeter class, Hello from the Greeter! Let's go back out and make that service use a configuration source. So over in Greeter.cs, one easy way to do this is to define a constructor for this class, again, I can do that with ctor, and ultimately I want someone to pass in the IConfiguration that this class needs to use. We will call that configuration. IConfiguration, I need to bring in the namespace for that, I can do that with Ctrl+Period. It is in the Microsoft.Extensions.Configuration namespace that's been added to the top of the file, and I want to go to Configuration, and I believe we called the setting Greeting, yes. I want to read this value in, and let's save it into a private field called Greeting. I can generate this private field using Visual Studio and Ctrl+Period, and ti will generate a private field of type string, which is perfect, and now inside of GetGreeting, I simply need to replace the string literal with the greeting that I read from the IConfiguration source. So this class has no idea where the configuration comes from. Someone needs to pass in an object that implements IConfiguration, and if I run the application right now, we would get an error message very much like the previous message that we saw. ASP.NET does not know of any services that implement IConfiguration. That is something that I built in my Startup, and it's the object that I stored in this property. So I'm going to register another service as a singleton, this time using a slightly different API. Since I already have an instance of an object available in this property, I'm just going to pass that object reference into AddSingleton. ASP.NET is smart enough to see the type of this is IConfiguration, and so anyone that needs an object that implement IConfiguration, it will use this object. And now when ASP.NET invokes the Configure methods, it sees that this method needs an IGreeter, it sees that the greeter needs an IConfiguration, and the great thing about inversion of control container or a service provider as ASP.NET calls it, is that a service provider knows how to stitch all these objects together, it knows how to build an object graph. It can follow the dependency chain and just put everything together that I need. I should be able to save all my files at this point, come back to the browser and refresh, and we are back to using that message that is stored in the appsettings.json file. Now we have that file setup as a configuration source here in our Startup class. Again, we did that by adding a few NuGet packages. You might be wondering why we have to add two new NuGet packages just read a json file, but that's one of the philosophies of ASP.NET Core, it wants to be as lean as possible. You're only going to pay for those features that you use. And now we have this configuration source set up, it's being consumed by a service, a configure method then uses that service to produce a greeting message and write it out on every response. Throughout this rest of this course, we're going to be adding additional services and additional configuration information. So this quick introduction to configuration should help you remember how some of these little pieces fit together.

Summary

In this first module on the new ASP.NET Core framework, we have created a new application. We started with the empty template and we'll be adding just the pieces that we need. The empty template is truly empty. The only thing the application can do is say Hello World. We will need to add additional NuGet packages throughout the course to get additional features. In this first module, we used the ConfigurationBuilder class to add an appsettings.json file, and consumed the settings that are inside of that file. I also showed you how to work with a container, aka the service provider in ASP.NET. What we did was register a couple services so that those services are available to inject into other methods in other components that are inside of the application. That knowledge will be useful as we progress throughout the course. In the next module, we're going to still be focusing on the Startup.cs file, but this time talking about the middleware that is set up for the HTTP processing pipeline.

Startup and Middleware

Introduction

Hi this is Scott, and in this module we're going to move forward with our application and set up our middleware. Middleware in ASP.NET controls how our application responds to HTTP requests. It can also control how an application looks when there is an error, and it's a key piece in how we authenticate and authorize a user to perform specific actions. We will learn a little bit about middleware in this module and how to set up the middleware during application startup, and by the end of this module, we will have a processing pipeline that allows us to use ASP.NET MVC.

How Middleware Works

Let's get an understanding of what middleware is briefly so that we can understand why we need to set up middleware for our application. When an HTTP request arrives at our server, and let's pretend we have an HTTP POST request to the URL /reviews, in this example we need software that will respond to this request. In ASP.NET, it is ultimately middleware components that will determine how to process this request. Each piece of middleware in ASP.NET is an object, and each piece has a very specific, very focused, and very limited role. So ultimately we need many pieces of middleware for an application to behave appropriately. So let's imagine that we want to log information about every request to our application. In that case, the first piece of middleware that we might install into the application is a logging component. This logger can see everything about the incoming request, the path, the query string, the headers, any cookies and access tokens, and the logger can record information about the request. It can even change information about the request if it wanted to, or reject the request and just stop processing right away. But chances are a logger is simply going to record some information and then pass along this request to the next piece of middleware. So middleware is a series of components that are all in this processing pipeline. And let's say that the next piece of middleware that we've installed into the application is an authorizer. An authorizer might be looking for specific cookie or access tokens in the HTTP headers. If the authorizer finds a token, it allows the request to proceed; if not, perhaps the authorizer itself will respond to the request with an HTTP error code or redirect code to send the user to the login page. But otherwise, the authorizer will pass the request to the next piece of middleware. Perhaps this piece of middleware is a router. A router looks at the URL and determines where you want to go next. Do you want to call some method on a class? And that method, it might return JSON data or XML data or an HTML page, the router might look all over the application for something to respond. And if the router doesn't find anything to respond, the router itself might return a 404 not found error, or if it found the right component and that component produces HTML, well now the pipeline starts to reverse itself. Because the router can return control to the authorizer, and the authorizer can return control to the logger, and when the logger at this point sees that the rest of the pipeline has finished, it might record that fact and log the total amount of time taken to process this particular request, and then it will allow the request to flow out over the server and over the network to the client who is waiting for some result. This is in essence what middleware is all about in ASP.NET. We need to set up a series of components to make our application behave properly and respond to requests. We will need middleware to handle errors. We will need middleware to serve static files from the file system. And we will need middleware to send HTTP requests to the MVC framework, which will ultimately allow us to build this application later that will show restaurant information to the users. I'm not going to go into excruciating details on middleware in this course, I just want to show you enough of the basics to move forward with an ASP.NET MVC application.

Using IApplicationBuilder

The way we set up middleware in an ASP.NET Core application is to modify the code inside of the Configure method for our Startup class. We were working inside of this method in the last module when we changed the greeting from Hello World to a greeting that we ran from the configuration file via a service. It is inside of this Configure method where we will invoke extension methods in the IApplicationBuilder interface. That is how we add middleware. There are already two pieces of middleware installed in our application. One is a DeveloperExceptionPage. This is a piece of middleware that is only installed when we're in a development mode. We'll talk about development versus production as we move throughout the course. When we're running in Visual Studio by default after we have created a new project, we will be in development mode. This piece of middleware will catch any unhandled exceptions that happen during the processing of a request and show a page that is useful for developers to debug whatever problem happened. That's because this page will show things like a stack trace. The other piece of middleware is registered with app.Run. This is a piece of middleware that is always present, and it always responds to HTTP request with a greeting. Let's go into Visual Studio and experiment more with adding some middleware and changing the existing middleware around. My goal in this clip is to give you an idea of how to install and work with middleware. I'll do that by opening the Startup.cs file, because it is here where I have my Startup class and the Configure method. The Configure method is where I configure the HTTP request pipeline. Every HTTP request that arrives at my application will pass through the middleware that I have configured into the application inside of this method. I add pieces of middleware into the application by programming against this object that implements IApplicationBuilder, and most pieces of middleware are available by invoking extension methods that start with the word use, use. To demonstrate that, I actually want to simplify things here for just a second. I want to go into project.json and I'm going to temporarily remove this dependency on Microsoft.AspNetCore.Diagnostics. I'm going to cut it out of this file. I will be adding it back in later. But if I come to Startup.cs, once Visual Studio catches up, I should see an error on this invocation of UseDeveloperExceptionPage, and there it shows up, the little red squiggly line. This method is no longer available, and that's because most piece of middleware are built into a NuGet package. And when you see a piece of middleware that you want to use, whether it's ASP.NET MVC middleware, or perhaps middleware that gives you cookie-based authentication, or token-based authorization, the first thing you'll need to do is install a new package. And that package will include an extension method for IApplicationBuilder to make the middleware available and easy to install. I'm going to comment out this line of code for right now, and just show you if I go into the IntelliSense window and look for methods that start with the word use, there's not many here. And certainly UseDeveloperExceptionPage is not here. Now one method that is here is the Run method, but run isn't one of those methods that you will use a lot in production applications. Run is really useful for demos and for debugging, but run allows me to install a very low-level piece of middleware. But I do want to point out a couple features of this Run middleware, because it does demonstrate some of the capabilities of every piece of middleware. The most important thing here is that I receive access to an HTTP context, so it is this method that is defined with a lambda expression that will be invoked for every single HTTP request that arrives. And ASP.NET will set up an HTTP context object for every request and pass it into this piece of middleware. This context object gives me access to all sorts of information about the request and the response, so for example, I can go to the request and I can look at the body of the request, I can see the ContentType, I can inspect any cookies, I can inspect any other headers, and there's an entire API and set of properties here that will allow me to see the path of the URL, everything I would want to know about the request. There's also a response object, and one of the things that I can do with a response is write into the body of the response, I can do that with the WriteAsync method. So you'll see many Async methods in this new version of ASP.NET, and Async methods are easy to use when you use async await in C#. So now that we've seen that there are not very many pieces of middleware that I can use out of the box, let's go back into project.json. I'm going to hit Ctrl+Z to bring back Microsoft.AspNetCore.Diagnostics. Save project.json. Visual Studio is going to take a moment to refresh, but now that Visual Studio has caught up, if I type app.Use, I can see there's more middleware available for me to use. There is something called an exception handler, there is UseStaticCodePages, there's also UseWelcomePage. Let's try this one out. I'm going to install this piece of middleware here before the piece of middleware that is installed with app.Run, save Startup.cs, come back to my browser, and refresh. And what this particular piece of middleware will do is show a very simple welcome page. It might not be something that you use in a production application, but it can be something that you want to use when you are debugging or if you just want to see if an ASP.NET Core application can come up on the server correctly and everything is configured. So that is a new piece of middleware that I've added to the application by installing a NuGet package, and then invoking a Use method to install the middleware into the HTTP request pipeline. Now UseWelcomePage, when I invoke the method without any parameters, becomes what I would call a terminal piece of middleware. That is, when a request reaches this piece of middleware, it will not continue into any other pieces of middleware, because this middleware will never call into the next thing. Just like the middleware that I install with app.Run, this doesn't know about any additional middleware that's in the pipeline, it never calls into the next thing. If execution reaches this method, this method will always write to the response and will never continue to any additional piece of middleware. So the order in which you install middleware can be important. If I were to use the welcome page down here as the last piece of middleware, we would never see that page. We would only see the greeting, because this middleware doesn't call into the next piece of middleware. However, I can use the welcome page up here before a piece of middleware that's installed with app.Run, and I can configure this middleware to only respond to a certain path. I can see on this method there are four different overloads. I'm going to pick an overload where I just pass in a string like /welcome, and that's going to be the path that the welcome page middleware responds to. In other words, back out here in the browser if I refresh now, a request to the root of the website will execute my run middleware and display my configurable greeting. However, if I go to /welcome, that particular request was handled by UseWelcomePage. It saw a request that matched the path string that I configured it with, so it provided the response that we see in the browser, and then never called into the next piece of middleware. But if I go back to the root of the website, this is a request that passes through that WelcomePage middleware, the WelcomePage middleware says, oh, I don't handle this request, hands things off to the next piece of middleware in the pipeline, and that allows my run middleware to show the greeting. Most middleware will also allow you to configure an options object. For the WelcomePage middleware, there is a WelcomePageOptions object that I can instantiate and set properties on. Again, this is true of many pieces of middleware. They will have an Options class defined that uses the name of the middleware like WelcomePage, and then has the word Options at the end. Now it just so happens that the only property on the WelcomePageOptions is a path property that allows me to specify the path in this way, and so this particular installation will behave just like we had before. It's only going to respond when a request comes in for /welcome. It won't respond to a request that comes in for the root of the website. Now remember every piece of middleware, it gets to see not only the incoming request, but if it passes that request along to the next piece of middleware, eventually that piece of middleware will see an outgoing response. And there are some pieces of middleware that only care about the response, UseDeveloperExceptionPage is an example. It's looking for unhandled exceptions that occurred somewhere else down the line. We'll be looking at that in more detail in the next clip. But the idea here was to get accustomed to the workflow for installing middleware. Typically when you want a new piece of middleware, it will be in a NuGet package somewhere, so you'll need to go and add that dependency. Once you've added that dependency, most middleware will provide an extension method against IApplicationBuilder, so that after the package is installed, you can say app.Use and you'll see some new extension method that will allow you to install that middleware into the pipeline. And most middleware is configurable, it's configurable by creating an options object and passing it into that extension method. When you're dealing with complex things like a cookie authentication framework, or ASP.NET MVC, it's going to need a piece of middleware. Those pieces of middleware will have an options object that will allow you to configure the behavior of that particular piece of middleware. We'll see that as we move through the course. Now let's go into a little more detail on handling errors and showing exception details.

Showing Exception Details

Now let's take a closer look at the middleware that is installed with the UseDeveloperExceptionPage method. To demonstrate what this middleware will do, let me temporarily comment out that line of code, and then come into the run middleware and what I want to do here is just throw a new exception. So anytime we hit this piece of middleware, I'm just going to throw an exception that says something went wrong. And let me save this file, come out to the browser, and let's do a refresh. And the response that I get from the web server is a completely blank page. There's no indication of an error. Let me open up the Chrome Developer Tools on Windows with the F12 key. And if I come over into the Console listing, I can see that we failed to load a resource: the server responded with a status code of 500. So my ASP.NET Core application did respond with a status code of 500, there was an internal server error. This actually happened twice, once on a request to the root of the website, and once on a request for the favorite icon, because Chrome will send off a request for the favorite icon by default, and that request will go through the same middleware that we have installed for everything else, it's just another HTTP request. So the web server is creating an error, but there is no indication to the user that there was an error. Now let's go back into the startup file, and I'm going to uncomment this line of code and install the user developer exception page. Most pieces of middleware are there to look at an incoming request, and to do some processing based on that request, perhaps inspect some headers, inspect some cookies, determine some authorization rules, perhaps render HTML, or perhaps just print out a message like Hello World. The UseDeveloperExceptionPage middleware is a little bit different. What this middleware is doing is simply letting the request flow through to the following pieces of middleware and waiting for that processing pipeline to return for the response to start coming back out of the pipeline. And if this piece of middleware detects that there was an unhandled exception somewhere further down the processing pipeline, what it will do is build a UI that developers will like, because it will include lots of information that we can use for debugging. So when my application has an unhandled error, the developer exception page will catch that error and the UI that shows things like the raw exception details, that include a full stack trace, and I can also see right here that the exception occurred in Startup.cs line 59, that gives me a lot of good information to go into the source code and start working on this. I can also see information about the query string in this request, the cookies, other headers that were sent along, but this is the whole idea of installing the DeveloperExceptionPage middleware. In an empty ASP.NET application, really all we started with was this piece of middleware and the middleware that wrote out Hello World. I'm going to for right now get rid of this exception, and I do want to point out that the placement of UseDeveloperExceptionPage, again, this is important, if I took this piece of middleware and installed it down here after the exception would occur, the DeveloperExceptionPage would never have a chance to execute, would never have a chance to display that UI, and it would never see the exception. So this piece of middleware is something you typically want to have registered first with the ApplicationBuilder interface. Now the page that's being displayed is, of course, a page that I really only want to show to a developer. I only want to show it in a development environment. If this application is deployed to a production and a real user is looking at this application, I probably don't want to show that exact error page. Let's talk about that next.

Middleware to Match The Environment

I am going to undo a change that I just made at the end of the last clip using Ctrl+Z, and that is to reinstate this line of code that will throw a new exception. I want to keep the exceptions happening, and now we can talk about this IsDevelopment flag. We'll remember that the Configure is injectable, so these services, IApplicationBuilder, IHostingEnvironment, IGreeter, these are all services that ASP.NET knows about and can inject into this method. IGreeter was a custom service that we created in the last module. The other services, ApplicationBuilder, HostingEnvironment, LoggerFactory, these are all services that are available right from the start. ASP.NET provides them. You might remember we saw them in the services collection when we had a breakpoint in this method. In this IHostingEnvironment interface, it can give me all sorts of information about my hosting environment. We used it previously also in the constructor of the Startup class. ASP.NET can also inject that service here. In the constructor, I use the IHostingEnvironment interface to find out the ContentRootPath for my project. That will be my path on the physical file system to the folder that contains the project.json file and the appsettings.json file, that helps the configuration system find app settings. Down here in Configure, we are using IHostingEnvironment to find out what sort of environment we're in. Is it a development environment? We can also ask is this a production environment, is this a staging environment, or is it some custom environment that I have defined? And now the obvious question is how does ASP.NET make this determination? Well, when you create a new project using File New Project in Visual Studio, Visual Studio will add some properties to the project to configure this application to run in a development environment. If I go to the Properties window for this project, there are three categories of properties, Application properties, Build properties, and Debug properties are the important properties to look at here. The debug properties tell Visual Studio to launch my application using IIS Express. And by the way, I should mention that these settings apply even when I do not use the debugger in Visual Studio. If I just run the application, it's going to launch with IIS Express and an environment variable is going to be set ASPNETCORE_ENVIRONMENT. The value is going to be Development. This is an environment variable that ASP.NET will look for by default. If the value is set to Development, then this flag IsDevelopment will be set to true. On the other hand, if I change this to Staging, IsStaging will be true, and if I change it to Production, the IsProduction flag will be true. If this environment variable doesn't exist, ASP.NET will assume it's a production environment, that's a safe default. So if I change this value over to production and then close my property pages, we're going to go back and change that back in just a little bit. Now this piece of middleware will not be registered as part of the application. And so if an error occurs, we'll go back to that scenario where we just have a blank browser screen, and a 500 status code coming back from the browser. What can we do in these situations? This is a situation where we can use a different piece of middleware for production. There's a UseExceptionHandler middleware that we can use for production, and yes, we could debate the merits of using different pieces of middleware in different environments, but UseExceptionHandler is highly configurable. There's a couple different things I can do with it. One thing I can do with it is simply pass in a path, and what UseExceptionHandler can do is re-execute my request to pipeline using this new path so that my application can respond in a different way. Later on in the course, what we could do is set up an ASP.NET MVC controller that could respond to a URL like server.com/error and give the user a pretty error page, and then on the back-end it could also log details about the exception somewhere in a log file or database or somewhere safe back on the server. We don't want to show the user all these exception details. Another thing I could do just to test to see if this works is to instantiate a new instance of ExceptionHandlerOptions. One of the properties on ExceptionHandlerOptions is the ExceptionHandlingPath, so I could also say /error there, but I can also provide an ExceptionHandler. You can see in the IntelliSense window the type of this ExceptionHandler is a request delegate. A request delegate is also what is used by app.Run, so a request delegate is a method that takes an HTTP context as a parameter and then returns a task, let's just assume that it's going to operate asynchronously. If I wanted to write this as a lambda expression, I could say ExceptionHandler =, given in HTTP context, please evaluate and return the following expression, context.Response.WriteAsyn Opps! So that will be our friendly error page that we show to users, because it's very difficult to build complicated HTML when you're just using a C# string. But if I save everything, I'm going to relaunch everything by pressing Ctrl+F5 again. That will make sure that IIS Express gets launched with this new environment variable in effect. Eventually Visual Studio will get the browser launched, and now because a request to the root of the website will generate an exception, and I am now in a production environment, I simply display the string Opps! But again, chances are you will use the Path parameter, so you can essentially do a server-side redirect to an error handler that you have on your server. Something like an MVC controller in a view that can render a pretty error page. But right now, before I forget, I'm going to go back into the Properties for my project, and I'm going to set this back to Development, because having stack traces is quite useful when we're developing an application. I'm also going to remove that line of code that throws a new exception, and now we can see that not only can I build an HTTP request pipeline with middleware, I can also customize that pipeline for different environments. Now one of the other things that I could have done with the exception handler is given it a path to an HTML file that resides somewhere in my web application that's on the file system. I just want to show an HTML page. But currently my application cannot display a simple HTML page that lives on the file system. Let's look at that next and find out how we can get it to work.

Serving Files

One feature nearly every web application needs is the ability to serve up files from the file system. Files like JavaScript files, images, CSS files, files that are on disk. Currently our application cannot do that, and to demonstrate that fact and to show you how we can serve those files up, I want to add a simple HTML file to the project. This HTML file has to go into the web root folder, wwwroot. By default that's the only place where we can serve up files directly from the file system. So on that folder, I right-click and I want to add a new item, and I'm going to search for the HTML template. I want to create an HTML page, let's give it the name of index.html, that's a good default name for an HTML page. And once this file is added to the project, let's give this file a title of Welcome, and some simple text, Hello, from an HTML page. I'm going to save that file, I'm going to save all files, in fact, and come over to the browser where I'm going to try to go to index.html. And the result I see is A configurable hello! So this is the result from my middleware that I have in Startup file, the last piece of middleware, the middleware that runs in app.Run, and the reason I'm seeing that result is because there is no middleware installed that will look at that request for index.html and try to find a file on disk. In order to do that, I need to configure another piece of middleware. So let's go to the project, right-click, say that I want to Manage NuGet Packages, and I'm going to do a search for staticfiles. The package that I'm looking for is Microsoft.AspNetCore.StaticFiles. I'm going to install that package after I accept the license terms. That file is going to come down to the file system. Let's swing over to project.json. I just want to show you that adding that package through the UI has also recorded the fact that I've installed that package in project.json, so you can use either approach. And now over in Startup.cs, I'm going to have some new middleware options. So in addition to welcome pages and exception handlers, I'm also going to be able to say app.UseStaticFiles. Now like most every other piece of middleware, this piece of middleware will take some configuration options, but I'm not going to pass any in. By default, what static files will do is look for files on the file system in the webroot folder. And now if I save my startup file and come back to the browser and refresh this request for index.html, I will now see the html file that we just created that says Hello, from an HTML page. What if I go to the root of the website, what if I want index.html to be served by default? Well, the static files middleware does not give me that feature. It's going to look at the path and the request and try to map that to a file that is on the file system. There is another piece of middleware, which is UseDefaultFiles, and what this piece of middleware will do is look at an incoming request and see if there is a default file that will match that request. So in other words, if there is a request to the root of the website, this piece of middleware will look in the web root to see if there are any default files. And the default file names are configurable, but index.html is one of the default names. So with that piece of middleware in place, I should be able to save Startup.cs, and now refresh a request to the root of the website, and I still get to see the HTML page that I have on the file system. Now it's very important, once again, to order the middleware correctly. If I place UseDefaultFiles after UseStaticFiles, I would not get the result we just saw. That's because UseStaticFiles doesn't actually serve up a file. What it will do is see if a default file matches the incoming request, and if so, change the request to path so that later in the pipeline something like UseStaticFiles will find the matching file and serve it up. Now there's one other piece of middleware that actually combines both of these features, and that is UseFileServer. UseFileServer is essentially default files plus static files. You can also enable features like directory browsing with the options that you pass into UseFileServer, but I'm just going to leave it with the default options. And now back in the browser, a request to the root of the website, that will still respond with my HTML page, a request for index.html, that will also serve my index.html page that's on the file system. A request to /welcome, that will still use the welcome page middleware that was installed into the pipeline. And a request for anything else, like /foo, that's going to travel through all the other middleware and reach the app.Run block where I write out a configurable greeting. So now we have an application setup so that we can handle exceptions and see stack traces when something goes wrong. We can serve up static files that are in the web root folder. We have a welcome page at /welcome, and we have a greeting displayed for any other request that the rest of the middleware didn't recognize. And now there's one more piece of middleware that we need to install before we can start using ASP.NET MVC. We're going to do that in this module, and then start digging into the magic behind this MVC middleware in the next module.

Setting up ASP.NET MVC Middleware

Ultimately what we want to do is build a web application on top of ASP.NET, more specifically on top of the ASP.NET MVC framework. Although we could technically build an entire application using only middleware, MVC gives us the features that we can use to easily create HTML pages and HTTP-based APIs. We'll see how all that works in the rest of the course. For now we just want to get set up to use the MVC framework, and set up from our nearly empty project requires three steps. Step one is installing the ASP.NET MVC package. That will give us access to the assemblies and the classes provided by the MVC framework. Once the package is installed, we need to register all of the services that MVC requires at runtime. We'll do this inside of the ConfigureServices method, where we also configured our IGreeter service into the application. And finally, we need to add middleware for ASP.NET MVC to receive requests. Essentially, this MVC middleware takes an HTTP request and tries to direct that request to a C# class that we will write, a controller. I'll show you a little bit about what the class looks like in this module, but we will go into much more detail in the next module on how controllers work, so try to remain patient. For right now, we just want to have all the setup in place so that we can move forward. We want to use the ASP.NET MVC framework, so let's come into the project.json file this time, and I'm going to add a new dependency, this time by searching for MVC, and I should be able to find the package Microsoft.AspNetCore.Mvc. We will take version 1 of this package. Once I save project.json, and once Visual Studio has caught up, then I should have a new piece of middleware available. What I'm going to do for right now is I'm going to remove the welcome page and I'm going to remove the bit of middleware that is in there with app.Run. We're really not going to make use of any of that anymore. I was just using those to demonstrate the workflow from middleware and how middleware works. Instead what we're going to be using is MVC, and I'm going to select the extension method that says UseMvcWithDefaultRoute. I promise to explain in more detail in the next module exactly what that means, but here's the ultimate goal of the MVC framework. This middleware is going to look at an incoming HTTP request, and try to map that request to a method on a C# class. And what the MVC framework will do is instantiate a class, invoke a method, and that method will tell the MVC framework what to do next. Ultimately what I want the MVC framework to do is I want the MVC framework to take control of responding to a request for the root of the website. Right now since I have an index.html file in wwwroot, and I have the file server middleware registered before MVC, the index.html page will always display when I request the root of the website. So I'm going to delete that file, but I am going to leave the file server middleware in place. We are going to be using some static files later in the course. And now you might remember that there were three steps to using the MVC framework. Step one was to install the package, step two was to register the middleware, step three was to register the services, and it actually might have been register the services before the middleware on the slide, but in either case, I am in a situation where I have registered the middleware for ASP.NET MVC, but I have not registered the services, and I just want to show you the error message that results. Unable to find required services. Please add the required services by calling 'IServiceCollection.AddMvc' inside of 'ConfigureServices.' This is because ASP.NET MVC requires some services to function. The MVC framework has a very flexible and very granular architecture. There's a number of different services that all have a very specific responsibility. For example, there is one service that the MVC framework uses to locate controllers for a given request. Since that service isn't present, ASP.NET MVC is throwing this exception. And this happens really before the application even gets started, because this happens while we are still inside of Configure. It happens while we are still setting up the middleware, so that's why we don't see the pretty developer exception page. Now what the MVC framework will do, when I install the NuGet package for the MVC framework, that will add an extension method that allows me to configure the middleware on IApplicationBuilder, but the package also contains an extension method for IServiceCollection that makes it really easy to add the default MVC services. I can just say AddMvc. And if there's any of those services that I want to replace, I can still go into that service collection and replace those specific services. That's how easy it is to extend the MVC framework. But now to see if we have this working, let me write the simplest possible controller, so again, the goal of the MVC framework, direct a request to a controller method. We will cover that in much more detail in the next module. For right now, I'm just going to right-click on the project and add a new folder. I'm going to call it Controllers. You can have more than one controller in an MVC application. And then in this folder, I'm going to add a very simple class. I'm going to give this class the name HomeController, and inside of this class I'm going to create a public method that returns string. I'm going to call this method index, and I'm just going to return a string Hello, from the HomeController. The reason I called this class HomeController and the reason this method is named Index is because this follows some conventions that the MVC framework will use. And that is also a topic that we'll cover in the next module. But what I should be able to do at this point is save all my files, and let's come out and send off a request for the root of the website, and what I will get back as a response is a simple string Hello, from the HomeController. So we're not using any sophisticated HTML just yet, we will build something more sophisticated in the next module, but this was enough to let me know that ASP.NET MVC was successfully installed and successfully configured. I now have the middleware installed for MVC that happens inside of the Configure method, and all the services are added in the ConfigureServices method. The MVC framework is up and ready to go, and in the next module we will learn more about this framework and how to build an application on top of ASP.NET MVC.

Summary

In this module, we learned more about middleware and how to configure middleware in the Configure method of a startup class. We now have a processing pipeline where a request to the root of the website will travel through several pieces of middleware, including the DeveloperExceptionPage, that can show detailed error information, there's the file server that can serve up static files, and finally that request can reach the MVC middleware. The MVC middleware can then forward that request to a controller class. Right now we have a simple controller that displays a hello message, but in the next module we will learn more about controllers and how requests can reach different controllers and how they can produce HTML.

Controllers in the MVC Framework

Introduction

Hi this is Scott, and in this module we will start learning the ASP.NET MVC framework. The MVC framework gets its name from a popular design pattern, which we will also learn about, and then we'll go into the mechanics of how to use controllers to process HTTP requests. We'll see that controllers can produce text, serialize objects into JavaScript, and render HTML to the client.

The Model View Controller Design Pattern

The MVC framework is named for the MVC design pattern where M stands for Model, the V stands for View, and the C is for Controller. The MVC design pattern is a popular design pattern for the user interface layer of a software application. And in larger applications you typically combine a model view controller UI layer with other design patterns in the application. Like data access patterns and message patterns, these will all go together to build the full application stack. In this course, we'll just focus on the MVC fundamentals. In MVC, the controller receives an HTTP request. We'll see how to map an HTTP request to a method on a controller class, and once inside of a controller method, the controller has to figure out how to put together the information to respond to this request. Perhaps the user is pointing their browser to the /movies URL of the application. So the controller needs to put together the information to display a list of movies. In this scenario, the controller will build a model. The model doesn't know anything about the HTTP request or the controller. The model is only responsible for holding the movie information that the user wants to see, as well as any logic associated with that list of movies. A model is just another C# class we can use, perhaps there's more than one class if you have a complex model, but once the model is put together, the controller can then select a view to render the model. The view will take the information in the model, like all the movies and each movie title, and it will use that information to construct an HTML page, and then that HTML is sent back to the client in the HTTP response. And thus we've completed an entire HTTP request and response transaction. These are the basics of the MVC design pattern, and we'll be working in each one of these steps in this module. The idea behind this pattern is to keep a separation of concerns. So the controller, it's only responsible for taking a request and building a model. And it's the model that carries the logic and data we need into the view, and then the view is only responsible for transforming that model into HTML. We have three components, each with their own focus on a specific part of the job. In order for all of this to work, we need to find a way to send these HTTP requests to the right controller, and in ASP.NET MVC, this process is known as routing. Let's look at how to route requests to different controllers.

Routing

The ASP.NET middleware we installed in the last module needs a way to determine if a given HTTP request should go to a controller for processing or not. The MVC middleware will make this decision based on the URL and some configuration information we provide. One way to define this configuration information, this routing information, is to define the routes for our controllers inside of Startup.cs. When we add the MVC middleware, this approach is often referred to as convention-based routing, and in this approach we defined templates that tell MVC how to look at a URL and find a controller name and an action name, where a controller is a C# class, and an action is a public method on that class. Another approach to routing is what we call attribute-based routing. With attribute-based routing, we can use C# attributes on our controller classes and on the methods inside of those classes, and those attributes have metadata that tell ASP.NET when to call a specific controller. Let's take a look at these two routing approaches in the next two clips.

Conventional Routes

At the end of the last module, we created a controller in our application, the HomeController. As you can see, this class doesn't need to derive from a base class or implement an interface or have any special attributes. What we have a plain C# class with the name HomeController. And as the open browser on the right-hand side of the screen demonstrates, we could see the string this controller Index method returned just by browsing to the very root of our web application. Currently we are not using models, we are not using views, we are just going to focus on simple controllers and how to route an HTTP request to a specific method on a controller. The way we're currently doing this is back in our Startup class, UseMvcWithDefaultRoute, that extension method. I'm going to simplify things by getting rid of the WithDefaultRoute part, because there's another extension method I can invoke, UseMvc. This will install the MVC middleware, but it will not give me any routing rules. Instead, I'm going to pass in the name of a method that we have not created yet, but we will call that method ConfigureRoutes. I'll press Ctrl+Period in Visual Studio, use Visual Studio to generate that method, and as you can see, the method that I pass in to use MVC, it's a method that has to return void and take a parameter of type IRouteBuilder. You could write this code that I'm about to write inside the method as a lambda expression, but I'll use a named method just to make things a little bit clearer. I'm going to also rename this parameter to routeBuilder. And when I have a routeBuilder, one of the things I can do is map a route. The first route that I want to map will be very much like the default route that UseMvcWithDefault route, what that method would have given to me. And the first parameter that I pass in here is just a friendly name for the route, so I'm going to call this the Default route. It's going to be the only route that we start off with. And then the second parameter is arguably the most important parameter here. The second parameter is a template that describes to the MVC framework how to pick apart the path of a URL. So let's say that I receive an HTTP request or /Home/Index in my application, and I want the MVC framework to interpret this URL by looking at the first segment of the path and saying, ah, you want the HomeController. And even though this doesn't have the word controller in here, MVC automatically applies a convention whereas if this is a controller name, the word controller is automatically appended, so it will go looking for a class named HomeController. And then I want to take this second segment of the path and use that as my action name; in other words, when we have a method on a controller, a public method, we don't think of those as just methods, we think of those as actions, they're something that I can reach by having the right URL come into this web application. So the controller name is Home, the action name is Index, that's what I want to have happen when the MVC framework sees /Home/Index. So I'm going to add a template where first I'll have the word controller inside of curly brackets. The curly brackets denote a parameter, so the MVC framework's not going to look for the word controller in the URL, it's going to take what is ever in the first segment and treat that as the name of the controller as a parameter and the second segment of the URL after the slash, that will be the action name. So I can also have literal text in here. I could also have something like admin/controller/action. Now the MVC framework would have to see admin/home/index to reach a particular controller, but I don't want the word admin there, so I'm going to take that out. And I am going to add one more parameter in this URL. I'm going to add a parameter, the third segment of the URL, that MVC can treat as an ID parameter. But I'm also going to add a question mark here, and a question mark says that a particular parameter is optional. In other words, the MVC framework doesn't have to see something else here, and that something else, the ID, it could be a number like 42, it could be letters and numbers, it could be a GUID, all the MVC framework has to see for this route to match is a controller name, slash, and an action name. Now before we try this new route, I'm going to go back and quickly add a piece of middleware, or given in HTTP context, I'm just going to say ctx/Response, let's write out async Not Found, and the idea is this. When the MVC middleware inspects a request and it sees that it doesn't match any of the routes that I have configured, it will allow that request to go through to the next piece of middleware. And so at this point moving forward, if I ever see not found as a response, I'll know that the URL that I'm using does not match one of the routes that's configured or use MVC. So at this point, let's save everything and refresh, and I'll see that the response is not found. And that's because the route that I have added is not quite like the default route that MVC would use when I have that extension method that I use with default route. The true default route adds some defaults for the parameters that are here, and I can do that by using an equal sign and then providing a default value. This is new for this version of ASP.NET MVC, but this tells the framework that if you don't find a controller in the URL, the default controller name should be Home, and if you do not find a default action in the URL, the default action name should be Index. Now if I save my files and refresh, now again, we have a request to the root of the website that is going to reach the HomeController. These default values, by the way, you can pick anything you want, so the action doesn't have to default to being index, I could have said the default action is named foo, but if I were to save that and refresh, we'd go back to being not found, because the HomeController doesn't have an action named foo. So let's keep the default as Index. And now because of the defaults, I am able to reach the HomeController's Index action from the root of the website where the defaults are picked up. I should also be able to go to /home, that will reach the HomeController, and pick up the default action of index, and I can also have the very explicit URL /home/index, all of those requests should reach the same controller and the same action on that controller. If I try to reach a method that's not available, let's try to reach /home/list, that will be not found. But since we have an Index method, that is found. Let's try this with another controller. I'm going to right-click on the project in the Controllers folder. I want to add another class. Let's call this class the AboutController. This will have information about the application or about the company behind the application. And let's give this controller one public method called Phone that will allow me to see the phone number for the company, and let's just use a 555-555-5555 number. And let's have an Address action that will simply return the string USA. Now I want to save everything and try to get to this about controller also. Because the name of this class is About Controller, I should be able to go to /about, and if I want to reach the address action, going to /about/address should give me the result USA, which it does, and /about/phone gives me the phone number. So my routing rule looks like it's working just like I need. And this is really the essence of routing. I need to describe one or more rules that the framework can apply to figure out where I want to go. What controller do I want instantiated, and what method do I want to invoke on that particular controller? That is what my template is doing here. And you can have as many routes defined as you like. You can have just one route. We have one called default. I can have 50 other routes defined that are special cases for individual controllers perhaps, controllers that need a special URL. Perhaps they need additional parameters or they need to be nested inside of a specific area inside of my application. For the most part in this course, we're going to work with this one very simple route. However, I do want to show you one alternative to this sort of routing, because routing is very flexible in ASP.NET and there are different ways to achieve what you need. This is what we would call convention-based routing. But in the next clip, I want to show you how to use attribute-based routing.

Attribute Routes

One way to define routes for ASP.NET MVC is to use this MapRoute method of a routeBuilder. This allows me to define templates to use against incoming URLs like /home/index. But another way to define routes is to use an attribute directly on a controller. And these attribute-based routes, these are great for routes that are very specific to a controller, and they allow you to define routes right next to the controllers that are going to be pointed to by these routes. I'm going to add a route attribute to this class, this route attribute is from the Microsoft.AspNetCore.Mvc namespace. I'm also going to use Visual Studio to remove the using statements that I'm not using. And let's say I want this controller to behave in such a way where I can have phone be the default action on this controller. In other words, if someone comes to just /about, I want this to invoke the phone controller. That's the type of rule that will not work well with the template I have currently defined, because that says that the default action is index, and that might work well for the HomeController and it does in other controllers that I have, but it's not going to work well with the AboutController. So I'm going to use the routing attribute, and with the routing attribute what I can do is say that in order to reach this controller, the first part of the URL has to be about, and then the next piece of the URL can be empty. I'm expressing that just using an empty string. And let me show you something that can happen, if I save all my files at this point and refresh, and actually want to go to, not refresh, I want to go directly to just /about. And I have an exception message from ASP.NET MVC about multiple actions matched. This is how the MVC framework tells me that I can see that you wanted me to go to the AboutController, I figured that out because of the routing attributes. But I see two different methods inside of here and I'm not sure which one to invoke. I don't know if I should go to the phone method or the address method. I can fix an error like this by providing an explicit route attribute for address, and saying that the only way to reach this particular action is to have a URL like /about/address, so these route attributes are hierarchical. The top-level route here would be the start of the route, which is really the start of the URL path, and then I can pretend there is a slash after about, and then I either see nothing, which we'll go to the phone action, or I see /address, and we'll go to the address method. Let's just verify that by saving and refreshing. And now I can see the behavior that I want, which is going to /about produces a phone number. If I put phone inside of here, I wouldn't be able to do that anymore, I would have to go to /about/phone. And now we have the situation where these route names match the method names. And the controller name matches this part of the route name. And when you are in that situation, you can use what's known as tokens inside of the route attribute. So, tokens are inside of square brackets. These are not parameters like we saw in Startup.cs with the curly braces, these are tokens, and one special token that I can use here is the word controller. That tells the MVC framework that what you need to see in this position of the route of the URL is this name of the controller, about. Likewise, I can also use a token for an action name. This way if someone ever goes in and refactors the phone method to a different name, that will also change the URL that I need to reach this particular action. So if I rename this method to telephone, I would have to go to /about/telephone to reach this particular action. And if I'm just going to have defaults here, where essentially I need the name of the action to reach this particular method, then there is an easier syntax I can use, which is to remove the route attributes here, and just include the action token in my top-level route attribute, because the MVC framework has the ability to say, okay, I need to see the controller name and then an action name, so we URL like /about/phone, I know can instantiate this controller and invoke this method. I can also have literals in the URL, just like I could with MapRoute. So I could say I need this controller to only respond to a request when the URL looks like company/about/some action name. So if I save everything and try to go to about/phone, this will take me to my not found middleware, so I know that ASP.NET didn't find a way to respond to this request, it didn't find a matching controller, but I should be able to go to /company/about/phone, and I can still get to the phone number, and if I go to /address at the end, that will return USA. And this was a quick demonstration of attribute-based routing. Again, there's a lot of flexibility here, you can include parameters, and you can include all sorts of constraints. We will revisit routing in the future of this course, but for now just know that you can combine convention-based routing with this attribute-based routing. Attribute-based routing is great for special case routes or actions that need some additional parameters. Convention-based routes don't handle those scenarios very well; however, many of the controllers that we're going to write in the application for this course, they will use convention-based routing. And now that we know how to take an HTTP request, like /company/about/phone, and direct that request to a specific method on a C# class that we write, a class whose name always ends with the word controller, let's actually dig into these controllers and see what else they can do.

Action Results

So far in our project we have been using plain, simple C# classes as controllers. Our controllers don't derive from a base class, and you can use this approach with MVC, but it is much more common to derive your controllers from a controller-base class provided by the MVC framework. The base controller class gives me access to lots of contextual information, as well as inherited methods that help me build results to send back to the client. I can send back simple types like strings and integers in a response, but I can also send back complex objects, like an object to represent a restaurant, and all the data associated with a restaurant. These result types or action results, they are typically encapsulated into an object that implements the IActionResult interface. There are many different types that implement this interface, result types that can contain a model or the contents of the file for download. These different result types also allow us to send back data serialized into JSON or XML. We could also build HTML for the client. Let's take a closer look at how this works inside of the project. Inside the HomeController's Index method, I just want to use the IntelliSense window to show you the API that is available to me here inside the method. Almost all of the methods that you see here are methods that I inherit from my implicit system.object base class, and none of them are particularly useful when I'm programming a controller action. And that's why most controllers will derive from a base class Controller, this is provided by the MVC framework, and it is in the namespace Microsoft.AspNetCore.Mvc. So I'm going to bring in that namespace, remove the namespaces I'm not using, and then show you the IntelliSense window again. Now I have a much richer API. There's a number of methods in here that allow me to create different types of results. For example, the first method that is available, BadRequest, that would return an object that implements IActionResult that basically returns a 400 error back to the client, it tells them that they made a bad request for some reason. I also have access to a lot of contextual information. So if I want to find out more information about the controller that I am inside of or even the action that is executing, I can get the information like the action name and the controller name from this contextual property. Speaking of contextual properties, there's also an HttpContext. This property can give me access to things like the response object, if I want to write into the response object. Or even the request object, if I want to do something like look at the headers. But I can tell you as a general rule of thumb, you want to avoid using the HttpContext inside of a controller, unless there is no other solution. And throughout the rest of this course, I'm going to show you some areas where you can avoid using HttpContext, and use some friendlier mechanism that is built into the MVC framework to access information that is in the context without going directly to that property. Going directly to that property just makes things a little harder to test, and usually requires a little more code. But again, those scenarios will come up throughout the course. Now methods like BadRequest, these are what I would call result helper methods, they produce something that implements IActionResult. Another example would be the File method. The File method produces the FileContentResult. I can invoke this method and pass in a byte array, and that will build a result that the MVC framework will ultimately take and send back to the client so they can download a file. There's a different version that takes a string parameter, the virtual path to a file, and that gives the MVC framework the ability to read an existing file that's out there somewhere, and take the contents and send it back to the client. There's also a Content method. So instead of sending back a string by returning a string, I can invoke the Content method, pass in a string, and this will build a ContentResult. And that means I need to change my return type here to either ContentResult, or I can also return IActionResult. If you have a controller action that's only going to return one type of result, it's often useful to use a concrete type here as the return type, especially if you're doing unit testing that makes the controller a little easier to unit test. But it's certainly possible, and we will see controller actions that have different types of results, depending on the circumstances. And in those cases, we might need to return IActionResult, so any object that implements IActionResult is legal, and in this case a ContentResult is something that implements IActionResult. Now if I save my controller and come back to the browser, the client's not going to notice any difference. We're still just sending back a string, Hello, from the HomeController, we're not even sending back any HTML. So you might be wondering what is the advantage of using something that produces an IActionResult? Well, the typical advantage is that an ActionResult is a formal way to encapsulate the decision of a controller. So the controller decides what to do next. Do I return string? Do I return content? Do I return HTML? Do I return a model object that might be serialized into JSON or XML? All the controller needs to do is make that decision. The controller never has to write directly into the response the results of its decision. So unlike middleware, where we typically go to a Context object and write something directly into the response, a controller is going to return an ActionResult, and the MVC framework will take care figuring out how to take this ContentResult and put it into the response for us. So it's a higher level of abstraction. And also it's an important concept in architecture and software design. This is a separation of deciding what to do next versus actually doing that work. And this separation of deciding from doing gives us some additional flexibility, it makes controllers a little more testable. And it also gives me the ability to do something like the following. I'm going to go ahead and create a model for our project, and I will do that by adding a new folder to the project called Models. And in larger applications you might keep all of your models in a separate class library, a separate project away from the web UI, but we are building a relatively simple application, so I'm just going to use a Models folder here. And I'm going to add a class called Restaurant, because ultimately in this application OdeToFood, we want to show information about restaurants. Let's create a very simple restaurant. Later in the course we will store restaurant information in the database, and that will require a restaurant to have a primary key, so the first property I added there, Id, that's going to hold the primary key eventually. And I'm also going to give every restaurant a name. Just two simple properties to start with; we will add more later. Let me save restaurant and come back to HomeController. What I want to do now is have my controller action instantiate my model, which is a restaurant, and in order to be able to do that, I'm going to bring in the namespace OdeToFood.Models with Ctlr+period, and let's give our restaurants some initial data, populate the properties. So let's give it an Id of 1, and the name is The House of Kobe. Now what I want to be able to do is send this restaurant back to the client. Not as HTML; we will do that in just a bit. I want to produce something known as an object result. Now it just so happens there are many types of results that you can create with one of these helper methods, like File, Content, BadRequest. There's also a very popular type of result which is an ObjectResult, which I need to instantiate explicitly. So I will instantiate an ObjectResult and pass in my model. And ObjectResult is a special type of result in the MVC framework, because when I return an ObjectResult, the MVC framework looks at this object and the model inside and says, we need to take this object and represent this object somehow in the HTTP response. So should we take this model object and serialize the object into XML or into JSON or into some other format? And ultimately that decision by the framework will be based on some configuration information that you give the MVC framework at startup. Or if you don't configure anything, you will just get some defaults, and that's what's going to happen here. We're just going to get a default response for an ObjectResult, and that default is to serialize the model into JSON and send that back to the client. So if I save the HomeController and come back to the browser and refresh, we're no longer saying hello, we're taking this model, which is a restaurant, the MVC framework is serializing that model and sending back JSON to the client. And now I have a response that I could easily consume from JavaScript. So when you're building an API and returning raw data to a client, you're typically going to build controllers that return ObjectResult. And there's all sorts of extensibility points in the MVC framework where you can tell the framework to look at certain headers, and if such-and-such a header exists, produce JSON. If a different header exists, produce XML. So for those of you that are familiar with HTTP-based APIs, ObjectResult gives us content negotiation. But the nice thing is, the controller doesn't have to worry about any of that. Really all the controller is worried about is building a model, whether it's querying a database or instantiating some objects in memory, the controller needs to build that model and then return some type of result. So this controller index action, this would be very good for an API. But let's also see how to take this model object and render that model into HTML using the Razor view engine.

Rendering Views

With the MVC framework, the most popular technique for creating HTML is to use the Razor view engine of ASP.NET MVC. To use this view engine, a controller action produces a ViewResult object. That implements IActionResult. And a ViewResult can carry the name of a specific Razor view that the controller action wants to use. In our application, the view will be the file on the file system. So the view result can carry along the name of the view that we want to use as well as a model object that that view will consume. The view can use that model object when it wants to create HTML, so it can take something like a restaurant name and put that inside of a header tag or in the title of a page. So when the MVC framework sees that your controller has decided to produce a ViewResult, the framework will find that view on the file system, execute the view, which produces HTML, and it is that HTML which the framework sends back to the client. Let's see how this works inside of our application. Inside of the index action of the HomeController, instead of producing an object result, let me invoke the helper method view, which will produce a ViewResult. A ViewResult also implements IActionResult. We will look at some of the parameters that we can pass to this view method, but for right now I will invoke the method without any parameters, save my file, and refresh the browser just to show you how that application behaves, and what we will see is an error. Because I've told the MVC framework that I have decided to render a view, and now the MVC framework has to go out and find that view. It's looking for a view called index. The MVC framework follows very specific conventions in where it will try to locate a view. So I can see here that it looked in a folder called Views, and then a subfolder called Home-- where does Home come from? When I render a view from a controller named HomeController, the MVC framework is going to look in a folder dedicated to the views for that specific controller, so we're looking in /Views/Home, and then we're looking for Index.cshtml. All Razor views have the file extension cshtml. Why the name index? Because we rendered this view from the index action. So you can see the naming convention here. All the views by default are going to go under /Views, and then the short name of the controller, and then the name of the action and .cshtml. There is one version of view that I can use to change the name. If wanted to render a different view, like the Home view instead of the default index view, I can pass in a string parameter there. The MVC framework will interpret that as the name of the view. You can see it's now gone looking for Home.cshtml. But let's go back to using Index with no parameters and see if we can get this to work. I know that I need a folder called Views, and inside of that folder, I need to add another folder called Home, so all of the views for this HomeController will be here. There's also, by the way, a shared folder, any views that you place into that folder, they are available to any controller out there, because the MVC framework will always look in that folder. But we're going to create index.cshtml in this folder, Home folder. Let me add a new item. I'm going to go to ASP.NET, and this time search for view, and I'm going to select this first template here, an MVC View Page. Yes, I do want the name of this to be index.cshtml, so let me add that view, and the way we will start things off is by deleting all the code that is inside of here. I want to render HTML, and inside of a Razor view, I can type in HTML, I can add divs and headers and all of that; I'm going to use a code snippet html and then press Tab. That's a little code snippet that will give me the base structure for an HTML page, so now I have a header and a body, I can add a title for this page. Let's put in a title of OdeToFood. Inside of the body I could have an h1 tag, Hello from a view, and perhaps even a div. This is the homepage. Let me save that view, come back to my browser. We should now have an index.cshtml file. And here I can see I do get the HTML that I expect. Now let's see if we can get some restaurant information into this view. This is where I want to take my model and pass it along to the view, so it is available inside of that cshtml file. There's a version of the View method that will take a model object. There's another version that takes a view name and a model object. So the API is very flexible. And now inside of index.cshtml, here's how things work. Everything I have inside of here now is literal text. The MVC framework is going to take this view, look at the text inside, and just send it down to the browser. That's why I have an h1 element, Hello from a view! That's why I have a div here that says this is the home page. But now I want to mix in some dynamic content. I want to put in a restaurant name. That restaurant name is going to come from my model. My model, by the way, doesn't know anything about the view, doesn't know anything about the controller or the action; its only purpose in life is to carry along information and perhaps some logic, so that I can consume that information and logic from a view. And now inside of a view, in addition to the literal text that I have here, I can also write small C# expressions. I start writing a C# expression inside of a Razor view using an @ sign. And this switches razor into a mode where whatever I type here is going to be evaluated as a C# expression. It will evaluate the expression and produce some value, and I can place that value into my literal text, into my HTML in this page. And one important thing to understand is that the MVC framework is going to take this Razor view and compile this view, it really becomes a class just like the classes that write, and that class is going to have some properties and members available. If I look at this, I can see an entire API here, and some of these things we will be looking at throughout this course, but I want to show you one of the most important properties available inside of a Razor view is the Model property, Model with a capital M. This Model property will contain the model, which is passed into the View method, so if I pass in a restaurant, then what I have access to inside of index.cshtml is that restaurant. Every restaurant has a name, so if I output the C# expression Model.Name here inside of the h1 tag, what I should see in the browser is The House of Kobe inside of the h1 tag. Now one quick tip about this. Inside of a razor view, I have no help from IntelliSense by default. So if I say Model., Visual Studio at this point does not know what my model is, it treats model as dynamic, and therefore I don't know what's available on my model. I can change that behavior by using what's known as a directive. The directive I'm going to use is @model, but this case it's a lowercase m, so @model with a lowercase m is what we call a directive. It's a directive to set the type of the Model property, the Model property with a capital M. The capital M Model is something that I would use inside of expressions to produce values that I put into my HTML. So let me show you that when I use this directive, I can say that my model type, it should be an object of type restaurant from the OdeToFood.Models namespace. Once I do that, Visual Studio and the MVC framework at runtime, everyone knows that this Model property should be of type restaurant, and now I can see my IntelliSense. Every restaurant has an ID, every restaurant has a name. If I have a typo here, I should be able to get errors, errors that will tell me, sorry, this isn't available on the model type that you selected. So I know a lot of people coming to Razor for the first time get confused between @Model with an uppercase M and @model with a lowercase m. The lowercase m is to set the type of your model. This gives Visual Studio in the MVC framework more information about what your model is or should be if I do not pass a restaurant into this view. If I pass a string or some other type of object, I'll get a runtime error. And then @Model with the uppercase M, I use this to produce expressions that the Razor view can evaluate to spit out data into my HTML at the appropriate location. There is no difference to the user, adding that strong typing there is really just for me and Visual Studio and the MVC framework to all understand what model this view should be accepting. And what we're seeing here is the essence of the MVC framework and the MVC design pattern. It's very simple at this point; we're not doing much. But I have a controller. This controller receives requests that are HTTP requests that get routed to this specific method on this specific class. The goal of this method is to produce a result, a result that represents the decision of what to do next. In this case, I want to produce a view. In order to produce this view, my controller action also has to put together a model. The model's going to carry all the information that a view needs, so that the view doesn't have to do any hard work. All the data access is done by my controller. All the view needs to do is take that model and produce HTML, that's a separation of concerns.

A Table Full of Restaurants

Let's build on this example that we currently have working and display a collection of restaurants, multiple restaurants. Because ultimately I want to attach this application to a SQL Server database, and that database will contain multiple restaurants. I want to be able from this application to see all of the restaurants that are in the database. We are not going to start using a database just yet; we will do that later in the course. But I do want to write a service or a component that will simulate data access. This component will start just by holding some restaurants in memory, and then later in the course, partly to demonstrate the flexibility that we have, we'll swap out that component with another component that actually talks to SQL Server. So we will start by creating a folder that I'm going to call Services. So this represents the various classes and components that I want to use throughout the application to perform things like database access. And I can even take my Greeter service that I wrote earlier in the course, I'm going to move that into the Services folder, because it really is a service. And I'm going to change the namespace that this class is defined in, because the convention in C# is to have namespaces that map to folders. I'm in the OdeToFood.Services folder, so I will be namespace OdeToFood.Services. That's going to require a using statement where we use the Greeter, but we'll come back and fix that up in just a bit. Because I'm going to go ahead in the Services folder and also add a class, let's call it RestaurantData. The goal is that this service will provide information about restaurants. We will start off by holding the RestaurantData in memory, so I'm actually going to call this InMemoryRestaurantData, and later we will swap this out for a class that talks to SQL Server. And in order to be able to switch between the two without the rest of the application knowing, I will go ahead and define an interface IRestaurantData with the idea that both InMemoryRestaurantData and the SQLRestaurantData that we use later, they will both implement this interface. Inside of here I just need to define the members that this interface will enforce in the concrete types. I know one thing I want to be able to do is to get all the restaurants out of the ultimate data source. So I'm going to define a method GetAll that will return a restaurant, IEnumerable of restaurant, and I just need to bring in the namespace, OdeToFood.Models. And now I need InMemoryRestaurantData to implement that interface. So I need a GetAll method here. Let's maintain as a private field a list of restaurants, let's call that Restaurants, and in the constructor for this particular class, we can go ahead and initialize restaurants to a new list of restaurants, and also populate this list with some initial restaurants. Now I do want to caution you that anytime you use something that is just a list of something, like a list restaurants, this list collection is not thread safe, so you have to be careful using it in a web application, especially if you're going to share this service across multiple requests. But I'm going to assume that we only use InMemoryRestaurantData when we are developing or when we're testing, so we're not going to have to deal with multiple users when this service is actually being used. When we actually deploy the application, we'll be using a real SQL Server, and a database can handle multiple users easily. But we have restaurants initialized to a new list, and let's add some restaurants in here. So one restaurant with an ID of 1. The name could be The House of Kobe. Let's have another restaurant, Id of 2. Let's give this name LJ's and the Kat. And one more restaurant with an Id of 3. Let's give this restaurant the name King's Contrivance. So we're going to hold these three restaurants in memory and all the GetAll method has to do is return that list of restaurants. Now I want to be able to use this service in my controller, but I don't want the controller to instantiate this class directly. I don't want the controller to know about the InMemoryRestaurantData service or the SQLRestaurantData service. I just want the controller to program to an interface, IRestaurantData, and this is going to be easy to do. It's going to be very similar to how we configured and used the GreetingService earlier. The Greeter service moved to a different namespace, but if I press Ctrl+Period, Visual Studio can add the using statement for OdeToFood.Services to Startup.cs for me. So we're inside of the ConfigureServices method where we configured our GreeterService, we added configuration so that we could inject an IConfiguration anywhere we need it. And now I'm also going to tell the MVC framework that I want to add a service with a scoped lifetime anytime you need IRestaurantData, but right now instantiate the InMemoryRestaurantData. You might remember that when we use AddSingleton, that is telling the framework there should be one instance of this service for the entire application, and so every method and every component that needs an IGreeter, they will have the same object injected. The scoped lifetime is a way of telling the framework that there should be one instance of this service for each HTTP request. So if I have three different pieces of the application that need IRestaurantData, during a single HTTP request, all three pieces of the application will see the same object. But when the next HTTP request arrives, there will be a new restaurant data instantiated for that request. This is going to prove useful when we start using the entity framework in SQL Server as we'll see later in the course. But for now I'm going to save Startup.cs and with that service registered, I will now come to my HomeController, and what we can do is have a constructor, and I can ask for an instance of IRestaurantData inside of my constructor. We will call this restaurantData. And I will bring in the namespace OdeToFood.Services, and I will save the restaurantData parameter into a private field that I'm about to generate with Visual Studio. We'll call that _restaurantData. And so now the controller doesn't have to know about the concrete service that is implementing IRestaurantData, but because I have a constructor that requires something that implements IRestaurantData, the MVC framework will be able to take a look at this when it needs to instantiate this HomeController. It will use the services that have been registered, figure out what should be passed in anytime there's an IRestaurantData, and so ultimately what my controller will receive right now is this InMemoryRestaurantData class that we wrote. And since I've saved that off into a private field, I should now be able to say my model equals restaurantData. Please give me all the restaurants. Now I just want to show you what happens if I come over to my view and refresh. You might remember we use the @model directive to tell the view engine that the model it should expect to receive is a single restaurant, but now we are passing in a collection of restaurants, an IEnumerable of restaurants, so I have a runtime error. The model item passed into this view is behind the scenes a list of restaurants, but we expected a model of type restaurant. And since I do want this view to display a collection of restaurants, I need to go into the view and fix this up. So I will say that the model type will be IEnumerable of restaurant, so even though it is a list behind the scenes, I'll just ask for IEnumerable, that can be many different types of collections, and IEnumerable gives me everything that I need, because all I really need to do here is loop through those restaurants. Since we don't have a single restaurant, I'll just display a welcome message for now. And what I want to do ultimately to start off with is to display my restaurants in a table. So one table row for each restaurant. So in Razor, there is a very easy way to loop over things that are in your model or your model itself, and create HTML for each item in a collection. Here I have a table row, I want to repeat that table row once for each restaurant, so I can write a foreach statement, again using the @ sign to switch razor into C# mode. Now I can foreach restaurant in the Model property, and I can specify code block. So an opening curly brace and a closing curly brace. We'll be talking about Razor in a lot more detail later in the course, but Razor is smart enough to switch into C# mode when it sees the @ sign. It's smart enough to switch back into HTML mode when it sees the opening tr tag here, and it's smart enough to know that this is a closing curly brace and then we're back in HTML again with the closing table tag. And what Razor will do is stamp out a copy of this tr tag once for each restaurant that is in my model, and for each restaurant I want to write out the restaurant.Id, and you can see I still have IntelliSense here, and let's have another td tag where I write out restaurant.Name. So very easy switching between HTML and C# code. This is a block of code, this doesn't write anything into the output, it's an @ sign followed by a statement and an opening curly brace. That will be a block of code. You can have if statement, you can write foreach statements. At sign with an expression, that's going to write something into the output inside the HTML where that expression appears, so here I'm writing out the restaurant.Id, here I'm writing out the restaurant.Name. Let's save everything, come back to the browser, and although we don't have the prettiest user interface, we do have a table with our three in memory restaurants displayed. And so now we've seen how a controller can build a model and how the controller can take that model and hand that model off to a view, and how a view can take that model and render information inside of HTML about the model. The beautiful thing about this example is that later in the course we'll be able to switch over to using a SQL Server database, and we will not have to change any of our controller code or any of our view code. That typically indicates that we have a pretty good architectural design, as well as a good separation of concerns.

Summary

In this module we learned about the model view controller design pattern, and began to see how different components work with each other to process an HTTP request. The controller receives an HTTP request, and it works to build a model. The controller then selects a view to render that model, and the view renders HTML and places that HTML into the response. In the rest of this course, we'll continue working with this MVC design pattern and dig into some details on views and models to show and edit data.

Models in the MVC Framework

Introduction

Hi this is Scott, and in this module we're going to take a closer look at Models in the MVC Framework and working with data in general. We will look at the concept of a ViewModel, both input and output ViewModels, as well as how to work with the Entity Framework to save our restaurant information into a SQL Server database. To get started, let's talk about the concept of a ViewModel.

Models and View Models

Quite often in MVC development, you find yourself in the following situation. You have an application with a database to store data, and that data could be users, restaurants, movies, invoices, whatever's important to your business. When you store something like a restaurant in this database, the database will require and store specific pieces of a data. For our restaurant imagine we're storing the restaurant name, the address, and the type of cuisine that the restaurant serves. Now somewhere else in the application, you might need to build a view to edit the restaurant information that is stored in the database. The edit view will also have some requirements. It will need the name of the restaurant, the address, and the cuisine type, so that the view can display these attributes and allow the user to edit the individual properties of a restaurant, but an edit view typically needs more data than what the database even stores for a restaurant in a single table. For example, the edit view might want to create a pick list for the cuisine type, and the view will need to build this list by fetching all the possible cuisine types that can be stored in the database. So when we query the database for a specific restaurant to edit, we only get the restaurant data with the current cuisine, not a list of all the possible cuisines. And it's in situations like this where I think of two different model objects. One is what I call the entity model. An entity is an object that I persist into the database, and an entity model typically looks just like my database schema. If the database stores just the name and address for a single restaurant, my entity also stores just the name and address. The other type of model object I think about is the ViewModel object. A ViewModel is an object that I use to carry information from a controller into a view. It contains everything that a view will need to render its HTML. So in the case of an edit view for a restaurant, I need a ViewModel that contains not only information from my restaurant entity with the name, the address, and the cuisine type for a restaurant, but also the additional information that the view needs, like the list of all possible cuisines. Quite often this requires the controller to make multiple queries and pull back multiple entities to build this ViewModel and put all the information inside that ViewModel that the view needs. And that's why sometimes we call a ViewModel a DTO, or data transfer object, because this ViewModel carries information around. We don't persist the DTO, we don't save the DTO into a database, but we do often copy information into a ViewModel from an entity, and from a ViewModel back into the entity so we can save something in the database. Moving forward then, what I want you to think about is that there's two different types of models that you can use in the application. The entity model and the ViewModel, and they serve different requirements. One is focused on the database, one is focused on the views. Thinking this way can often make your application a little bit easier to build. Let me give you a concrete example. Currently in the application, our homepage displays a list of restaurants from the restaurant data store. But let's imagine that the homepage needs to display additional information. Not only do we need to display this list of restaurants, but we also need to display today's current message. These restaurants might come from a database, and the message might come from a different data source, like a configuration file, but regardless of the different data sources involved, what my home controller is going to need to do is put together all of that information into a single model to provide the view with all of the data that it needs. To pull this off I'm going to need to do a little bit of refactoring of what we have so far, because currently our ViewModel is just a list of restaurants, and we need to get the current message in there. And this Restaurant class that we're using, I really want to think of it as an entity, it is something that I persist in the database. It might be a relational database, it might be a document store. Regardless of where the data is stored, I do want to think of the restaurant as an entity. To make this more explicit, I'm actually going to rename the Models folder to Entities. This will be all the entities that my application requires in this folder. In larger applications you might have a separate project or even multiple projects to contain your entities. But I'm also going to open up the Restaurant class and change the namespace here from Models to Entities, because I do like to follow the .NET convention where the directory structure matches the namespaces structure. So, instead of OdeToFood.Models, it'sOdeToFood.Entities. That means I'm going to need to change some of the using statements that are in the application, but we will make those changes as we come to them. I'm also going to add a new folder to this project and call this folder ViewModels. The idea is that the different ViewModels that all my views will need, they'll be placed in this folder, and again, in a larger application, you might need to divide up your ViewModels into multiple folders inside of here, perhaps, have a folder for each controller, just like we do with the views. But I'm going to keep things simple in this application and really just want you to focus on the concepts. There's entities, and there's ViewModels, and these two categories of objects, they serve different purposes. One is for persistence, that's entities, and one is carry information into the view, that's a ViewModel. Inside of the ViewModel's folder, let's add a class. I'm going to call this the HomePageViewModel. And again, in a larger application where you are placing ViewModels into folders, you could take an approach where there's a home folder and inside of that there's an index ViewModel, something that matches the name of the view, but let's just work with HomePageViewModel. What information does the view need that is for the homepage, the index view? Well, I do need to know that I need to pass along the CurrentMessage of the day, and I'm also going to need a property to carry along the list of restaurants, all the restaurants in the database. Let's make that an IEnumerable of Restaurant, and I will call that property Restaurants. Now I am going to have to bring in the namespace, OdeToFood.Entities. We'll do that here. We'll also remove the namespaces that we are not using, remove some extra white space, and that's the ViewModel. Next let's swing over into the HomeController, close this file off. Over in the HomeController my model is no longer going to be this list of restaurants. Instead I'm going to instantiate an instance of HomePageViewModel, which means I need to bring in the namespace OdeToFood.ViewModels. Let's come up here to the top, remove OdeToFood.Models, that's no longer being used. And now I can populate my new ViewModel. So model.Restaurants, I know where the restaurants come from, that's from restaurantData, that service, I can ask to get all the restaurants. Currently I'm going to have an error here. I do need to come over into restaurantData and fix up a few things. Since Restaurant moved from Models to Entities, I'm going to need to bring in a using statement, OdeToFood.Entities. Over here I can also remove OdeToFood.Models. I can remove the other unnecessary usings. Let's close that service off, go back to the HomeController. We now have all the restaurants in our ViewModel. Now we just need to populate the CurrentMessage. Where do we retrieve the CurrentMessage from? I know I have a service out there, the service that we created very early in this course, and that was the IGreeter service. I'll call this greeter. Just like I do with restaurantData, I'm going to save that greeting service off into a private variable. Let me generate that with Ctrl+Period. We're going to generate a field, a private field, to hold that greeter service. And now for the current message I can say, let's just go to to the greeting service and ask to get today's greeting. So now the controller has constructed the ViewModel using a few lines of code and a couple different services. The controller is going to take that model and pass it off to the Index view. Now we just need to fix up a few things over in the Index view. One thing I will need to change is that we no longer take an IEnumerable of restaurant. Instead we're going to take that homepage ViewModel. So that model directive should say that the model type is going to be OdeToFood.ViewModels.HomePageViewModel. Here underneath the h1 tag let's add an h3 tag that will go to the Model property for this view and display the CurrentMessage. And now the restaurant information that I need to loop through, that's no longer the model. Instead I need to drill into the model and go to restaurants, but that should be all the changes that I need to make in the view. Let me save all the files in the project, come over the browser and refresh, and we now have not only our configurable hello message, but we also have the list of restaurants. What I'm trying to demonstrate is in this world of ASP.NET MVC, there's actually a few different ways that you can information from a controller into a view. I don't have time to give you an exhaustive list of all the different techniques, but a common technique that you'll see is to use the concept of a ViewModel, that is, an object that is dedicated to carrying all the information that a view needs, so that the view itself doesn't have to work very hard. It has all the information available; all it has to do is write out its HTML, and poke pieces of data into the right spot. And this is a technique that I can recommend, you build ViewModels for your views, and have ViewModel classes contain all the information that you need to shuttle from the controller into the view. This is a very simple demonstration of that technique, but you can extrapolate this example to ViewModels that are very complex.

Detail a Restaurant

Now that we know a little bit about ViewModels used as outputs, let's talk about models that are used as inputs to a controller action. Imagine we want to give the ability not just to see a list of all the restaurants in the database, but also to see all the details for one specific individual restaurant. This will be a different page in the application, which with the MVC framework means I'll need to create another controller or another controller action in another view. Since we are going to be showing the details for one particular restaurant, let's create an action named Details that will return an IAction result, and the first question might be how will this action know which restaurant the user wants to see? Well, when we start using a database later in the course, I plan on the ID property of a restaurant being the unique identifier for the restaurant, which means if I can get an integer value into my Details action, the action should be able to use that identifier to look up the restaurant that the user wants to see. Now the next question would be where does the Id come from? Let's temporarily return just a string from the Details action, and I will show the value that has arrived at the Details action by returning id.ToString. We'll be able to see what Id arrives here. And we know because of our routing rules that we have setup, that if we go to /home/index, that's the homepage that we're on here, but if I go to /home/details, that should reach this details action and I'm going to go ahead and put a 4 here into the URL, and we'll see a 4 come out in the browser. How did the MVC framework get a 4 from the URL into the Details action as the ID parameter? Well, whenever you have an input parameter or an input model to an action method, the MVC framework will do everything in its power to create and populate that parameter. The framework will look around in the request environment to find something with the same name as this parameter. And because I named this parameter id, the MVC framework is looking for something named id in the request. And because this value appears here, this value 4 is in the URL, it's in the path, that means that because of our routing configuration, the MVC framework is treating that piece of data as something named id. Remember we set up our route to say have a controller name, slash an action name, and then slash something else, and if that something else appears, we will treat it as a parameter named id. This id will go into what we call the routing data of an MVC request, and that is one of the places where the MVC framework will look to see if there is something named id, and it's finding that value, and it's able to use that id right from the URL. The framework also looks at query strings, it also looks at posted form data. We'll see examples of posted form data later in the course. For right now I want to take the 4 out of the URL and instead have the query string id=5. Now the Details action sees a 5. You might remember I was telling you earlier that quite often you don't need to go into the HTTP context property in a controller and look at the request object to find something in the query string or in the headers. You can setup the MVC framework to identify data that's in the request and just and hand it off to you. Things that are in the route or the query string or posted form data, you can receive those items as individual parameters to an action very easily. You can also receive complex parameters, so Details just needs an integer value, but I could take a restaurant here. We will see that in just a bit. If I did have a restaurant, the MVC framework would create the restaurant and try to populate the restaurant object with things that it finds in the request. Now you might be asking what happens if the MVC framework finds two value for id? In other words, what if I went to /home/details/4, and then query string id=5? Do we get a 4 or a 5, and the answer is we get a 4. It just so happens that it is an implementation detail that the MVC framework will favor something it finds in the routing data and use that before it finds something that it uses in the query string. But now that we have this id parameter arriving, let's actually use it to retrieve the movie and display the movie the user wants to see. In the controller action let's go back to returning an IActionResult, and what we want to do is find our model. Now I will expect that I should be able to use restaurantData to get my model. I'm just going to call a Get method that is not implemented yet, but I expect if I pass in an id parameter I will be able to retrieve a single movie. Let's go over to the service, the restaurantData service, and add a method on the interface definition Get that takes an id parameter and returns a restaurant, and now add that, I'll use Ctrl+Period, add that method to the service itself. This can be a very easy link query. I'll just return Restaurant, and then use the FirstOrDefault operator. In order to be able to do that, I need to bring in the System.Linq namespace. I'll also do that with Ctrl+Period. And now I can write a lambda expression that says given a restaurant r, if r.Id equals the incoming id, that is the restaurant we want to return. If you're not comfortable with Linq operators, I do have Linq Fundamentals course, but those of you that use linq might know that FirstOrDefault, if it doesn't find something that matches this predicate, it's going to return the default value for the restaurant type, which will be a null reference. We'll deal with that in just a bit. But over in the HomeController, I just want to return a view with that model, which means in addition to the Index view that's in the Home folder, I'm going to need a detail. So let's add a new item, I'm going to find the MVC View Page entry, I want something called Details.cshtml, and I'm not going to create a full HTML page this time. Later in the course when we talk about Razor views, we're going to see a way to make sure that all of our views are producing valid HTML pages with head tags and body tags and so forth, but right now I'm just going to emit enough HTML to know that this is working. And then when we get to Razor views, we'll fix this up. So first of all, I will use the model directive to say that we are about to receive an OdeToFood.Entities.Restaurant. So in this case, yes, I am using an entity as a ViewModel. With this entity it does give the view everything that it needs to know. And let's just create an h1 element and display the name of the restaurant, and then eventually we'll have some more details here. Maybe we can wrap that in a development. So now if I come over to the browser and ask for the details of the movie with an id of 2, I do see LJ's and the Kat, and if I go to /1, that's The House of Kobe, everything looks like it's working. What if I go to /22? That is a movie that does not exist. In this case, I'm getting an exception, because FirstOrDefault returned null. It didn't find that movie. Therefore, I passed in a null restaurant to my view, and inside of the view when I tried to dereference that pointer and say Model.Name, that threw an exception. How can we handle this scenario? There's several different strategies. One strategy would be to actually go into the view and have an if statement. And I could say something like if Model is null, then we could display to the user something like sorry, but we couldn't find your restaurant else, only then would we output @Model.Name. That would be one approach. Another approach from the HomeController would be to deal with null values here. I could say if model came back as null, now what do we do? Well, there is, it turns out, a NotFound result, that implements IActionResult, but NotFound result, it's really geared towards APIs. All it's going to do is produce a response that has a 404 status code telling the client something was not found. On high-end professional websites you typically don't want the user to see a 404 error in the browser. Typically you want to send them somewhere else or have them do a search or display some sort of friendly page instead of just an error. So one way we could do that is to return a redirect result. There's a number of different redirect results inside of the MVC framework. They all represent HTTP status codes of 301 or 302 to tell the browser to go somewhere else, issue a GET request for this other resource, and what I could tell the browser to do with a RedirectToAction, is to temporarily redirect to this other action that has the following name. I want to go back to the Index action. I pass that as a string. This RedirectToAction method, it takes a number of different parameters. If I want to go to an action on a different controller, I can do that. I can also pass along routeValues. I'll talk more about them in just a second. Also I should point out that with C# 6, I can use the nameof operator to say give me the name of this member called Index, and that will return the string Index for me. That way if I ever change the name of this method, it will be easy to refactor the code and either have the method name changed here or generate a compiler error. But now if I come into the browser and I issue a request for /home/details/22, I end up back on the homepage, because my web application had a response that told the browser to go over to this other URL. And now that I'm looking at this list of restaurants, I want to provide an easy way for the user to navigate from this list of restaurants to one specific restaurant to see the details. I don't expect them to type into the address bar of the browser, instead I would expect since this is a web application, that the user should be able to click some link and then go to the page that shows the details for a specific restaurant. That means I need to add a link in index.cshtml. Let's have a link here instead of displaying the restaurant ID, because typically the user doesn't care about the ID. Now I want to show you two different techniques to generate this link in this clip, and then later in the course when we talk about Razor views in more detail, I'm going to show you the tag helper approach to building the link. That is probably the preferred approach moving forward, it's a new feature in this version of ASP.NET MVC. But if you're looking at any existing MVC code, you're going to see one of the following two techniques that I demonstrate right now. The first technique is just to write HTML. I know I want an anchor tag, I know that anchor tag will need an href. Let's display the text details to the user. What would my href be? Well, I know if I go to /home/details, and then the restaurant.Id, that should allow them to see the restaurant. Let's just test that out real quick. I'll refresh the browser, we can get to The House of Kobe, we can get to LJ's and the Cat, we can get to King's Contrivance, so that works. But here's another approach. I'm going to use another property that is available inside of a Razor view, so in addition to Model, there's also Html. Html, this property gives me a collection of what we call Html helpers. These are methods that I can invoke that will build small snippets of HTML for me. Some of them are incredibly useful. I'll be honest, I don't find the ActionLink always incredibly useful, but I do want to demonstrate how to use it. ActionLink is a method that I invoke and I pass in some parameters, and it's going to build an anchor tag with an href attribute. It's going to build that href attribute by using some information that I give the ActionLink method and consulting with the routing rules that I've defined for this application to build the proper href. In other words, if I hard-code URLs like this, and then I ever go in and change the default routing rule for my application, this link could break. If I generate the same anchor tag using ActionLink instead, there's a good chance that I can change my routing rules and the link will never break, because ActionLink will always consult with the routing rules to generate the proper link. So ActionLink, there's seven different overloads of this method, and I need to pass in the first parameter, which is the text to display. Let's actually change this from Details to View. That is the text that I want to display to the user. And now I tell the framework what action do I want this link to point to when the user clicks on it? I want this to go to the Details action. I can also pass in a controller name. So if I want to jump to the action on a different controller, I can do that. Here this view was rendered by the HomeController. I just want to go to this other action on the same controller, so I don't have to specify the controller name. I do have to specify some route values. These are the parameters that ActionLink will use when it consults the routing engine, and figure out what is the URL that we need to generate so that we can properly pass along information in the route. In other words, the Details action, it needs an ID value to arrive in the routing data, or somewhere in the URL, and these route values that I can pass into ActionLink, any properties on the object that I pass in here will be placed into the URL. So the syntax is a little bit funny here, but if I create a new anonymously typed object and give that an object an ID property and set it equal to restaurant.Id, that's going to give ActionLink enough information to say, ah, you want to Details action on the same controller and pass along an Id value of whatever this is, a 2, a 3, a 4, a 1. ActionLink will go to the routing engine, the routing engine will give it a URL that will reach this destination and pass along the correct data, and then ActionLink will build the anchor tag and use that URL in the href. We should be able to see that now. If I come back to the browser, this second link is the one created by ActionLink, so I can now view King's Contrivance, that's good. Might also be nice to have a link here so that the user doesn't have to press the back button, so over on Details.cshtml, let's create another div and use html.ActionLink. I will display the text Home, and I want to go to the Index action when the user clicks here. I don't need to pass along any route values. The index action doesn't need any additional information. I should just be able to save this. Now I have a link that goes back home. And now we're seeing a little bit about how actions can coordinate in the MVC framework. If you need to jump from one action to another action, one way to pass information between those two actions is to use routing data, which can be data that's in the URL or even the query string. Next up we're going to look at form data, which can represent very complex model information. And once again I'll just remind you that when we get to Razor view later in this course, I'll show you another approach to generating links using the new feature of tag helpers. Now one more question you might have is can I use name of inside of a view, and the answer is yes. If you don't like to have hard-coded strings in your view, if you are afraid that you might refactor a controller and change a method name and then suddenly your links break, because the index action doesn't exist anymore, well, one thing I could do is add a using statement here, which is just like a using statement in C#. I want to use OdeToFood.Controllers, because I can say here let's here use nameof HomeController.Index. And this will generate the same link that I had before, but now it's a little bit safer.

Create a Restaurant

What we want to do next is see how to create a new restaurant. With HTML anytime that you want to give the user the ability to enter data into a page, you will use an html form element. How will we build the form? Well, like everything else with MVC, we will have an HTTP GET request that gets routed to a controller action, and this controller action will return a view that includes a form tag. So to create a restaurant or edit an existing restaurant, we will need an action that returns HTML with a form inside. And inside the form, we will have input elements to enter text and numbers. We might also have check boxes and dropdown list and sliders. There's a variety of input controls in the browser these days. And we'll need to make sure each control has a name, so that MVC knows how to process the incoming data when it comes back to the server. Ultimately the form needs to use an HTTP POST operation to send the form data back to the server. And on the server we can process the incoming POST with another controller action. We'll see how MVC can map incoming form values from our inputs into a model object that is a parameter to our controller action. All we have to do is follow some easy naming conventions. Let's see how that works. Let's make this creation scenario just a little more interesting by adding some additional attributes to a restaurant. Actually, I just want to add one additional attribute. I also just noticed that the namespace has a typo in it, it should be an i here. There's an easy way to fix this. I can add the i, then press Ctrl+Period. Visual Studio can go through all the rest of the code and make sure that namespace is correct. And now instead of adding a simple type like a string or an integer, let's make things more interesting by adding an Enum property to the restaurant. And this Enum will be and represent the type of cuisine that a restaurant serves. Let's have Enum values of None, that will be the default, that represents a restaurant where we don't know the cuisine type perhaps, and then we can have Italian, French, let's add in Japanese, and American. Now, on the restaurant I can add a property of type CuisineType and we will call that Cuisine. So in addition to allowing the user to edit the name of a restaurant, I also need the ability to allow them to set the cuisine type of a restaurant, and in order to do this, I need to give them a form, or what the user will see is a new webpage. And of course, a new webpage needs a new action and a view. Let me create an action result returning action, and we can call it create, and it's going to create a restaurant, and for right now just return a view. Since I'm creating a restaurant, I'm not going to pass in a model object, I don't have a model object to give the view. The view will just receive a null reference for the model property, and that's okay, although there are many scenarios that will require a model. Quite often when you're creating something, you'll need to provide some information on the page that allows the user to pick from a number of different options. Or perhaps you have some default values for some fields. Those are the types of situations where you can build an edit ViewModel and populate that model with information that the view needs to display the correct form. Our scenario is a little bit simpler. And even though the user is going to have to pick the type of cuisine, I'll show you that we have enough information to do that. All I need is a Create.cshtml view. So let's go to the View's Home folder add a new item. Once again, an MVC View Page, but this one will be called Create.cshtml. And once again, I'm just going to create an HTML fragment. Later when we get to the Razor view section of the course, I'll show you how to plug in the fragment from this page into a larger structure that will add the head tag and the body tag and all the rest of the HTML infrastructure that we should really render and send down to the client. For right now though, just something simple. I'll have an h1 element that says Create on the page, just so we know we're creating a restaurant, and then I can display a form. I will warn you up front that this will not be the prettiest form. You can find lots of articles and videos about styling forms. We're just going to create a basic form that allows the user to create a restaurant. One way to do that is just to type html. So you can have something work in ASP.NET MVC. If you just create the form tag yourself and set the appropriate method, which would be post, and the appropriate action for where the form should post back to, which in our case will be back to the create action of the HomeController. But I'm going to show you how to use HTML helpers. So that HTML property that's on a view, we've already used HTML.ActionLink. And again later in the course when we talk about Razor views, I'll introduce you to tag helpers. Many people prefer tag helpers to HTML helpers, but I want to show you both. There's many examples and a lot of documentation out there that uses HTML helpers. I want you to have some understanding of what they're doing. So the first HTML helper I'm going to use is an HTML helper called BeginForm. This HTML helper is a little bit odd in the sense that it actually returns an object that implements IDisposable, so the using statement that I have here, that's the using statement that C# provides. You can have an expression that returns a disposable object and what using will do is automatically call dispose here down at the closing curly block. And the way BeginForm works is that when I invoke the method, it will write out the opening form tag, and then when we hit the closing curly brace and dispose is called, that's when that object will write out the closing form tag for me. So I have an opening form tag and a closing form tag here with BeginForm. And there's many parameters that I can pass into BeginForm if I want this to post to a different controller action, or to issue a GET request instead of a POST, those were all behaviors that I can influence with parameters to that method, but we're going to take the defaults. And now I need my inputs. So for example, I need an input where the user can type in a restaurant name. Once again, I could do that with an input type equals text, but I'm going to use another HTML helper, an HTML helper called TextBoxFor. The idea behind TextBoxFor is that this TextBoxFor will write out an input tag for me, and it will set various attributes of that input tag like the name and the value according to information that is in the model. Now we're not passing a model to this particular view, so the model property will be null, but that's okay. These HTML helpers, they know how to deal with a null model. But what I need to do in order for this to work appropriately is to use @model, the lowercase version, the model directive, to tell this Razor view about the type of the model, so the type of my model is OdeToFood.Entities.Restaurant. That's the type of model that I want to work with, even though I'm not passing one in. What that allows me to do here is TextBoxFor, this expects a lambda expression. A lambda expression that will point to the property that you want a TextBoxFor, so this is a lambda expression that takes one parameter. You can see the type of this parameter is Restaurant. The type of the parameter is always going to match the type of the model. And then I simply write an expression that basically points to the property that I want. So in this case, I want a TextBoxFor the name of our restaurant. If I did pass a model object into this view, TextBoxFor would be able to look at the name property of the model, retrieve the model that's inside of there, and set it as the value for this input, but since I'm not passing in a model, what TextBoxFor will do is just look at metadata about that particular property. It can look at the type of the property, it can look at the name of the property, which is Name, and it can set the input values appropriately. I'll show you exactly what this is doing. Once we have the page up and running, we can inspect the HTML. There is also an HTML helper to build a label for a property. So here I want to build a label for the restaurant name. And if I save this view and refresh the browser real quick, what we'll see, once I go to /home/create, I have a label displaying the text name, I have an input where I can type in the restaurant name. This is looking good. The next thing that we will need is to be able to set the cuisine type. So let me also create a LabelFor, and goes to m.Cuisine. So just picking properties off of my model using these HTML helpers, and now I need some sort of input where the user can select a cuisine. I don't want them to type in the name of a cuisine, I want them to be able to pick a specific cuisine that I have defined. So in this case I'm going to use the DropDownListFor helper. This builds an HTML select element with options inside. And I can say I want a DropDownListFor the Cuisine property of a restaurant. And again, if I was editing a restaurant, this HTML helper would set the initial value of a dropdown to the value that is in the restaurant, but this helper also needs some additional information. It's going to need a collection of SelectListItems. These SelectListItems represent the options in the HTML select. And this is one of those scenarios where sometimes you need to build an EditView model to pass this information into the view till the view has all the information available that it needs to build the pick lists or the dropdown for the user. But if you are using an Enum type like we are here, there's another option. And that is another HTML helper, which can take an Enum type and reflect over it and build a select list for me. All I need to do is use GetEnumSelectList and pass in the type of Enum that I want to reflect over. So I'm going to have to specify CuisineType here, only here in the Razor view I will either have to fully namespace qualify that type, like I do here with Restaurant OdeToFood.Entities.CuisineType, or let me just make things simple and add a using statement at the top of the view. So just like we have using statements inside of a C# code file at the top to bring in all the types for a given namespace, I just want to make all the types for the OdeToFood.Entities namespace available inside of this view. That means I no longer need that namespace here in the model directive. Instead I can now just refer to restaurant, and down here I can just refer to CuisineType. And then the last piece of UI that I will need to make available is a button. So, an input type = submit, so that when the user clicks this, the browser will submit the form and all of the inputs back to the server. I will give this a value of Save. That's what will display in the button. And now let's save all the files, come back to the browser, and refresh /home/create. And I now have the ability to input the name for a restaurant and select a cuisine and click a Save button. Let's take a look at the HTML server sent back to us. I'm going to right-click and say View Page Source. And I can see that the BeginForm helper created a form tag. The action for that form tag points back to the action that I came from on the server, so /home/create. But when the user clicks the Save button, what this form will do is issue an HTTP POST back to that same action. I can also see the input for my name and the select where my cuisines exist. And notice the names of my input, so the name on the select is set to Cuisine. That matches the property that this select is editing. Likewise, the input up here for the name of the restaurant, its name attribute is set to name, and so it's matching the property on the model back on the server, and that's a very important convention. We'll see exactly how that works in the next clip. For now I just want you to know that if I was editing an existing restaurant, this view would look almost identical. The only additional piece of information I would really have to store is the ID of the restaurant that we're editing so that we can send that back to the server and the server knows which restaurant we're editing. I could store that inside of my form. Quite often that's done with a hidden input, and there is an Html helper, HiddenFor, which will build an input type equals hidden and store let's say the id inside of the hidden input. We don't need that when we're creating a restaurant. Now in the next clip what we're going to do is see how we can actually process the information that the user sends back to the server.

Accepting Form Input

Now we are ready to post our restaurant to the web server. And this POST request, we want it to reach a controller action that has an input model as a parameter to the action. As I've said before, the MVC framework does everything it can to populate your action parameters based on information in the Http request environment. Remember earlier we created a detailed action with an Id parameter, and the MVC framework populated the Id parameter with the Id from the route data. It also worked when the Id parameter was in the query string. For complex input types like a restaurant, MVC will look at the properties on that type and map route data, query string, and form data into the properties of your input model. If we post a form with Name and Cuisine in the form data, the framework will automatically map those values into their respective properties by name on the input model. So if the restaurant model object has a Name property, that property will receive the name value from the posted form values. You do have to be very careful when selecting an input model, because the framework will by default try to set all the properties, and you can never, never trust data coming over the network. You might have a malicious user who tries to set a property that you didn't expect. We'll talk about that more in this clip and see how it works. Inside the application, let's go back to the HomeController, and we know from looking at the page source that what the form is programmed to do is to do an Http POST back to /home/create. In order to accept that request, I'm going to write a second version of the create action, only this one's going to take an input parameter. So this first create returns to view with a form, the second create is where I want the form to post to. And inside of here I could use a restaurant as my input model, and to do that I'll need to bring in the namespace OdeToFood.Entities, but I do want to caution you, you have to be very careful about your input models. If you have an input model with 5 or 10 properties on it, but you only expect to populate two of those properties from a form, there's always a chance that there might be something in the network request that tries to populate some of those other properties, properties that you didn't expect to receive. And some of those properties might be protected, they might be properties that you never want a user to be able to set. And that's because the MVC framework is doing what it calls model binding. It's trying to bind information that's in the request into your model. And it doesn't matter if that model is a simple ID or a complex type like a restaurant, the MVC framework is going to look at this restaurant object and do everything in its power to try to set every property on that object. And for that reason, it's often better to create a ViewModel with just the properties that you expect to receive over the HTTP POST, just the properties that you have inputs for in your form. So let's go into the ViewModel's directory, and I'm going to add a class, let's call this the RestaurantEditViewModel. And I know in my form I have essentially two things that the user can set. They can set the name of the restaurant and they can set the cuisine of a restaurant. And the name of the select and the name of this input type equals text, they will be set to Cuisine and Name. And as long as I have an object as an input model with properties that match these names, Cuisine and Name, the framework will move information into those properties for me automatically. So let's give the RestaurantEditViewModel a Name property to receive the name, and let's also give it a Cuisine type, which means I will need to bring in the namespace, OdeToFood.Entities, and name this property Cuisine. I can remove some of the unused usings here. Let's save that file, close that out, come back to the controller. And I want to use here the RestaurantEditViewModel. Let's call that model. And again, this is something I would do in all but the simplest scenarios, just so you don't accidentally open up any security holes. This ViewModel, this input model will contain only the properties that I expect to receive in the Http request. Now we are not doing any validation yet, but I just want to set up the simplest possible scenario to see if we are correctly receiving the information about the restaurant. And what I'll need to do is take the information that's in the EditViewModel and copy it into a new restaurant, so let me create a variable, newRestaurant, and instantiate a restaurant, and then we can say newRestaurant.Cuisine is equal to the incoming cuisine, and the newRestaurant.Name is equal to the name in our incoming model. At this point I would expect to be able to go to my restaurantData source and tell it to add this newRestaurant. We don't have that method available yet, but we will. And now I have to think about what I will show to the user. But I'm going to return the details view. Remember our controller can select the view that it wants to render. And in this case, when I receive the posted restaurant data, I'm going to display the Details view. And again, there's no validation, no error checking yet. We will come to that. There's a few changes that we have to make. We're just going to see if this works. I'm going to pass in the newRestaurant here, and then we'll modify the Details view to display the newRestaurant information. I'm also going to assume that the data source might update this restaurant with some additional information or perhaps even return a new object, so I'm just going to assign the result of restaurantData.Add back into my newRestaurant variable. That's what we're going to render. We'll need to write this method. Let me go to the Details view first. I just want to make sure that we see the restaurant ID, because I would expect the data source to generate an ID for this restaurant. So let's say Model.Id. And I also want to see if we got the proper cuisine type. So let's say that the cuisine is Model.Cuisine. Let me hit Ctrl+K, Ctrl+D to do some formatting in this view, I'll save the Details view. Now we need to make some adjustments to restaurant data. First I'll put a definition for the Add method on the interface, so this will be a method that returns a restaurant and takes the newRestaurant to add to the data. And then I need to implement this method in the InMemoryRestaurantData in this class. So, down here where we Add. One thing I'll need to do is compute a new ID. Before I do that, I'm going to make another change to this InMemoryRestaurantData. I'm going to make the list of restaurants static, that means there will be only one instance of this list for the entire application, and I'll always be looking at the same restaurants. I'll also make this constructor static, so it initializes this list of restaurants the first time we use InMemoryRestaurantData. And, of course, that means that this class is completely not thread safe. You'd never want to use it with concurrent users. I guarantee at some point you will receive an exception or the list will become corrupt, but we're just using this in memory data source until we hook up a database later in the course. For right now I just want to compute a new ID for this restaurant that's been added. One way to do that would be to say that the newRestaurant.Id is and let's look at all the existing restaurants and use the link Max operator to say give me the maximum value that you see for the ID property across all restaurants, and then add one. That will be fine for this class, but really just a development and test data source. Then I can actually add that restaurant to my list, and then let's return that new restaurant that we have modified. Now I'm going to make sure that I save all the files, and let's try to refresh the browser and see what this form looks like now. And what I receive here is an exception. The reason I'm seeing this exception is because the MVC framework has determined that I want to go to the HomeController and invoke the Create action, but unfortunately multiple actions match that name. We have two Create methods in the code. And as a developer I know that this version of the Create method should return the form and respond to a Http GET request, while this version of the Create action should receive the form POST. But the MVC framework's not going to be able to figure that out. Even though there is restaurant information in the request, I have to provide the MVC framework with some more information so it can select the proper method here. The way I can do that is to use what's known as route constraints. These are attributes that you can place on a route on an action. And the particular constraint I'm using here is restricting this version of Create so that it only responds to an Http GET request. That is the type of request that would be issued when I refresh this page or when I go to this URL. This version of Create I only want to respond to an Http POST operation. That should only happen when the user clicks the Save button and the form creates an Http POST back to the server. So with these two attributes in place, let's save the HomeController, come back out to the browser and refresh. Now we have our form, let me enter the name of a restaurant, let me use Sabatino's. We will make this an Italian restaurant. I will click Save. And I am looking at the Details view. It does look like we have successfully placed that restaurant into our data source. I see the new generated Id as 4, the cuisine is Italian. This is all good. If I go Home, Sabatino's also now shows up on the list. And everything is looking good. Let me go back to the Details view, just to show you that we are on /home/create, but because the Create action rendered the Details view, I'm looking at the Details view. And although it looks like everything is working, we do need to add some validation, and there's something else that we need to do to improve the experience for the user. Let's look at that in the next clip.

POST Redirect GET Pattern

At this point I want to introduce you to or remind you of the POST REDIRECT GET Pattern for web applications. Currently our client, the browser, has a form that will use an Http POST method to send new restaurant data to the server. And currently our server responds immediately with the details of the new restaurant. But responding to a POST operation with an Html page can cause troubles, because if the user decides to refresh the browser, the browser will need to send another Http POST message, which will try to add the restaurant to the data store again. It's a common practice in web applications that when you have a successful POST operation, you respond to the POST with an Http redirect status code and tell the browser to send a GET request to read the new data from another location. Remember, POST is for write operations, and GET is for read operations. The POST redirect GET pattern ultimately delivers a page to the user that they can read, a page that the user can bookmark and refresh at any time without trying to write new data by refreshing the form and resending a POST operation. Let's see how easy it is to follow this pattern in our application. In the browser where we last left off, we were looking at the rendering of the Details view, but this was rendered by a successful post to /home/create. If the user tries to refresh this page to update the view, even the browser knows that there might be a problem. I see a warning message. Refreshing the result of a POST operation can lead to duplicate restaurants, duplicate transactions, charging my credit card twice, it is generally a situation that we want to avoid. Fortunately, it is easy to avoid this scenario. Instead of responding immediately with the Details view from my Create action, it is much better to send back a redirect response and tell the browser to go to some other URL and issue a GET request. From there the user can view the details of the restaurant. And this is as easy as instead of returning a view, returning a RedirectToAction result. The action that I want to go to is still the details action, but now instead of rendering that view directly, I'm sending back a response that tells the browser to issue a GET request for /home/details. But I do need to include enough information for the browser to issue a GET request to the correct details URL, and that means I need to include the restaurant Id somehow. Now earlier when we used the HTML helper ActionLink to build an anchor tag that included the Id of a restaurant, just like that scenario, this RedirectToAction method includes a parameter where you can pass in route values. So once again, I need an object that has an id property, and I will set that to newRestaurant.Id. And I can actually add as many properties as I want to this anonymous type. All the property values will be bundled up and presented in the URL somewhere. My routing rules allow for an Id parameter to appear in the path of the URL, so we'll have something like /home/Details/4, but if a parameter doesn't fit into the URL, the MVC framework will place that parameter into the query string. So I can have as many parameters as I want, but in this case all I need is an ID. Let's save this controller, come back out to the browser, let me issue a fresh GET request for /home/create. I come back to my form. Now let's enter the Airport Inn. I will give this a cuisine of Italian and Save. And now I can see I'm redirected back to /home/Details/4. The Id is 4 because my web application restarted. I lost the restaurant that we added earlier. That problem will be solved when we use the Entity Framework and actually save data into a database. The important part is right now the user can bookmark this page, they can refresh this page, there's not going to be any problem looking at the result of their Save operation. So this POST redirect GET pattern, it is usually the approach that you should use when you have a successful POST operation, but what if the POST operation is not successful? What if the user didn't send correct information to create a new restaurant? And how would we even check to see if all the information is there? Let's talk about that next.

Model Validation with Data Annotations

When the user creates a new restaurant, there are some rules that we want to apply to the data that they give us. For instance, we want the restaurant name to be a required field. One of the easiest techniques for enforcing rules like this is to use data annotations that are available in .NET. Annotations are attributes that we can add to model properties. They are attributes like MinLength and MaxLength, which require your string input to be a certain minimum or maximum size. We can also check the range of a number, match a string against a regular expression, or compare two model values using the compare annotation. That's useful to make sure that the password and confirm password fields are synchronized. You can also write custom annotations to perform your own custom validations. And there are some data annotations that will influence the display of a model value or the label for a model value. These are annotations like Display and DataType. If I tell the MVC framework that a given model value will hold an email address, the Html helper I use to render that input will render an input element where the type attribute is set to type email. On some devices, this will give the user a different type of input or a different keyboard to enter the values into that textbox. Let's add some annotations and enforce model validation in our project. To see how we can use data annotations, let's go back to the view that we used to create a restaurant, which is /home/create, and I'm going to open up the Html Inspector in the Chrome Developer Tools. And what I want to call your attention to is the label that we have inside of here that is currently displaying the text name. Where does that text come from? Well, once again over in our Create view, we said that we wanted a LabelFor this property of the model, so this Razor view is looking at the restaurant, which is our model, and looking at this property to see if there is any metadata here. Currently the only information it has to work with is the name of the property and the type, which is string. We can change that by adding some annotations. Almost all the annotations are in the System.ComponentModel.DataAnnotations namespace, so I will go ahead and add that using. And now you can see that I can bring up annotations like DisplayFormat and Display. DisplayFormat, by the way, is very useful when you have numeric types or DateTime types, and you want to display those in a certain way. So, for example, with numeric types, you can format a number with different currency symbols, you can specify the number of digits after the decimal place, these are all done with the standard C# formatting strings. And then there's the Display attribute. This is where I can say when you want to display a label for this particular field, don't use the name of the property, which is Name; instead, I want to display the text Restaurant Name with a space. This is very useful when you have properties that don't look good in a UI, because in C# we don't use things like spaces in our property names, but now if I refresh the view, instead of having name, we now see the text Restaurant Name. So by default, almost all of these Html helpers will look at annotations for the property that we are specifying to see if one or more of these data annotations exist. You can place multiple annotations on a single property. For some of these annotations to work properly, I need to use a more generic Html helper. There's Html helpers here to create labels, to create TextBox. TextBoxFor is very specific and says I want an input type equals text. But there's another Html helper, EditorFor, where I can say I want an editor for this name, and you choose the best editor. Maybe it's an input, maybe it's something else. And let's see what happens when I use EditorFor and then come back to the restaurant and use an annotation of DataType. With DataType, I can say that this particular field represents a password or a phone number or a time entry or multi-line text. I'm going to choose password just to show you a difference here. Let's save restaurant.cs. Let's watch the input here in the inspector after I refresh the page. And now instead of being input type equals text, this is input type equals password, which means if I type in the restaurant name, I don't see the characters that I'm typing, I just see dots. That's not an annotation that I want to keep here, I just wanted to demonstrate that to you. And so some annotations allow you to modify the display of an input, or how to edit a particular property. Other annotations like Required enforce validation rules for a particular property. So let's add Required and MaxLength of 80 for this particular property. Save. Once again, I want you to watch the input field. It now consists of many more attributes, and some of these attributes would imply things like the MaxLength is 80. These particular attributes exist for client-side validation. We're going to look at client-side validation in the last module of this course. There will be no client-side validation in effect as yet, but what we do need absolutely is server-side validation. We can never trust client-side validation. When I think about enforcing model validation, these annotations aren't so important on the model when I am using that model to render Html, although obviously that changed around some of the output when I added Required and MaxLength annotations for the Name property. I'm going to leave those annotations in place on our restaurant entity. We will later in the course where they have an impact. But now I have to start thinking about my input model, my RestaurantEditViewModel. I can also add annotations to this model, and when I add validation annotations, the MVC framework will automatically apply validation rules to this input model. In other words, if I open up this file, which I can do by putting the cursor there and pressing F12, I can paste in my annotations and bring in the System.ComponentModel.DataAnnotations namespace. This now makes the Name property of my RestaurantEditViewModel obey the rules that it must be required so there must be something there, and the maximum length of the string has to be less than or equal to 80 characters. So the MVC framework over in my HomeController, when it creates this ViewModel and populates the properties on this object, it will execute the validation rules to see if this model is valid or not. I can check the state of my model by looking at a property that I inherit from my base class, the BaseController class, and that is the ModelState property. The ModelState property allows me to add new model errors. So if I wanted to have some validation logic right here in the controller action, and I determined that something went wrong, I can add a model error. And I can also check the IsValid flag. So if the IsValid flag is true, all of these data annotations passed, and my restaurant should be in a good state. So only then do I want to try to put that restaurant into my data store, and only then would I want to redirect the user to the details action to see the successful result of this processing. Otherwise, what can I do? Well, if the user's trying to post a form with invalid data, and I detect that here on my server, what I could do is just return that create view again and represent that form and allow the user to fix any errors that might have occurred. So perhaps they forgot to enter the name of a restaurant. By returning the Create view here, the MVC framework will be able to recreate that view with the data that the user entered, the invalid data, and it will give them a chance to fix that problem and resave the restaurant. But I will want to show some validation messages. That is easy to do. In addition to helpers like LabelFor and EditorFor, there is also a ValidationMessageFor helper. This is where I can say, show me all the errors that occurred for the Name property of a restaurant, show those validation messages here. You'll typically want to style these appropriately so they show up in red. We're not going to do anything fancy like that, but I am going to go ahead and add a ValidationMessageFor the Cuisine also, in case something goes wrong there. And when you are building a UI, you might also find it useful to use a ValidationSummary. This would display all the errors associated with a model if I set the correct parameters. So if you want to collect all the error messages together in a particular location in the UI, you can do that with a ValidationSummary. Let me save all the files. We now have a Create view that will show error messages. We now have a HomeController that checks to make sure that ModelState is valid. And we now have data annotations on our input model that will make sure the restaurant name is Required and has a length that is less than 80 characters. Let's come out to /home/create, and now I will forget to enter the restaurant name, but I will set a cuisine of Japanese and try to save this restaurant. And my Controller action has detected that ModelState was not valid, it re-rendered the Create form, and now I have an error message included, The Name field is required. The goal of this exercise was to show you how data annotations like Required and MaxLength and the other validation attributes that are in the data annotations namespace, how these, and even your custom data annotations that you can write, work together with Controller logic and model binding in ASP.NET MVC, so that when the MVC framework is binding to an input model like our RestaurantEditViewModel, the MVC framework can apply the validation rules that are expressed by these data annotation attributes and tell us if our ModelState is valid or not. When ModelState is valid, we will save an entity, in this case a restaurant; when ModelState is not valid, we need to re-render the view so that the user can see the errors that are on the form, and hopefully correct those errors. Now there's one more attribute that I need to make you aware of, and it's something that you should consider using whenever you have a post to a web application. Particularly, when you are authenticating users using cookies. That's a topic we will look at later in this course when we look at ASP.NET identity. But I do want to come back and inspect my page one more time. I want to show you that inside of the form, there is a hidden input with the name RequestVerificationToken. The value of this hidden input looks like gibberish, but there is some cryptological significance to these numbers. And what the RequestVerificationToken can do for us is ensure that the posted form that a user sends to us is from a form that we gave to the user. In other words, this RequestVerificationToken is trying to help prevent a cross-site request forgery. You can find other courses and other articles out there that will talk in more detail about a cross-site request forgery; I'm not going to cover it in any detail in this course. But I can assure that whenever you have authenticated users, posting information to your website, you do want to take advantage of this RequestVerificationToken, and you want to make sure that the MVC framework verifies this token, it will verify this token against a cookie that the framework also sets in the browser. And this is one of the techniques that you can use to avoid cross-site request forgeries. The attribute that I have to place here on my Controller action is a ValidateAntiForgeryToken attribute. Having this attribute in place on an action that accepts an Http POST, particularly a form POST, is very important when you are authenticating users using cookies. But I'm also going to place it here, just so you can see this attribute and know that you should be using it with a POST operation. And know that you should use it when you write an action that is accepting posted form values.

Summary

In this module, we made a distinction between entities and models, and I gave some examples of different types of models, input models and output models. We saw how to use data annotations to influence the labels and inputs created from models by Html helpers, and we saw how Html helpers work with forms and controllers and validation rules to produce ModelState and ValidationMessages. In a controller, you always want to check that ModelState is valid to make sure an input model is properly populated. And if that test fails, you typically re-render the view that displays the form to the user, so they can fix any validation problems and resubmit the form. Later in this course we will also look at enabling client-side validation messages. But for now, we're going to turn our attention to the Entity Framework, so we can start saving this restaurant data into a SQL Server database.

Using the Entity Framework

Introduction

Hi this is Scott, and in this module we're going to set up and configure our application to save and read data from a SQL Server database. To work with a database, we're going to use the Entity Framework, which is freshly rewritten to work with the new .NET frameworks. Although if you have worked with EF in the past, you'll see many familiar pieces. To get started, let's first talk about your SQL Server installation.

SQL Server LocalDB

In my application, I'm going to use SQL Server LocalDB. If you are comfortable with SQL Server, you can use any database that you'd like. Local databases, remote databases, as long as you have permission to create a new database on the instance, you should be just fine. But I'll be using LocalDB. This is a special edition of SQL Server that is optimized for developers. Visual Studio 2015, even the community edition, which is the edition I'm using, the setup program for Visual Studio will install LocalDB by default. You can also install some additional useful tools by making sure the Microsoft SQL Server Data Tools options is checked when you install Visual Studio. If you're not sure, you can always run the installer again; it gives you the ability to modify an existing installation. I just want to start the module by showing you some tips on how to verify the LocalDB installation, as well as how to connect to LocalDB using some tools you might find useful. One of the easiest ways to verify that you have a LocalDB installed is to use a very simple command-line tool. To run this tool, I have to open a specific Command Prompt, so I'm going to go into Windows and search for Developer, because one of the best matches that should appear for that search string is the Developer Command Prompt for VS2015. This is a Command Prompt that Visual Studio configures when it installs, and the installation sets up the path, so that you can reach all of the developer command-line tools. The tool that I want to execute is sqllocaldb. If I run this command with the info argument, and it doesn't produce some error, it gives me some output, I can be pretty sure that LocalDB is installed and correctly configured for me to use. I can see here I have two localDB instances. The one I'm going to be using is MSSQLLocalDB. And I could even get additional information about that instance if I run sqllocaldb info and then the same of the instance, so mssqllocaldb. This will tell me this is a version 12 instance, which is essentially SQL Server 2014. Now I'm going to leave this developer Command Prompt open, because we'll come back and use it a little bit later. The other tool I want to show you is under the View menu, if you installed the SQL Server Data Tools, you should be able to get to an option the SQL Server Object Explorer. This is a really great tool if you have to work with SQL Server, because it allows you to explore databases and browse data and even create data inside of a database. When you first open it, it might take a little bit of time, but it should connect to LocalDB for you automatically. And from here I can do things like browse the available databases. Ultimately this is the instance that I want to hold data for the OdeToFood application, so eventually I'm hoping that an OdeToFood database will appear here. Right now there's nothing else here except for some default things that get installed. And I will show you that if you right-click on this server and go to Properties, you can see in this Properties window, a connection string for this database. Connection strings are important. We will have add a connection string to our application, so that it can get to the correct database. But right here is the connection string. I could take this value and copy it out of here, and use that in other tools or applications to make a connection to SQL Server. The most important part here is the data source. SQL Server LocalDB uses special connection string. When I specify the data source, which is essentially the server and instance that I'm trying to reach, I use LocalDB inside of parentheses and then slash the instance name, which in this case, I do want to use that MSSQLLocalDB instance. So now that I have verified that I do have a LocalDB, and it appears to be in working order, let's get the Entity Framework up and running.

Installing the Entity Framework

To get started with this version of an Entity Framework, we first have to install the Entity Framework dependency, the NuGet package. We've already seen two different techniques for doing that in this course. One way I could install this dependency is to open up project.json, come into the dependencies section, and then type in the package name for the Entity Framework and select the version that I want. That's one way to install a NuGet package. We've also seen that I can right-click on the project or right-click on references and manage NuGet packages. This brings ups a user interface where I can search for packages and select one and click an install button. Which, if you take this approach, make sure you select Entity Framework Core, not Entity Framework, which is version 6.1. Entity Framework Core, yet another brand-new version of the Entity Framework. I want to show you a third approach to installing dependencies, and this approach uses the Package Manager Console. To open the Package Manager Console, I can come to the View menu, go to Other Windows, and eventually I will locate Package Manager Console in this list of items. The easy way to do this is to use the Quick Launch bar in the upper right of Visual Studio. I can just press Ctrl+Q to get in here, and then I can search for the command that I want. In this case, I want package manager console, so I'll search for package, I'll find Package Manager Console, and Visual Studio will open this console window where I can execute PowerShell commands. I can also execute commands that are available from any command-line, so for example, I can execute that sqllocaldb command that I showed you to find out information about the SQL LocalDB instances that are available. But another command that I can use, and the one that we're going to install the Entity Framework is install-package. We're going to do this through the Package Manager Console, because we're going to be using this console to execute some other tools a little bit later in this module. But the first thing I want to do inside of here is install the package Microsoft.EntityFrameworkCore.SqlServer. This should install version 1 of Entity Framework Core, which it has. You can see it also updated my project.json file when I did that. And then there is one additional package that I need, which is I'm going to hit the up arrow to bring up the last command that I just executed, because again, I want to install a package, but this time it's going to be Microsoft.EntityFrameworkCore.Tools. Now, at this point in time, if I try to install this particular package, this particular package is still in pre-release. I just want to make you aware of that, because a few things might change in the future. So I'm going to need to re-execute this command using a -pre flag, which means include pre-release, and now if I try to install this, it is successful, and you can see I'm using the tooling, which is version 1 preview 2 final. Now there's one more step that I need to take in order to use the Entity Framework the way I want to use the Entity Framework in this particular module, and I'm going to leave the Package Manager Console open, just unpin it so it hides down here at the bottom. But the one additional step is to take this line from project.json, the one that registers the tools as a dependency, I'm going to take that line and copy it with Ctrl+C, then come into the Tools section here, and add this as a second tool. Tools are dependencies that your application doesn't necessarily need at runtime, but it's something that might be required to build or configure or package the application. In this case, we're going to be using some commands that are available from this tooling dependency in the Package Manager Console to manage our SQL Server database and its database schema. We will see that just a little bit later, but for now what we need to do is set up what's known as a DbContext. It is the DbContext that will give us access to a SQL Server database.

Implementing a DbContext

To use the Entity Framework, we need to create a class that derives from the Entity Framework's DbContext base class. Each DbContext class that you write will give you access to a single database, and I don't mean a physical database. You can always change connection strings, so that a single DbContext class can point to different physical databases, but logically a DbContext maps to a specific database that has a schema the DbContext understands. And on that DbContext class, you can create properties that are type of DbSet of T. The generic type parameter T will be a type of entity, like restaurant is an entity in the OdeToFood application. So if I want an OdeToFood database, I'll create an OdeToFood DbContext class and implement a DbSet of restaurant on that class. Each DbSet in this class will map to a table in the database. So if I have a property DbSet of restaurant, and the name of that property is restaurant, the Entity Framework will by default look for a restaurant's table inside of my database. Now there's lots of mapping and configuration that you can do to override these defaults. We won't need to do anything fancy in this application. Let's just dive in and see how this works. In the application, I need a class that derives from DbContext, and I think I will put that class here in the Entities folder. So right-click and add a class. Let's call this OdeToFoodDbContext. Even though this class is not going to be an entity itself, it does tie together all my entities so that I can use them with the database. In larger projects, many people will place their entities and their DbContexts into separate projects, but we're going to keep everything together here to keep things simple. The implementation for my OdeToFoodDbContext is very simple, because I only have one single entity to work with. But I do need to make this class derive from the Entity Framework's base DbContext class. That means I need to bring in the namespace Microsoft.EntityFrameworkCore, and I will just a single DbSet property on here. Let me remove the unnecessary usings and then create a property, a DbSet of Restaurant, and we will name this property Restaurants. Now there is one other member that I need to add, I need to add a constructor. I'll do that with the ctor code snippet, and I need to add a constructor that will allow the Entity Framework to pass through some configuration information to the DbContext. This constructor will need to take a parameter of type DbContextOptions, we'll call that options, and my DbContext won't necessarily need to do anything with these options. There's some scenarios where you might want to look at the options, but in my case all I need to do is take those options and pass them to my base class constructor, the DbContext constructor, and just allow those options to flow into there. And now the question is, where will I use this class? Well, I could set things up to inject my DbContext into controllers, and the controllers could then use the OdeToFoodDbContext to query the database. But we already have an abstraction that we inject into controllers and that allows the controllers to query for restaurants, that the IRestaurantData interface. Currently we have one implementation of that interface, InMemoryRestaurantData. Now what I want to do is create a second implementation of that interface that will work with the Entity Framework and talk to a real database. Once again, I'm going to add another class to this file; typically, I would keep all of these abstractions in separate files, but to make things easy let's add a class. I'm going to call this SqlRestaurantData. It will be an implementation of IRestaurantData that stores restaurant data in SQL Server database. In order to do this, I'm going to need to give this class a constructor that takes an OdeToFoodDbContext, let's call that context, and I will save that off into a private field called _context, and I'll generate that field using Visual Studio, so Ctrl+Period. I now have a private _context field where I can store the DbContext. I also need to implement IRestaurantData, so again, use Ctrl+Period in Visual Studio, tell Visual Studio that I want to implement this interface, and now we just have a few methods to fill out. Some of these methods will be remarkably like the methods that we have for an InMemoryRestaurantData. For example, when someone wants to get all the restaurants, I'll simply return _context.Restaurants. Even though this type is DbSet of restaurant, the DbSet type of T implements IEnumerable of T, so I'm still technically returning an IEnumerable of restaurant. I could also use the Linq ToList operator to force this operation to execute immediately, but that's not something you would want to do against a large database. And for larger databases, you would really need to return an IQueryable here, not IEnumerable. That would allow other pieces of the software to compose in additional operations for paging and sorting and filtering and grouping and joining, all of those things that you can do with Linq operators. But for this application, we'll stick with IEnumerable of restaurant, we'll return _context.Restaurants to give back all the restaurants in the database. When I am asked to return a single restaurant, I will return _context.Restaurants, and use the same FirstOrDefault operator that we used below in memory. Given a restaurant, I want to select a restaurant where the Id of the restaurant matches the incoming Id parameter; otherwise, return null. And now we just need logic to add a restaurant to the database. This is where I can walk up the context and simply invoke the Add method and say please add this new restaurant to the database. The DbContext is smart enough to figure out that, ah, this object is a restaurant, I know where that goes. The restaurant will be placed into the appropriate table. And ultimately my API design forces me to return that new restaurant. That gives me the option of returning a different object instance if I need to, but in this case we'll just return the incoming parameter. And then there's one more thing that I need to do with the Entity Framework to make sure that restaurant actually goes into the database, and that is to call SaveChanges on my DbContext. Now in some applications, you will not want to have SaveChanges here inside of the Add method. If you need to group a number of different Add operations or Update operations into a single logical transaction, you won't want to call SaveChanges on the context until all of your work is applied to the objects. In that case, you might move the call to SaveChanges out of here, and then you'd have to have a method on this class for some other component that would use this same DbContext and tell it to save changes, all the changes. Not just adding this new restaurant, but also adding and updating and deleting other objects that you might have modified. I'm going to keep things simple, keep the SaveChanges call in here. One other thing that SaveChanges will do is that we will have an identity column that generates new identifiers for each restaurant that we add. The Entity Framework will be able to bring back the new identifier for a restaurant and automatically populate that into the Id property of a restaurant. We'll see how that works. You might remember with the in memory data, we had to generate an ID ourselves. With the SQL restaurant data, SQL Server will take care of generating the Id, and the Entity Framework will take care of grabbing that Id and assigning it to a restaurant when we save changes. So now we have a DbContext in place, now we have a SqlRestaurantData service in place that can use that DbContext. Now all I need to do is get the DbContext configured with the correct connection string, and configure my application to use SqlRestaurantData instead of the InMemoryRestaurantData. Let's look at this configuration in the next clip.

Configuring the Entity Framework Services

To have a usable Entity Framework DbContext, I need to change the configuration of the application. I'll need to tell the framework what connection string to use so my DbContext knows what server to go to and which database to query. Since connection strings change all the time, I'll put the connection string into our JSON configuration file. I also need to add more services during the ConfigureServices method of the Startup class. The Entity Framework, just like ASP.NET and the MVC framework, this framework relies on dependency injection, and for injection to work, the runtime needs to know about the various services that the Entity Framework uses. Fortunately, there is an easy configuration API that will add all the default services that I need. Let's take a look. Let's swing over into the Startup class of the project and go down to ConfigureServices, where I will need to make two changes here for everything to work properly. The first change is that we no longer want to use InMemoryRestaurantData, we want to use SqlRestaurantData, so that this class is injected into our controllers and other components that request in IRestaurantData. And now the application will be working with a real database. I also need to configure the Entity Framework Services in my DbContext. And the way I can do this is to use a method, an extension method that is installed when I add the Entity Framework to the project. It's AddDbContext. This method is a generic method. It requires a type parameter here to specify the type of context that I want to add. In this case, we created a class OdeToFoodDbContext, that is my type of context. This will require me to bring in the namespace OdeToFood.Entities. And this method is a method that I can pass in an action to specify some specific options for this DbContext. I can write this as a lambda expression. It's a lambda expression that's going to take an Options object, and I need to tell this Options object that I want to use SQL Server. Now this particular, UseSqlServer, this is in another namespace, Microsoft.EntityFrameworkCore. I need to bring this namespace into the file with a using statement, I'll do that with Ctrl+Period. So that statement will be at the top of the file. And now UseSqlServer, by the way, this method exists because this version of the Entity Framework will be able to work with databases beyond just Microsoft SQL Server. In fact, there's support for databases that aren't even relational databases now, but when I use SQL Server I need to tell the Entity Framework what connection string to use for this particular DbContext. That's the additional parameter that this method is waiting on for here, I've just added an empty string for right now. But I will remind you back towards the beginning of this course, we added an appsettings.json file to the project. And the item template for appsettings automatically added a ConnectionStrings setting to my appsettings. I added the Greeting setting to demonstrate the greeting service, but ConnectionStrings was already here, and it's inside of this object where I can add different connection strings that I might use. There is already a connection string here called DefaultConnection. I'm going to change that to OdeToFood. And I also need to make a change to the ConnectionString itself. It's already set up to point to my localdb instance. So that is the proper server specification to reach LocalDb. The database, as the text would indicate, is what I want to change. I want to create and query a database called OdeToFood, and then the rest of this connection string, just in case you didn't have this here, I'm going to leave this as is, so Trusted_Connection=True. I'll leave that in place. That will allow me to use Windows Authentication to authenticate myself through the database. That works perfectly well in development scenarios. And I'm going to leave MultipleActiveResultSets=true. That's something that the Entity Framework often requires when it's executing some complicated nested entity loading. So my ConnectionString is here, I now have it configured, I'm going to save that file and close it. All I need to do is grab that ConnectionString and pass it into UseSqlServer. That's easy. You might remember we saved our configuration off into a property, IConfiguration, and that configuration was loaded from appsettings.json. If I have a different ConnectionString for production, I can add additional files here that might be present only in production, or I could add a ConnectionString as an environment variable, and that would override the ConnectionString in appsettings.json. But ultimately we built our configuration into this configuration property, and this IConfiguration object, there is an extension method available that makes it easy to get a ConnectionString. All I have to specify is the name of the ConnectionString, and the name of the ConnectionString in that appsettings.json that I just closed is OdeToFood. So this extension method will work as long as your ConnectionStrings are defined in the ConnectionStrings object, and then the name inside of there that I want is OdeToFood. Now I just need an additional parenthesis here. Let me bring down onto the next line, so we can try to fit everything onto the screen. And at this point, I've added the core services, I've added the services that talk to SQL Server. I've told the Entity Framework about my DbContext and the ConnectionString that it should use. I've also configured the application to use SqlRestaurantData instead of InMemoryRestaurantData. So now all of my operations should be going against a database, but I don't have a database as yet. Let's use some of those Entity Framework tools that we installed earlier to create the database and put the proper schema inside.

Entity Framework Migrations

One way to get a database set up with the Entity Framework is to use the Entity Framework to create the database. This is a two-step process. The first step is adding migration code to my project. Migration code is C# code that I can execute to create a database, and inside of a database create a database schema. The Entity Framework can generate migration code for me. What it can do is look at a database, see if it exists, and look at my entities and figure out what schema changes are required to make the application work. So, as I add additional entities or make changes to existing entities, like changes to the Restaurant class, I can continue to add migrations to my project and keep my database schema in sync with my C# code. The Package Manager Console command to create a migration is Add-Migration. I also need to explicitly apply migrations to update a database. This is the Update-Database command, it's something that I can do once the migration code is in my project, and my project is in a buildable state. Both of these commands, by the way, are available in the Package Manager Console, because we added in the Tools section of project.json the Microsoft.EntityFramework.Tools entry. Let's see this at work in the project. In the project, I want to use Entity Framework Tools to create the database and the database schema that we're going to use. But before I do that, I just want to come into the SQL Server Object Explorer under the View menu, and look at my MSSqlLocalDb instance. Inside of there is the list of databases that exist, and there is currently no OdeToFood database. That's something that I hope to change by the end of this clip. We'll see that database appear here. And to do that, I'm going to open up the Package Manager Console once again. Now if you've previously closed that window for some reason, remember you can always get to it from Quick Launch, just search for Package Manager Console. Let me pin this to the bottom of the screen. And the first command that I want to run is command add-migration. This will add migration classes to my project, and these are classes that contain C# code that the Entity Framework will execute to create a database schema. What that Entity Framework will do is look and see that I don't have a database, so it needs to create everything that I need to get started. And it's going to look at the DbContext that is in this project. The OdeToFoodDbContext is going to see that it has a DbSet of Restaurant, so it knows that it will have to create a table to store this restaurant information. And in order to create that table, the Entity Framework will look at the definition of the Restaurant class. And it will see that I need a column to store an identifier, to store a restaurant name, and to store a cuisine type. Now, I will caution you that if you have a larger application where you have multiple DbContexts, or you store your DbContexts in separate projects from the web project, then you might need to add some additional parameters to add-migration to specify things like the exact DbContext that you want to add a migration for. But since we only have one DbContext class, there's only one parameter I have to pass, which is the name of the migration, and I'm going to name this migration InitialCreate. This is the initial creation of the database. Now what's not immediately obvious when I execute this command, and was a bit mystifying to me at first, is that in order to figure all this information out, the Entity Framework's actually going to execute code inside of my project. So the Entity Framework's actually going to execute code inside of Startup and bootstrap the application to a point where it can discover the DbContext inside. And not just the DbContext, but also the connection string that the DbContext is going to use. The way things are set up in my application, we're always going to use a connection string to my LocalDb, but if you want to generate migrations from a different SQL Server, you can do that too, it's all in the parameters and how you set up the configuration for your application. Now, I'll show you that the output of this add-migration InitialCreate was this line of code, which was only to undo this action, use Remove-Migration. But the important output actually popped up here in the editor. This is a file that ends with my name, InitialCreate, and then .cs, because it's a C# file. This file is stored in the Migrations folder of my project, along with some other metadata. But what we're looking at here is essentially a migration script, and C# code and an API that allows us to create tables. This is generated by the Entity Framework just looking at my entities. This is going to create a Restaurants table. This table is going to have some columns, the Id, the Cuisine, and the Name column. You'll notice interesting things, like the Name column has a maxLength of 80. Where did the 80 come from? Well, the Entity Framework also respects some of these data annotations that I place on a property, so when the Entity Framework sees that it has to store a name for a restaurant, not only did it create a Name column, but it also set up that column to be an nvarchar 80. So the Entity Framework is trying to build a database schema that closely reflects my entities for the application. And if I had multiple entities and those entities had relationships, for example, a restaurant had a collection of reviews associated with it, the Entity Framework is generally smart enough to set up things like foreign key relationships. Now it's also possible for you to go in and add additional custom code into a migration, so I just want to point out that this migrationBuilder, it does have the ability through this Sql method to execute arbitrary SQL, if you wanted to say INSERT some lookup data into the database. There's also this API that would allow you to do things like create an index if you want an additional index on this table, because there is a particular column or set of columns that you query frequently. We're not going to do any of this for our project, I just wanted to make you aware that these things are available. And of course, for all of this work, you do have to have everything configured properly in Startup, and you do have to have things available like the ConnectionString. This is the ConnectionString that was just used to determine this migration code. I'm going to temporarily put an error in this ConnectionString, I think I'll remove the R from server, just to show you what might happen when I run the next command and the ConnectionString isn't proper. Let's ping the package console here again, and the next command that I would want to execute is update-database. What update-database will do is look at the migrations that are in the project, and then look at the database that your connection string points to. And it's going to see if there are any migrations that exist that haven't been applied to the database, and if so, update-database will execute those migrations. This way if another developer on your team checks in some migrations when you pull down the latest version of the source code, you can just always come into Package Manager Console, execute update-database, and your database should be in sync with the project. Let's try update-database, and if for some reason update-database cannot connect to the database server, or in this case, when there's an error in the connection string, we will see error messages out here, as well as the stack trace that might not be very useful, since it's mostly EF code inside of here. But let's go out and fix the connection string now that we've seen the error. Set this back to server, save the file, try update-database again. I get the output done, there's no more red text on the screen, which is a good indication that this actually worked. So if I come back to SQL Server Object Explorer, let's refresh the database list by right-clicking, selecting Refresh, there's my OdeToFood database. Inside of here will be some tables. This first table that we see here, EFMigrationsHistory, as the name would imply, that's one of the tables that helps the Entity Framework keep track of which migrations have been applied to this database. So the next time I run update-database, the Entity Framework will know if it needs to apply any new migrations or not. In this case, it didn't. I can also see my Restaurants table. It has the columns of Id. Notice how the Entity Framework automatically set this as a primary key. It did that just by a naming convention. If I have a property named Id, the Entity Framework will assume that's a primary key. You can change this behavior through additional configuration, but we're going to leave things as is. I can also store my cuisine, store my name, now we are set and ready to try to run the application and use this database that we have created.

Up and Running

Before we run the application, let's go back into the SQL Server Object Explorer and go to the Restaurants table and select View Data. In addition to viewing the data that's in a table, I can also add data to a table. And it might be nice when I do the initial run of the application to see some restaurants listed on the homepage, because currently we have no restaurant to display. With the first restaurant, let me just pick a cuisine of 0, this is the integer representation of that CuisineType enum that I have. 0 would be the default value for that enum type, and it's where I believe we said the CuisineType was none. Let's enter a restaurant name here, LJ's and the Cat. Let's add another restaurant, The House of Kobe. And as I tab out of the cell, notice how SQL Server will automatically populate the Id column. That Id column is an identity column. Now we have a couple restaurants in the database, let me press Ctrl+F5 to run without the debugger. And when we arrive on the homepage, I can see the two restaurants that are in the database are also on this page. That's a good sign that everything we built in this module is working. Let's also see if we can create a restaurant. Currently there's no link here for the user to click on to go and create a restaurant. That's something that we will add in the next module when we look at some additional features of Razor views. I want to show you an alternative to using HTML.ActionLink and HTML.BeginForm. So for now without the link, let me just go to /home/create, let's create the restaurant Tersiguel's. I will set the cuisine to French, and click Save. It looks like we have added into the database successfully. Let's come back here. I'm going to click the Refresh button. And I can see that my application did successfully save that data into SQL Server.

Summary

In this module, we saw how to work with the database using the Entity Framework. We installed the Entity Framework Core NuGet package, specifically the package allowing the Entity Framework to work with Microsoft SQL Server. Then we wrote a class derived from DbContext. Once we configured the Entity Framework and the DbContext into our application services, we created migrations and then applied those migrations to create a database. Now our application is up and running with SQL Server. So let's turn our attention back to ASP.NET MVC and work with some features of the Razor view engine.

Razor Views

Introduction

Hi this is Scott, and in this module we will be focused on features of the Razor view engine. Although we've already been using Razor to render HTML with our model data sprinkled inside, we can make some improvements to the application by using some features we have not looked at yet, and some features that are brand-new for this version of MVC. The first feature we will look at is a feature to give us a more consistent structure across the application, and this feature is the layout view feature.

Layout Views

Most websites and web applications will want to create pages that present some common elements. For example, you typically have a top area on every page where you display a logo and a navigational menu. Then you might have a sidebar with advertisements or additional links. And probably a footer at the bottom of the page with some small print. Every page of the application will want to have these common pieces, but we don't want to duplicate these pieces in every single view that we write. This is where layout views are helpful. A layout view is just a Razor view with a .cshtml extension, and you can name a layout view whatever you like. I'll be using a layout view with the name of _layout.cshtml. This is a common name for a layout view. The leading underscore isn't required; that's just a convention that many developers follow to identify a view that is not a view that you render as a view result from a controller action. Instead it's a special kind of view. But once we create a layout view, we'll then go in and set up our controller views, like the index view for the homepage, to use this layout view. It will render inside of the layout view at a specific location. Now the index.cshtml doesn't need to know anything about the logo or the top-level navigation or the sidebar, it only needs to render the specific content for the model that the controller action gives the view. The layout view takes care of everything else. Let's try it out. Inside of the application, we have three views that are rendered by the HomeController, so they are in the Home folder. And these views all need to render some duplicate markup. Every time we send one of these views to the client, they should really render an HTML tag, a head tag, a title tag. And we don't have a complex UI, but you can certainly imagine it would also need to render a navigational view, something as a footer, perhaps a sidebar. And we do not want to duplicate all of this HTML inside of all of these views. This is where a layout view is useful. I'm going to create a new folder in the Views folder, so right-click on the Views folder, select Add New Folder. I'm going to call this folder Shared. This is a conventional folder that the MVC framework knows about. It knows that views inside of the Shared folder might be used by multiple controllers in the application. We saw that earlier in the module. The MVC framework will always check the Shared folder after it checks the folder specific to a controller to see if a view exists in either one. This is where I'm going to use my layout view so that I can use it from multiple controllers in the application. So, I'll add new item to the Shared folder. I'm going to look for the MVC View Layout Page template. The default name here is _Layout.cshtml. I'm going to keep the default name. But you can name the layout view whatever you want. You can even have multiple different layout views and choose the layout view that you want to use at runtime. You might do that depending on if the user is anonymous or logged in or even the time of day. We'll see how to select the layout view in just a bit. And it is inside of here where I can place my boilerplate HTML code, so things like the opening html tag, the head tag, the body tag, the navigation menu could go here. And because this layout view is still a Razor view, it's a file with a .cshtml extension, I can still use C# expressions and code blocks inside of this view. For example, I might place a div here on the page where I want to display the current year, which I could do do by evaluating the expression, DateTime.Now.Year. It's better to include information like that in the ViewModel that gets passed to the view, but as we'll see, layout views can be a little bit different, and I'll show you a technique you can use to funnel dynamic data into a layout view, we'll do that later. For right now, I just want to call your attention to two other expressions that are inside of this view. Let's talk about RenderBody first. When an MVC controller action says I want to render the index view, and there's a layout page involved, the index view and all of the html it produces will be placed here where the method call to RenderBody exists. So I can expect all of the content views throughout my application to appear inside of this div, where I invoke RenderBody. The other expression inside of this file is to place ViewBag.Title into the title element. ViewBag is a dynamic data structure, and you can add any property and any data that you want into the ViewBag. This expression is reading ViewBag.Title, so pulling up that property value and placing it here in the title tag. I'll show you in a moment how a content view can set ViewBag.Title so that the proper title makes it into this layout view. Because only a content view, like index or details or create, knows what the title of the page should be. The layout view doesn't know that; it works will these different views that should have different titles. So a ViewBag.Title, that's one easy mechanism that I can use to communicate or pass along some information from a content view into the layout view. We'll see how to set ViewBag.Title in just a moment. Now there's one more expression that is commonly used that I want to make you aware of. Let's change this bottom div to a footer. And inside of the footer, I want to make a call to the method RenderSection. RenderSection is useful when a content view like index.cshtml might need to output markup into different places in the layout view. So by default, everything that is in index.cshtml will appear where RenderBody is invoked. But from index.cshtml, I can also have named sections, and index.cshtml has the ability to say this particular chunk of html, I want to render it into the section called footer. And now the layout view is responsible for placing that section into the higher level layout. It will say here is where to render the section footer. And notice the second parameter here is a flag. Is the section required or not? If I say that this is optional by setting that flag to false, a content view does not have to provide a footer section, but if I were to leave this as the default or set required to true, if something like the details or the index view did not provide a footer section, there would be a runtime error. So this is what the layout view is going to look at. We're going to render the body here inside of this div. We're also going to render an optional footer section inside of a footer element at the bottom of the page. Let me save the layout view. Now we need to make some changes to index.cshtml to use this layout view. The first thing that I will do is remove the markup that we will no longer need inside of the index view. So I can remove elements like the html element, the head element, the opening body tag, all of that will be handled by the layout view. I'll get rid of the closing body tag and the closing html tag, then hit Ctrl+K, Ctrl+D, Visual Studio will reformat my markup and I don't have the leading spaces anymore. And now I'm down to the essence, I'm only rendering from index.cshtml, the content that is specific to the homepage. The layout view is going to take care of everything else, but I still need to do two things, I need to tell the MVC framework that I want to use that layout view, and I need to set the appropriate title by adding some information into the ViewBag. I'll do this by creating a C# code block inside of my view, so @ and opening curly brace. Now I can write statements that I can set properties and invoke methods, I can even declare variables inside of a code block, although we try to keep views as simple as possible. But don't try to add too much code into a code block. The only two things that I want to do here are first, use the ViewBag property that I inherit from my base class to set the title or this view. So, if I say ViewBag.Title = the string Home, this bit of code is going to execute before the layout view renders, and because I've placed something into this dynamic data structure ViewBag where I can add any property at any time, and it can be any type, that information is still in the ViewBag when I get to the layout view. And the expression ViewBag.Title, that will produce the string that I put in their home, and that will set the title when the index view renders inside of this layout view. So the title is set. Now I just need to tell the framework which layout view that I want to use. This is where you can apply some logic. You might choose different layout views, depending on the user profile. We only have one layout view, but I do have to give the MVC framework a specific path to the layout view. I'll do that by starting with a tilde slash, that tells the framework to go to the root of the project, then it needs to go into the Views folder, and then into the Shared folder, and then select Layout.cshtml as the view. And now if I save this file, let's come back and go to the homepage, and you can see I'm rendering the same content as before with the addition of the year that my layout page is outputting. But now I've cut down the amount of boilerplate markup that I need inside of index.cshtml. And no other views in my application will need to specify the head tag or the opening body tag, as long as they use this layout view. We'll see an easy way to do that in just a moment. Let's go back to this layout view and remove DateTime.Now.Year. I was really just placing that in there to make sure that we were rendering the layout view. And now let's try to plug some content into this footer section at the bottom of the page. I'll save the layout view, come over to index.cshtml, and let's say that we want to take this welcome message, or this CurentMessage, and we want to display this CurrentMessage in the footer section. So I'm going to cut it out of this HTML, because all of this will render where the RenderBody method is invoked. What I want to create is a section directive. So @section is a directive, I can give this section a name. I will call it footer. And then everything inside of those curly braces is considered part of that section, and when Razor is rendering this view, it's going to take this name and look for something in the layout view with the same name, and place the output here where the call to that particular section is. So let me paste in the CurrentMessage, then save all the files in the project, come back to the browser, and now my configurable hello appears at the bottom of the page inside of that section. And this is the power of layout views. The next thing we will need to do is fix up the details view and the create view so they are also using this layout view, but there's an easy way to do that. I want to show you a way that you can avoid specifying the layout view inside of every single content view.

_ViewStart

The Razor view engine in the MVC framework has a convention where the framework will look for any file with the name _ViewStart.cshtml, and execute the code inside of this file before executing the code inside of an individual view. The code inside of a ViewStart file cannot render into the HTML output of a page, but we can use ViewStart to remove duplicate code from the code blocks inside of individual views. In our application, if we want every content view to use the _LayoutView that we just created, we could put the code to set the layout view inside of a ViewStart file, instead of having the code inside of every content view. Let's see how this works. In the application, I don't want every content view to have to specify that the layout view is _Layout. I just want this to happen automatically. So I'm going to come into the index view and cut this line of code that is setting the layout view, and then create a ViewStart file and place that code inside of there instead. I'm going to place the ViewStart file in the Views folder. All I need to do is right-click the folder, select New Item. Under the ASP.NET templates, there should be a template for an MVC View Start Page. The most important part here is that the name is _ViewStart.cshtml. And once I click Add, you can see the usual responsibility of _ViewStart is to set the layout view. So let me remove what is here and paste in the code that I used to have inside of index.cshtml. And I'll just tell you that the reason I placed this inside of the views folder is because the MVC framework will look up through the folder hierarchy when you render a content view to find a ViewStart file. So, if I had placed this ViewStart file inside of the Home folder, that would be setting the layout view only for the views that are inside of the Home folder, just Index, Details, and Create. But I want to use this layout view everywhere, so by placing this in the Views folder, any future views that I create in Home or Shared or any other folder inside of here, they will have the layout view set by this particular ViewStart. And I can always override that by putting a ViewStart inside of one of those individual folders. I can also override this setting by still going into an individual view and saying, now, instead of using layout I want to use Layout2. So now the index view would be using Layout2. I could also say that the Layout property = null, and that's telling the MVC framework I don't want to use any layout views. All of the HTML inside of here is just as it appears. But I do want the index view to use the layout view specified in ViewStart, so I will remove that piece of code, and now I also want to fix up the details and create view. So we created these as HTML fragments. We didn't have a body tag and a head tag inside of here. So this will plug into our layout view just fine. I just want to set the title. So inside of a C# code block for the Create view, let's say that the ViewBag.Title = Create, and inside of the details view, let's also add a title. This is also just an HTML fragment inside of here, so it will plug into the layout view just fine. Let's set the ViewBag.Title = and in this case I want to use the restaurant name, so Model.Name. Now let me save all the files, come back to the browser and refresh, the homepage will still be using the layout view. If I go to the details of the movie, that should also be using the layout view. If I come to /home/create to create a movie, that should be using the layout view. Just to be sure, let's look at the page source, and I can see that even though this view over here is just a fragment, it is rendering with an HTML tag, head tag, body tag, everything from the layout view is there. Now in addition to this _ViewStart file, there's another special .cshtml file to talk about. Let's look at that next.

_ViewImports

In addition to _ViewStart, there is also an _ViewImports file that the MVC framework will look for when rendering a view. Like the ViewStart file, I can drop ViewImports into a folder, and the ViewImports file can influence all of the views in the folder hierarchy. This view is new for this version of the MVC and here's the idea. In previous versions of the framework, we could use an XML configuration file to configure certain aspects of the Razor view engine. Those XML files are gone. Instead I use code. The ViewImports file is a place where I can write code and place common using directives to pull in namespaces that my views need. So, if there are namespaces that I commonly use in my views, I can have using directives appear once in my ViewImports file instead of having those using directives in every view, or typing out the full namespace of a class. The ViewImports file also has another purpose, but we'll talk about that in the next clip. For now let's see how to move our using directives into ViewImports. Inside of the create view, I currently have a using statement to bring in the namespace OdeToFood.Entities. I'm going to cut that line of code out of Create.cshtml, but I am going to need that namespace in effect in order for this view to compile. You can see currently Visual Studio is telling me we cannot find this restaurant type, we cannot find this cuisine type. If you want to see what this looks like if you try to render this view, we'll just refresh the create view, and I get the same errors here. The type of namespace Restaurant could not be found. Now if that is a namespace that I use commonly throughout a number of views in the application, I would come into the Views folder and say let's add a new item, and this time I want to add an MVC View Imports Page. And the name _ViewImports, that's important, that's the name I have to use. Let me add this file. This template comes with no code, but I'm going to paste in that using statement that I took out of the Create view, save all my files, and if I come back to the browser and refresh, any view now throughout the entire application that is using types from OdeToFood.Entities from that namespace, this namespace OdeToFood.Entities is already in effect for all of the views in my application, thanks to _ViewImports.cshtml. This is, by the way, like ViewStart, a Razor view, but it's not a view where I can render any HTML into the page.

Tag Helpers

Tag helpers are a new feature in this new version of ASP.NET. Tag helpers are like HTML helpers, they help us render HTML. In many cases, you can use a tag helper instead of an HTML helper. Why would you use a tag helper instead of an HTML helper? Well, tag helpers blend into the HTML, because they appear as if they are HTML attributes or HTML elements. An example is the asp-for attribute that you see here on the screen. This is a tag helper. I can use this instead of html.LabelFor. We use that helper when we added a create view two modules ago. So whether you choose to use HTML helpers or tag helpers, it's really a matter of personal preference. But many people are finding tag helpers to be easier on the eyes, and they make for views that are easier to author and easier to maintain. Let me show you how to use these tag helpers. We are going to add another NuGet dependency, and we're also going to need to add an addTagHelper directive to the view or to the views that will use these tag helpers. Our first bit of business is to install a new tool. This is a NuGet dependency, and this is a dependency that will add IntelliSense help for us in the editor for when we are using tag helpers. And in order to get this to work, I want to close all of my views, because I'll need to reopen them after adding this new dependency. Let's go down to the project.json file, and it is inside of here where I will want to install Microsoft.AspNetCore.Razor.Tools. And just like the Entity Framework tools, this is still in preview. So I'm going to use the version 1.0.0-preview2-final, and I need to take this line of code, and also add this to the Tools section of project.json. Now one thing you might commonly see with this dependency, since it's a tool that provides IntelliSense, I only need this during development time. Instead of specifying the version here, I can actually specify another object, and in this object will contains some additional information. In addition to the version, which is still preview2-final, I can also set the type of this dependency to be a build time dependency. I could also do this with an Entity Framework core tools. But now let me save project.json, allow Visual Studio to restore the packages, and now we can open up index.cshtml and try out some tag helpers. The tag helpers that we are going to use are built into ASP.NET Core. The only reason we added a dependency to project.json was to bring in some tools that we'll load into Visual Studio and provide some IntelliSense. But anybody can write a custom tag helper. If you've run into a scenario where you find a tag helper useful, you can write your own tag helper, but regardless, if you write a tag helper or if Microsoft writes a tag helper, we do have to tell the Razor engine that we're going to use a specific tag helper. And the way we do that is with the @add tag helper directive. But I'm not going to add this into index.cshtml, because I plan on using tag helpers throughout the application. And for this scenario, I can come into ViewImports, and just like the using statement, if I add my tag helper directive here, the tag helper that I specify will be available for all of the views inside of the view folder. This directive is @addTagHelper. And what I can specify a specific tag helper type, I'll just put that as T for right now, and then the assembly where that tag helper lives. So I want to use tag helpers from AspNetCore.Mvc.TagHelpers. And this syntax would bring in a single tag helper, whatever I specify as T, but if I just want to use all the tag helpers, I can use an asterisk here to tell the Razor engine to load all the tag helpers that it can find from that specific assembly. So with that in place, I am now ready to use some tag helpers inside of my views. Over here on the homepage, we know that we need a link from this page to get to this create view. Currently the only way to get to that create view is for the user to type into the address bar /home/create, but I'd actually like to have a link here that a user can click on to get to the view. So one way I can create the link is to use html.ActionLink. As we saw earlier when we built a details link, all ActionLink is doing is outputting an anchor tag with an href set to a certain URL that is determined by evaluating these parameters. But this time instead of using an HTML helper, I'm going to go back to using just a regular anchor tag. I want this to display the text Create, but now I will use some tag helpers to generate the href attribute. So these tag helpers, they are evaluated on the server when the Razor view is executing, they are not sent to the client and manipulated by JavaScript. This is all server-side work. And all of the Microsoft tag helpers start with an asp- prefix. And when I have the IntelliSense dependency working properly, I can see a list of all the tag helpers that are available to me. All of these particular tag helpers are attributes, and one of the tag helpers here is asp-controller. And what I'm doing here is I'm telling the Razor view engine that I want you to set the href on this anchor tag by building a URL that will go to the HomeController, and then there's also an asp-action tag helper, where I can say I want to go to the Create action on the HomeController. So you can see that these tag helpers blend into the HTML much better than html.ActionLink, but they can produce the same result. And if I save the index view and come over to the browser, I now have a link for create that I can click on to get to /home/create. I should also add a link on the create view to get back to the homepage. What about using tag helpers to create a link for the details view? This is a little more involved since this needs parameters. Well, let's do this, let's remove the existing links that we have on the page, and we really don't need two links in any case, and go back to using just a regular anchor tag that displays the text. Let's just call it Detail, so we know something changed. And I want this to go to the HomeController, but since I am on a view that is rendered from the HomeController, I don't need to use the asp-controller tag helper. In fact, I don't need it down here on this ActionLink either. These tag helpers can work together, but they work very much like html.ActionLink. If I'm just going to the same controller and action on the same controller, I don't need to specify the controller. So up here I know that I want to go to the Details action, but now I need to pass along that restaurant ID, how can I do that? Well, whenever you're in that situation, there is an asp-route- tag helper, and what you put after the final dash is the name of your parameter. For example, if I need to pass along an ID value, I can say asp-route-id. If I needed to pass along the name of a restaurant, I could say asp-route-name. So I can have a -anything here, and that will be built into the URL, whether it appears in the path segments because of the routing rules where it appears in the query string, the MVC framework will figure that out. I need to pass along an ID, and that ID has to be the restaurant.Id. Let's save this view again and try it out. Now I'm down to just the single link that I created, but I should be able to click on Detail, and I get to /home/Details/1. And so this link, also working. And this demonstration should give you an idea of what tag helpers can do. They can manipulate the HTML for you, they can replace, in many cases, HTML helpers with a cleaner syntax. Again, these tag helpers are evaluated on the server, so if I were to view the source of this page, I'm not going to see attributes like asp-action in my markup. They'll be taken out on the server-side, and typically you'll see other attributes that these tag helpers have created or other pieces of markup, like the href attribute here on the anchor tag. And there's quite a few tag helpers that I won't have time to cover in this course, but I do want to make you aware that some tag helpers are elements, and there is a cache element where I can specify things like when this particular piece of markup should expire. And here I'm saying I just want to cache this one particular piece that is inside of the page. There's also an environment tag that you might run into where you can say that when I am running in Development, only then do I want the markup that is inside of this environment tag to display. Otherwise, I might have another environment tag that says Names = Production, to do something in production. I'm not going to have time to cover those particular tag helpers in detail. What I do want to spend some time with are the tag helpers that helps us build HTML forms. Let's look at those next.

An Edit Form

Let me demonstrate the form-related tag helpers by building a new feature for the users, the ability to edit an existing restaurant. Let's start off with a link that should appear here beside of each restaurant that will take the user to an edit page. So again, an anchor tag, this time the asp-action, will be equal to Edit, that's an action that we still have to create. This action will need to know the ID of the restaurant that we want to edit, so I will pass along asp-route-id as a restaurant.Id. And the text to display will be Edit. I'm also going to move this cell with the links after the restaurant name. Our table is not a pretty table, we haven't applied any styles to this table, but hopefully having the links after the restaurant name will make the table appear just a little bit better. And with that change in place, let me save the index view. Now we need to build an edit action. Now there's many applications I've worked on where the Edit action and the create type of action are combined into a single action and a single view. I'm going to leave these as distinct pieces so that you can see the difference not only in the code, but also the views. I'm going to leave the create view using HTML helpers, and we will implement an edit view that uses tag helpers, but the two forms inside of these views, they'll be very, very similar. First though, we need an action to respond to something like /home/edit/3 and provide a form that will allow me to edit a restaurant. So the first version of the edit action will be an action that only responds to HttpGet, but return an IActionResult. The name of this is Edit, it needs to know the id of the restaurant to edit. We will use restaurantData to look up the restaurant that the user wants to edit. We can again do something where if that returns a null reference, we know that restaurant wasn't found in the database. In this scenario, I'm just going to redirect the user back to the list of restaurants, so they can select another one to edit. Otherwise, I want to return an edit view with the restaurant as my model. Let me save the controller, and let's implement that view. I'm just going to make a copy of the Create view. So I can right-click that, say I want to copy it, select the Home folder, I want to paste that file here, and now right-click to rename this particular file, I'm just going to call it Edit.cshtml. Inside we want to replace HTML helpers with tag helpers. I also want to change the title. So instead of create, let's say Edit, and perhaps the restaurant name. I can add that in using C# 6 interpolation. I want to edit and then say Model.Name, that will put the name of the restaurant in the title. I could do the same thing here for the h1 tag. We will use Model.Name here and say that we are editing, and then the restaurant name. And now I can start to rip out some of the HTML helpers. So first we'll get rid of Html.BeginForm, and instead use a plain Html form tag. I just need to take the closing form tag and place it down here to enclose all of my inputs. And I am going to make sure that I specify a method of post. Now one difference between using the Html.BeginForm helper and a plain HTML form element is that if I want to use anti-forgery tokens to prevent a cross-site request forgery, I need to come in and use an asp- attribute, which is asp-antiforgery and set this to true to make sure that the anti-forgery token is still generated into this form. And later when we add cookie authentication, I surely want to use anti-forgery tokens, because using cookies for authentication is one of those scenarios where you want to make sure that a user is submitting a form that you gave to that user, and that's the purpose of the anti-forgery token. Now, I can replace things like Html.LabelFor also with just the plain html element label. But now there is a tag helper, asp-for, where I can say this is for the Name property of the model. And behind the scenes, LabelFor and asp-for, they do very similar sets of processing. They will both look at metadata about this property on the model, and look at any data annotations that are specified on that property, annotations like the display property that we have, and they will use that information to set the text of a label and the For attribute of a label. So I don't have to specify the label text here, the asp-for will do that for me. And by the way, this is all server-side processing, so these attributes are not sent to the client. I do not need JavaScript for tag helpers to work. These tag helpers are bits of code that execute as the Razor view is rendering the HTML, so when I look at my page source I won't see things like asp-for, attributes in my HTML, I'll just see that the label has a name, and it has a for attribute set. Let me get rid of the helper version of that. Now we can replace EditorFor by just saying I want an input, and I want it for the Name property of my model. This will make sure to set the name attribute of the input, as well as the value of the input. So the input should contain my restaurant name when this view is rendered. Let's remove EditorFor. And now ValidationMessageFor, there is a tag helper for that. So I'm going to place this into a span and use asp-validation-for here. You can see the IntelliSense really helps in telling you what attributes are available for which HTML elements. But I'm going to set asp-validation-for the Name property of my model, so any model errors that are associated with the Name property should appear in this span. And this gives you a pretty good idea of the difference between tag helpers and HTML helpers. HTML helpers are C# expressions. I need to invoke a method. I can use strongly typed lambda expressions. And although HTML helpers produce HTML, they do not look like HTML. One reason so many people like tag helpers is that they really blend into my HTML here. I want a label, I want an input, I want a span with validation messages. These are very easy to style with CSS, and for the most part just blend into the HTML so well. Let's also replace our HTML helpers here for cuisine, so once again I need a label. This one will be for the Cuisine property of my model. I can remove that HTML helper. Now the dropdown list is interesting. DropDownList ultimately just renders an HTML select element, and inside of the select will be one or more option elements that specify the available options for the select. I can still use asp-for with a select element, so I can say that this is for my Cuisine property. And you might have noticed there was also asp-items. This is where, again, I can specify the select list items that can be used to build the options for the select. And it is here where I can use Html.GetEnumSelectList for this cuisine enum type, I'm just going to copy that expression, bring it down and set it on asp-items and just include an @ in front to make sure this is evaluated as C# code. And that's all I need to do to build my select. I can remove the DropDownList helper. But this is sort of an indication that you might not find a tag helper for every HTML helper, so there's still some places where you will want to use HTML helpers. But in both cases, you can build your own HTML helpers, you can build your own tag helpers, that's a little bit beyond the scope of this course. Perhaps I can do that in a future course. For right now we just want to get this form working. So I need a span that will provide validation messages for the Cuisine property of the model. And at this point, I should be able to save my file, come back to the HomeController, now we need to figure what happens when the user clicks that Save button, and we have an HttpPost operation. In this case, I'm going to implement an edit action that takes not just an ID, but also that RestaurantEditViewModel that we created earlier. Remember, we want to be very careful when posting to the server. We typically want an input model that will only receive the data that we expect the user to give us. And one of the things that we did with RestaurantEditViewModel was only provide Name and Cuisine properties, those are the only two things that we expect from a form. We didn't even add an ID property to this model. We could, but it can also just have this as a second parameter here. This will still be picked up from routing data. So the post operation should be post to something like /home/edit/5 where 5 is the Id, and the MVC framework will know that's an Id, and pass it into the Edit method here. I also want to validate anti-forgery tokens that are in the request, and now I can get around to the business of saving data. So there's several different approaches that you can use for an edit scenario. Let me show you one. First of all, I'm still going to go out to my database at this point and ask restaurantData to get me the restaurant with this Id. And one of the checks that I could make here is to make sure that the restaurant doesn't come back as null. That might mean that the user started editing a restaurant as another user deleted that restaurant, and now the restaurant isn't in the database anymore. How would I handle that? I'd probably render a specific view in that situation and say something like if restaurant equals null, then return a view of NotFound and implement a view that tells the user why the restaurant that they thought they were editing might not be there. So that's something you might add in your application, and something you definitely want in your application is to check to make sure ModelState is valid. If ModelState is not valid, I want to re-render this edit view and give a user the chance to fix any validation errors that they created when they edited the restaurant. So that logic is in place. And if ModelState is valid, well then I can start copying information from the input model into the restaurant. So I can say restaurant.Cuisine = model.Cuisine, and restaurant.Name = model.Name. Now I need to actually somehow save that restaurant into the database, and if that is all successful, we can redirect to the details action, just like we do with the create action, and pass along some route data that includes the current restaurant id, so restaurant.Id will go here into the router data. But how are we going to update the restaurant? There's a couple different approaches you can use. Some people like a very explicit Update API on their services. Let me show you another approach. We had this debate back when we created restaurants on whether or not the Add method of SqlRestaurantData should commit and save changes as I add each restaurant. Let me actually show you what the API would look like if we did not have a explicit call to save changes here, and instead force the application to call save changes or commit. At some point when the application was done modifying data. So let me add a Commit method to IRestaurantData. That means we'll need to implement that here on the interface on SqlRestaurantData. I'll do that with Visual Studio and Ctrl+Period. A Commit operation is very simple. I simply need to go to the context and tell it to save changes. I'm also going to need to implement that method on my InMemoryRestaurantData, so I will use Visual Studio to generate that method. And since in memory data isn't transactional, this is really a no op, or no operation. If you set a property on an in memory data source, that change is already committed. For unit testing and other purposes, I could set a flag on this object that says, yes, work was committed. That can make testing a little bit easier, but I don't need to make any other changes here. Let me close that file, come back into the HomeController. Before I forget, let's go to the create action. After adding a restaurant now, I need an explicit call to commit to make sure that the Entity Framework generates an insert statement, and for my edit scenario, I will also need to make a call to Commit here. So if you haven't worked with technologies like the Entity Framework before, the Entity Framework knows that I pulled a particular restaurant out of a table and placed it into an object. And when I call Commit, which ultimately calls SaveChanges on the Entity Framework, the Entity Framework can detect which objects have had their data modified. So it will know if I set the cuisine of this restaurant to a different cuisine, or set the name to a different name, and when I call save changes, it's up to the Entity Framework then to reconcile those changes with the database. So if I changed the name of a restaurant, the Entity Framework will generate an update statement to update the record in the restaurant's table of my database to make sure that that change is persisted. That all happens when I call Commit. Let's try this out. I'm going to save all the files in the application. Let's refresh the homepage to get the updated user interface. And let's go and edit LJ's and the Kat. What I want to do is add an extra T to the name. Also, let's change the cuisine type to American, click Save. Looks like the extra T is there, the cuisine is still American. Even on the homepage I can see the extra T. Let's go back and edit this restaurant and remove that extra T and click Save. And it looks like my edit feature is working.

Partial Views

The MVC framework has the concept of partial views. As the name implies, a partial view, which is just another Razor file with the cshtml extension, a partial view is a view that renders just a part of the full view. There are generally two use cases for partial views. One use of partial views is when you have some view code that you want to reuse in the application. Let's say, for example, that you have a layout view, and the layout view is selected by an index view that renders in the body of that layout view. The index view receives from the controller a model object that is a list of restaurants. And the index view has to display summary information about each restaurant. This restaurant summary might require a block of Razor code that also appears in other views that are displaying restaurant information. If that's the case, I can take the common code and put it into its own view. Let's call it _Summary. And then I render that partial view into my index view using an HTML helper named Partial. With Partial I pass the name of a view and optionally a model object for that partial view to work with. So you can also use partial views to take a complex model object and break down the rendering of that object into smaller pieces. The key point here is that when using Html.Partial to render a partial view, a partial view relies on model data from the parent view. A partial view cannot go out and get a model independently. If you do need a different model for a partial view, this is where view components can come into play. View components are brand-new in this version of the MVC framework. Imagine I have a layout view that is again selected by the index view, and the index view has a model which is a list of restaurants. But the layout view also needs to display some advertisements about restaurants using information from the database. I don't want the index view to provide that ad data, since the index view is only concerned with the restaurants themselves. This is where I can build a view component and use Component.InvokeAsync to render a component anywhere on the page. I can use Component.Invoke from an index view or a layout view or any other partial view. And the wonderful part about view components is that they are separate objects. They can be instantiated and perform their own data access, build their own model objects, and render their own partial views. So unlike Html.Partial, a component doesn't need to rely on a parent view for any model data. Let's look at how to use partial views now and then create a view component in the next clip. Over the years I've used tables so many times to display data in a grid that I now actively look for opportunities to not use a table. So instead of displaying these restaurants in a table like this, let's display them in their individual divs. Divs where a designer can come along and apply CSS and make the UI look really attractive. So instead of a table, I'm thinking there's still going to be a be a loop, I'm still going to need to lop through these restaurants, but inside of a loop foreach restaurant, what I want to do is render a partial view to display just that one restaurant. We will call this partial view _Summary, and you can see that the second parameter to Html.Partial, it's where I can pass along a model object. So I want to pass along a restaurant. Let's go ahead and create that view. I could create this view _Summary.cshtml in the Shared folder, that means anyone anywhere in the application can use that partial view, but I'm just going to create it in the Home folder, it's only going to be a partial view only available to other views that are rendered from the HomeController. So let's add a new item. I'm going to select MVC View Page, and let's call this _Summary. I'll press Enter to add the view. Let's delete everything that's in here, and come up with a simple UI. The model for this, I will expect to receive an individual restaurant, and I don't have to type the namespace for that, because we have the using statement in the ViewImports file. And let's render each restaurant inside of a section. For each section let's have a little h3 element that will display the name of the restaurant, and then we can have a div, we're currently not displaying the cuisine at all on the homepage, but now I'll be able to say Model.Cuisine and place that into a div, and now I still need links to be able to get to the edit view or the details view. So let's borrow that code from index.cshtml. I'm just going to copy out the two links that we already have, paste them into summary.cshtml. I do need to change this expression from restaurant.Id to Model.Id. And now my partial view is complete. Let me save that file. Back in the index view, I can now remove my table, and I'm also going to put this create link inside of its own div. That will be important for styling and spacing. So, save all the files on the project, come back to the browser, let's refresh and see what this looks like. And now we still have a display of all the restaurants that are in the application, but instead of using a table and table cells, we're using section elements to display the restaurants. And the important part here is that I received a rather complex model object for my index view, the HomePageViewModel. It includes a message, it includes a list of restaurants. But this view has been simplified a bit, because I now delegate quite a bit of the work to this partial summary view, that is now responsible for rendering the details of each restaurant on this homepage. And now that we've seen how to use Html.Partial where I pass in model information for that partial view to use, let's look at how to build a view component.

View Components

Here is my scenario for using a view component. Let's say that we want this configurable greeting that currently displays on the index view, we want this to display on every page of the application at the bottom of the page, and therefore, it's no longer the responsibility of the index view to display the greeting. And what I should do is go into the HomePageViewModel and remove the current greeting from that model and remove the reference to the IGreeter service from my HomeController, but I'm going to leave that as an exercise for you to do. All I'm going to do is remove this footer section, and I now want to give all responsibility for displaying that greeting to the layout view. The problem with the layout view, however, it's very difficult to receive information as part of a model object here. I could specify that I have a certain type of model, but it becomes a little bit tricky for the entire application to build models that all derive from some base model type. Another option just as a quick aside is that it's also possible to use an inject directive and inject something like the IGreeting service into your view and use it directly. But I think you have to be very careful about using some services from views, so I'm not going to take that approach either. Instead I want the ability to use a view component. And a view component is completely independent of whatever controller is currently executing and whatever model is being used to render a view. The layout view will be used from different views that use all sorts of different models, but if I use a view component, the view component is responsible for getting the greeting and rendering some HTML into my layout view. And so what I will do down here in the footer is to use the Component property that is available from a view, and use the InvokeAsync method. Now I'm going to leave a bug in this code, so I want you to know up front that the code I'm about to show doesn't completely work properly, but it's a common error that everyone makes, so I'll show you exactly what the error is and how to fix it. My intention is to invoke a view component named Greeting, and this view component will go out and build its own model, render its own HTML, and that HTML will appear here inside of the footer. Now, a view component is almost the complete MVC abstraction. There is a class that be instantiated, there will be a method that gets invoked, it's very similar to a controller in that fashion. And it's also similar because the method needs to build a model and pick which view to render. It's just that the view is going to be a partial view that appears to render as just part of the page here. It's going to render an HTML fragment. If you have used previous versions of the MVC framework, you might have used the Html.Action helper here to do something similar. But in this version of the framework, Html.Action is gone, and it turns out that view components are a much better solution to this problem. So as I said, a view component is a class. Let me go ahead and add a new folder to this project, and let's call that folder ViewComponents. And inside of this folder I'm going to add a class, just like I would add a controller. And this one is going to be called the GreetingViewComponent. So yes, there's a default naming convention, just like if I asked for a controller named Home, the MVC framework goes looking for a class called HomeController; here I'm asking for a view called Greeting so the MVC framework is going to go looking for a class GreetingViewComponent. Let me add this class to the project, and let's go ahead and derive this class from a ViewComponent base class. That requires me to bring in the Microsoft.AspNetCore.Mvc namespace. I'm going to delete some unused usings, but I am going to leave behind for System.Threading.Tasks, that will actually prove useful later. Now as I said, the ViewComponent, it's very similar to a controller. Except instead of actions, I'm going to add a single method called invoke, and this Invoke method can return an IViewComponentResult. Very much like an IActionResult, but this is a VewiComponentResult. And the name of this method, I will call it Invoke. In order to get the greeting on the page, I will need a constructor for this view component, and I can for the framework to inject an IGreeter service for me. Let's call that Greeter, and just like I have done with other areas of application, I will save the IGreeter off into a private variable that I'll generate in Visual Studio with Ctrl+Period, so I can now build a model for my ViewComponent. The model is greeter. let's get the greeting. So this could easily be data access or calling an API on another server. The whole idea of invoke is for this view component to build its model and then render a view. So let's return a view here, and pass in our model object. Now there is something to be aware of both in view components and regular MVC controllers, if you have a model that is just a simple string, and you try to pass that model to the View method, what the MVC framework will think you are doing is specifying the name of the view that you want to render. So if your model is a simple string, the safest thing to do is explicitly specify the name of the view here, and then pass your model in as the second parameter. The default view for a view component is a view called default, but I'm just going to explicitly specify default here. Let me save GreetingViewComponent, and now we have to build this view. The logic for locating a view for a particular component is very similar to the logic for locating a view for a controller action. The MVC framework is going to search through a predetermined set of directories. Now, if I'm always using this view component from views that are in the Home folder and rendered by the HomeController, I can place that view for the view component here in home. But since I'm using this from the layout page, it would be a good idea to put my view component view inside of the shared folder. Now, inside of this folder I need to create a folder named components, and inside of this folder I need to add a folder that matches the name of my component. SO I need a folder called greeting, just like the HomeController uses views that are in the home folder. The GreetingViewComponent will use views that are in the Greeting folder of the component's folder. So we're just pushed down an extra layer, and now it is inside of this folder where I can add a view. So let me select an ASP.NET view page. I need the name to be default.cshtml. And it's inside of here where can use all the techniques that we've used for Razor views throughout the course. I can have a model type, I can say the model type is string, I can use markup, I can use Html helpers, I can use tag helpers, I can say today's message is an @Model to output that string into the HTML. And now let me save everything and show you the problem that I alluded to earlier. Let's refresh the homepage. And what I'm seeing the screen is System.Threading.Tasks.Task. Microsoft.AspNetCore.HtmlContent, what is all this mess? Well, technically inside a layout.cshtml, when I say Component.InvokeAsync, this is an async that returns a task of HTML content. And since that is an object that Razor really doesn't know what to do with, it essentially calls ToString on that object and we know that in .NET if you call ToString on an arbitrary object, you typically get back the type name for that object. That's what we're seeing here. What we really need to do is unwrap this Html.Content from the task that is encapsulated it, and put this HtmlContent into the view. Razor knows how to work with any object that implements IHtmlContent. And like I say, this is a common problem I've been seeing run into, and the easiest way to do this is to use the C# await keyword. I want to await the results of Component.InvokeAsync, that will strip the task away, and leave me with just HtmlContent, and now if I refresh the layout view, I can see my view component as working, and I get the correct message. And now this should appear on every page, since it's in the layout view. And again, the important part here is that the beautiful thing about a view component, it's almost like a miniature MVC request inside of an MVC request. I get to instantiate a class that can inject its own dependencies, execute a method that can build its own model and return its own views, and the ViewComponent doesn't need to know anything else about what's going on in the request, what controller we're inside of, what view is rendering, it has its own little focus responsibility. Now for those of you who are comfortable doing Async for programming in C# and you're familiar with the Async await keywords, you might be wondering why the layout view has to await Component.InvokeAsync, but yet my underlying view component is not asynchronous, this is a synchronous method. Well, this is far beyond the scope of this course. Perhaps I could do something in the future with more details on asynchronous programming with something like the MVC framework. But for those that are comfortable with the topic and know a little bit about this, you can turn this into an asynchronous method. Instead of having an asynchronous invoke method, I could have an asynchronous InvokeAsyncMethod, that means that this result would need to be wrapped into a task, and then I could make this an Async method and do or call asynchronous APIs inside of the method. I don't really have any asynchronous work to do here. If I was using a service that offered an Async API, or if I was using something like the Entity Framework's APIs where instead of calling ToList, I can call TopListAsync, or instead of calling save changes, I can call SaveChangesAsync. That would give me my task that I need inside of an Async method. I can simulate that scenario by simply wrapping my view result in Task.FromResult, and then the C# compiler will be a little bit unhappy, because of the way generics and the inferred typing works here. I'm going to need to explicitly pass a generic type parameter to FromResult to make sure that my task is typed as a task of IViewComponentResult. But now at this point, the C# component should be happy, Component.InvokeAsync will actually invoke an asynchronous method in my view component. And you see that I still get the message on the screen.

Summary

In this module we worked with layout views and partial views, as well as new features in this version of ASP.NET MVC, features like tag helpers and view components, and the view imports file. Using all of these techniques we learned about, they call allow you to create maintainable view code by avoiding duplication and decomposing complex views into smaller pieces. That's the ultimate goal of many of these features. They give you the ability to create good maintainable code.

ASP.NET Identity

Introduction

Hi this is Scott, and in this module we will set up the ASP.NET Identity framework to implement forms authentication. There are many options to choose from for identifying your users, including Windows authentication and all of the third party identify providers, like Google, Microsoft, Facebook, and GitHub. We're going to choose and focus on building up a traditional forms authentication scheme from scratch, so we can understand the primary pieces of the identity framework. Let's start with an overview.

ASP.NET Identity Overview

The identity framework is another dependency that we will add to our application in the project.json file. This framework allows us to add features where users can register and log in with a local password. The framework also supports two-factor authentication, third party identity providers, account lockouts, and other features we won't have time to cover in this video. We're going to focus on the scenarios where a user can register and login and logout. To do this, we're going to need to create a User entity. This class will inherit from a base class in the identity framework, and the base class gives us our standard user properties, like username and email address. We can include as many additional properties as we want on this class to store information about our users. We can store their favorite cuisine or favorite color, for example. We need to take this User class and plug it into a UserStore class provided by the Entity Framework. The UserStore is the class that our code will talk to create users and validate user passwords. Ultimately a UserStore will talk to a database, and out of the box the identity framework supports the Entity Framework and all of the databases that can work with the Entity Framework. But you can implement your own user stores to work with any data source. In order to work with the Entity Framework properly, our user class will also plug in to an IdentityDb class. This is a class that uses an Entity Framework DbContext to do the actual database work. We'll need to include this IdentityDb into our application by having our existing DataContext class inherit from IdentityDb instead of the Entity Framework's DbContext. So it's the IdentityDb and the UserStore that work together to store user information and validate user passwords, the hashed passwords that are in the database. And then there's just two more pieces of the framework to know about. One of these pieces is the SignInManager. As the name implies, the SignInManager can sign in a user once we've validated their password. We can also use this manager to sign a user out. With forms authentication, the sign in and the sign out is done by managing a cookie. When we tell the SignInManager to sign a user in, the manager issues a cookie to the user's browser and the browser will send this cookie on every subsequent request so that we can identify that user. Reading this cookie and identifying the user, this happens in the final piece of the framework, the Identity Middleware. We'll need to configure this middleware into our application pipeline to process the cookie set by the SignInManager. We'll also see some other features of this middleware. And as we go along, we're going to learn how to use the Authorize attribute to restrict access to specific controller actions. We'll also see new scenarios for ViewModels, model validation, controllers, and Razor views. So this will be a good overview of putting together everything we've learned in the course so far.

Using the Authorize Attribute

So far in our application, we will allow anonymous users to do anything. They can create restaurants, edit restaurants, and view the details of a restaurant. We want to change this behavior so that in the future anonymous users can only see the list of restaurants on the homepage. Every other action requires the user to identify themselves and sign in. We will do this with the Authorize attribute. You can place this Authorize attribute on a controller or on an individual action inside of a controller. When we place the Authorize attribute on the controller itself, the Authorize attribute applies to all of the actions inside. The MVC framework will not allow a request to reach an action protected by this attribute, unless the user passes an authorization check. By default, if you use no other parameters, the only check the Authorize attribute will make is a check to ensure the user is logged in, so we know their identity. But you can use some parameters to specify custom authorization policies. There is also an AllowAnonymous attribute. This attribute is useful when you want to use the Authorize attribute on a controller to protect all of the actions inside, but then perhaps there is one single action or one or two actions that you want to unprotect and allow anonymous users to reach that specific action. Let's see how these attributes work in our application. Inside the application, I am an anonymous use and I am allowed to come in and edit and make changes to a restaurant. I want to change this and force the user to log in and identify themselves before they can edit a restaurant. So let's open up the HomeController, and if I just want to restrict access to one or two actions, like getting the details of a restaurant, I could add an Authorize attribute to this action. The Authorize attribute is in the namespace Microsoft.AspNetCore.Authorization. I'm going to bring that namespace in. And as I say, if you have fancier authorization schemes, there's parameters that you can pass to this attribute to enforce a specific policy. A policy is something that you can configure in Startup.cs. That's a little bit beyond the scope of this course. We just want to make sure that a user is authenticated before they can get into an action, so just a plain Authorize attribute. And I want to protect most of the actions inside of the HomeController, so I'm going to come up to the class definition and place that attribute here instead. But I do want to allow anonymous users to get to the list of restaurants, so I'm going to place the AllowAnonymous attribute on the index action, that overrides the Authorize attribute for this specific action. Now let's save the HomeController, come back out, and refresh the application. I can still see the list of restaurants. Now let me try to edit a restaurant, but before I do, let me open up the developer tools in Chrome. I can do that with the F12 key in Windows. And let's look at the Network tab as I make this request to edit a restaurant. What the user sees is just a blank page. In the developer tools, I can see what the MVC framework did was return a status code of 401 Unauthorized. Unless the user has his developer tools open, they may not know that there was an error that came back from the server that told them they were unauthorized. And this is where the identity framework can step in and help. The identity framework can actually detect when an application wants to return a 401 status code, because the user is not allowed to perform some specific action, and the identity framework can turn that into a login page and allow the user to get past this problem by authenticating themselves. We'll see how that works once we get the Entity Framework installed and configured. For right now, we can see that the Authorize attribute is working, and we will need to start working with the identity framework to allow users to register and log in to the site.

ASP.NET Identity Configuration

Now we've reached the point where we need to install and configure the identity framework, and I'll warn you that this takes a little bit of work. I also want to point out that if you go into Visual Studio and create a new ASP.NET Core application, and you select the full web application template with authentication set to individual user accounts, that new project will include all the bits of the identity framework set up for you. But since we started from an empty project, we'll need to set up the Entity Framework from scratch, and this is, I think, a really good way to learn about all the pieces that are in the full application template. It's a bit overwhelming if you haven't worked your way through all of the code in detail. So if you want to know what is happening inside of that template behind the scenes, this is a good way to learn. What we need to do to get started is to install a dependency, which is the Microsoft.AspNetCore.Identity dependency, except we will actually install the Microsoft.AspNetCore.Identity.EntityFramework dependency, and that will give us an implementation of the identity framework that works with the Entity Framework. And therefore, will work with our SQL Server database. You can have other implementations of that core identity dependency that can work with other types of databases like MongoDb. Now once my dependencies are installed, the next step we're going to take is to create a custom User class. This class will contain all the information that I want to store about a user. For this application, I'm going to inherit from a class that is provided by the identity framework, and that class will give me all the essentials, like the username property and a place to store the hashed passwords. I will also need to modify my OdeToFood DbContext class to inherit from the identify framework's IdentityDb class. The IdentityDb gives me everything that I need to store user information with the Entity Framework. Then once I have a User class and a DbContext set up, I will need to configure the identity services into the application during the ConfigureServices method of a startup class. Just like when we need to add services to support the MVC framework, the identity framework needs services added to the application in order to work. These services include services like the UserStore and SignInManager. We will be injecting those services into our controllers to create users and issue cookies at the appropriate time. Finally, during the Configure method of the Startup class, I'll need to add identity middleware. The middleware will not only help to turn cookies into a user identity, but will also help to make sure a user doesn't see an empty page with a 401 response. Let's get to work on these steps now. Inside of the project, let's open up the project.json file directly, and what I want to do is add a dependency on Microsoft.AspNetCore.Identity.EntityFrameworkCore. I will pick version 1. Then I can save project.json and once Visual Studio has restored this package, we'll be able to add our User class. That appears to have worked. I'm going to add the User class inside of the Entities folder, because this does represent information that I want to store in the database. The name of this entity will be user. And I want to derive from a base class named IdentityUser. This is in a namespace provided by the Entity Framework, so I'm going to bring that in with Visual Studio, remove our unused usings, and I just want to show you by adding a member to this class the API that is available. By inheriting from my IdentityUser, I already have a user class that can store the email for the user, an ID for the user. There is also a hash of the user's password, their phone number, all of this information can already be stored in the database. And of course, the UserName property. If there's anything additional that I want to store about a user, like their favorite number or their favorite color, that's where I could add properties to this User class and customize it, additional information that I want for my users for my application. I'm not going to add any additional properties for this particular application, which means we didn't really need to create a custom user class, but I'm going to leave this here as a placeholder in case you want to customize anything for your users. What I need to do now is make sure that this User class becomes one of the DbSet properties on my DbContext. That way I can store and query user information. The easiest way to do this is to inherit not from the Entity Framework's DbContext, but from the IdentityDbContext that's provided by the identity framework. I just need to bring in the long namespace for that one also, and when I derive from this class, I can specify through a generic type parameter the type of user that I want to store. So this is the type that we just created, the User class in the Entities folder, that is how I tell the identity framework this is the information I want to store. And now I just want to show you, if I bring in the System.Linq namespace so I have the Linq operators available, that in addition to the restaurant's DbSet property that we have defined on this class, I have also now inherited a number of DbSets from my base class. One of these DbSets is the User's DbSet. This will become a table in SQL Server, and if I ever want to query that table directly via my DbContext, I can always walk up to the User's property on my OdeToFoodDbContext, and I can do the traditional filtering and sorting and finding a user by a specific ID. What we'll see when we build this application out is I generally don't go directly to that DbSet of User; instead I work through other services that the identity framework provides, and all I really need to do to get the user stored in my DbContext is just derived from this base class. At this point now, we can go into Startup.cs and work on our configuration. Let's start inside of ConfigureServices. There's two bits of information that I need to add in here. The first is I need to add in the core identity framework services. I do that with AddIdentity, and this method takes two generic type parameters. You'll see this as a recurring theme with the identity framework, because they want it to be extensible, they want it to be flexible, and it is designed to be able to work with your type of user entity, and also your type of role entity. The two generic type parameters here are first the type of my user, that's the user entity that we just created, so I'm customizing the identity framework with my user, and the second generic type parameter is the type of role that I want to use, and for this I'm going to use a built-in class provided by the identity framework. I will need to bring in that namespace. The name of this class is IdentityRole, and although we will not be using any roles in this application, IdentityRole does represent another entity that you can customize when you work with the identity framework. The second bit of information I have to provide is how is the identity framework going to save information into a database somewhere? For this application, we're going to be using a DbContext derived class, we're going to be using the Entity Framework, so I want to add the Entity FrameworkStores, and with this particular method I need to specify the type of the DbContext that the framework will use to store User information and look up passwords and so forth. That is, of course, our OdeToFoodDbContext. And at this point, I will be able to inject identity framework services into my code so that I can use the features provided to manage users and manage sign in attempts. The other piece that I need to add is the middleware. This happens inside of the Configure method, and it's very important where I place this middleware. If I add the middleware too late, it might never have a chance to process a request, and if I need to authorize users inside of my MVC controllers, then the identity middleware needs to come before the MVC framework sees a request, and that gives the identity framework a chance to turn cookies into users and process 401 requests successfully. At this point, I should be able to press Shift+Ctrl+B to build the application, just to make sure that we don't have any errors, and it looks like the build succeeded. So my next step will be to add migrations to my project so that I can update my OdeToFood SQL Server database with the schema that the identity framework needs to work with. We'll do that next.

Identity Migrations

Anytime that you make a change to one of your entity classes or to your DbContext derived class, chances are that you will have to create a new migration and apply that migration to your database to bring this schema in sync with what is in your code. And this is certainly the case in our situation, because the IdentityDbContext that we now derive from, this class contains its own DbSets. And this class wants to create a schema to store all the information about the entities like the User class that it has to manage. So now just like we did before in the Entity Framework module when we added the Entity Framework to the application, we're going to go into the Package Manager Console, and I want to add another migration, let's call this one Identity. This will inspect the state of the database, compare it to the entities that I currently have, and generate a new migration, and this migration is going to add things related to that identity framework, so things like a table to store, ASP.NET roles, store users. I can see inside of here things like the username that we're going to store that has a maximum length of 256 characters. Let's go ahead and apply this to the database, but first I just want to refresh the OdeToFood database to show you the only table of any significance right now is the restaurants table. But over in the Package Manager Console, let's do an update-database, and that operation has completed. If I come in and refresh my database now, I will see I now have tables to store things like Users. And inside of Users we will notice columns or many of those properties that we looked at before, the ability to store an email for a user, their username, of course we do not store passwords, we store a hash of the password. And again, if you wanted to query any of this information directly, at this point you could instantiate or inject an OdeToFoodDbContext class, and there will be a user's property that you can use to execute Linq queries against that ASP.NET User's table. But in this application, we're going to be able to do everything that we need with built-in identity services. Those services already contain the ability to create a user and validate a user's password. And they have the ability to do all those things safely without me having to worry about topics like what is the best hashing algorithm to use. And now that we do have a working database, it's time to start adding some registration login and logout features to the application.

User Registration

Now that we have our software configured and we have a working database schema, let's come into the application and try to get to the Edit view again. Remember when I did this previously, my application just responded with a 401 status code Unauthorized, and for the user this was just a blank screen. Let me refresh this view now that we have everything in place, and what I receive is the message Not found. Here's what happened. Down here you can see my browser still requested the edit page, /home/edit/1. The response now instead of a 401 response was a 302 response, that's a redirect response. That's the identity services stepping in and saying we can see the user doesn't have authorization; let's try to redirect them to someplace where they can log in and provide credentials. The default page to log in is /Account/Login, that is the default inside of the identity framework, but when you are configuring the identity framework, this is one of those options that you can change. If you didn't want the URL to be /Account/Login, you can choose another login URL. Currently, since we do not have a controller named account, this request cannot be handled by anything in our application or by the MVC framework, so we are falling through to that last bit of middleware that we have configured in the pipeline that just says Not found, that's inside of an app.run block of middleware. Ultimately now what we need to do is build this account controller with a login action and allow a user to log in. But before a user can even log in, they will need to register on the site and create a username and password. Login and register can both be features of an account controller, so let me right-click on the Controllers folder, I want to add a class, this will be AccountController. Just like we've done before, we will derive from the base controller class provided by the MVC framework, and I'm going to remove my unnecessary usings. And now I need to set up a feature where a user can register for this site. This is going to be much like an edit form. The user wants to register, so I first need to display a form and allow the user to fill out some information, and then they can post that form to the site. If everything is good, we'll save their information to the database. So let's first create an action that will respond to an HttpGet. We'll return an ActionResult, the name of this will be Register, so if I come to /Account/Register, I'll be able to register myself as a new user, and this will simply return a view. There is nothing to look up, the user's going to provide me with all the information I need. Now before I build the view, I often try to think about the ViewModel that view is going to use. That gives me a better idea of what the view needs to display for the user. So I'm going to right-click on the ViewModel's folder and start thinking about what information do I need to register a user. Let's call this the RegisterUserViewModel. I will add this to the project. And I will certainly need the user to give me their preferred username. I would also expect them to give me the password that they want to use, and like all good registration pages, I want them to confirm that password. Since they're not going to see what they're typing into the password box, we'll make them enter the password twice to make sure they don't have any typos. We will make the username Required, that will make me bring in the data annotations namespace, and as we saw in the database schema, the maximum length for a username is 256 characters. We're also going to make the password required, and I want to use the DataType annotation to make sure the view displays this as a password field. And for ConfirmPassword, I'm going to say that this is also a DataType password, and I want to make sure that Password and ConfirmPassword match up, that they're the same string. I can do that with another attribute that we haven't looked at yet, the Compare attribute. With Compare I can give the name of the other property, so compare this to password and make sure they match. I can also use in C# 6 the name of operator to generate that string. Let's now remove the unnecessary usings that are in here, close this file off, and we can think about that ViewModel as we create the view. I will need to add a new folder to our Views folder for views associated with the account controller, so let me add a new folder named Account, and it is inside of Account where I will add a new item, and this time select ASP.NET and MVC View page. I want this to be named Register.cshtml. Once this view arrives, I'll delete everything in here. Now I know my model for this, I want this to be a RegisterUserViewModel. We do not have a using statement for the ViewModel's namespace currently in our ViewImports file, but that's typically a namespace that is heavily used by View, so let me go ahead and add a using for OdeToFood.ViewModels, save our ViewImports, come back to the Register view, now that type name is recognized. I can go ahead and set up a title for this page by setting ViewBag.Title = Register. I could also have a little bit of a heading here, Register, and now I just need to create the form. I want to make sure that this form will post to the web server, and I might want to explicitly say that the anti-forgery token should be generated here. And now I just have to think about the information that I need to collect to populate my RegisterViewModel. I know, for example, that I will need to give the user the ability to input a username. So let's have a label for the Username property of our ViewModel. Let's also create an input for the username of our ViewModel, and finally, a span with validation messages for the username of our ViewModel. And speaking of validations, I also want to add an additional validation section up here at the top of the form. I want a div that will display an asp-validation summary. A summary gives you the ability to display all model errors or only errors associated with the model itself. Let me tell you quickly the difference between these two. ModelOnly errors do not include errors that are associated with a specific property. So if Username is required and the user doesn't provide us with a username, ModelState will be invalid and there will be an error associated with the username. That error will appear in this validation. If I also wanted that error to appear up here as a summary of all the errors, I could set asp-validation-summary= All and display all the errors associated with the model everywhere. But I'm going to select ModelOnly. That means these are errors that are not associated with a specific property. We'll see why that's important later, but during registration and log in, you can have situations where you violate a business rule that you can't really apply to a single property, so something like not being able to confirm passwords. So I want to provide a space here where those types of errors can display. And now I will also need inputs for the user to enter a password and confirm that password. And since that code is very much like the code we just typed, I'm just going to grab something offscreen and paste it here, but all I've added is a div that provides a label for the password and input for the password, validation messages for the password. I don't have to worry about setting input type equals password, because again, asp-for will see the data annotations on this ViewModel property and see that it is a DataType.Password and set the type of this input for me appropriately. And then I also have a label and input a span that allows the user to confirm that password, and then a Submit button. When the user clicks that button, we will posting back to the web server. So let me go ahead and implement an action that will receive an HttpPost that will also validate any antiforgery token that is in the request, and this one will be called also Register, because we'll be posting back to the register endpoint. And I will expect this to receive from that from a RegisterUserViewModel as input. I just need to bring in the namespace, OdeToFood.ViewModels. And now, inside of here, I'm going to need to interact with the identity framework and make sure that the user is valid, then tell the identity framework to create the user, and then since they've just created the account, go ahead and log the user in. We will look at implementing those steps in the next clip.

Creating a User

Of course, one of the first checks that we always need to make when we are posting back form values is to check if our ModelState is in a valid state. And if it is, we'll create a user; otherwise, we will return the same register view, allow the inputs to be populated from ModelState, and allow the user to try to fix any problems that might have occurred. There was some sort of validation error. Otherwise, we're going to start working with the identity framework's API to create a user. And in order to use that API, we're going to need to bring in some identity framework services. The first service that I will want is a UserManager service. This UserManager service is customized with the type of my user, which is not RegisterUserViewModel, it is just User, so I need to bring in the namespace for OdeToFood.Entities. I also need to bring in the namespace for Microsoft.AspNetCore.Identity. And as the name of this service would imply, this is the service that allows me to do things like create a user. Yes, it is technically possible to go directly to a DbContext class and access that ASP.NET User's table, but I want to use the API that is available from the userManager whenever possible, because then I can be sure that the user is created in a safe manner. The other service that I want is a SignInManager, also customized by my type of user. I'll call this signInManager, and as the name would imply, this service will allow me to officially sign in a user or sign out a user, it will take care of issuing proper cookies to the browser, so that the user is authenticated on the next request, and of course to make use of these services, I will need to store them away in some private variable. So, userManager = the incoming userManager parameter and an _signInManager will = the incoming signInManager parameter. And now I'll just use Ctrl+Period in Visual Studio to generate a field for both of these. And I can now start using them inside of the postback method here. The first thing we'll need to do, if ModelState is valid, we will want to go out and try to create a user. And again, you can see an API here that will allow me to do things like change the user's email, change a user's password. In this case, I don't want to change anything, I want to create a user, so I will invoke CreateAsync. So one problem we'll have to address here is that this is an Async method. And that means I really need to change my controller action around to be an Async method, so I will add the async keyword here. For Async methods the return type is wrapped in a task. I will need to bring in the namespace, System.Threading.Tasks, and this is just the easiest way to deal with Async methods in C# if you're not familiar with AsyncAwait. I'll use the async keyword here on the method definition, and the await keyword to grab any results or wait for the result of invoking another Async method. Those pieces are in place, so again, this method requires a user to be passed in, so this is one of those situations where I will instantiate a new user. I don't want to take a user as input here, that might allow someone who is filling out a registration form maliciously to give me more information than I expect. The only thing that is in this model are the things that I expect from the form, and one of the pieces of information that I expect from the form is the UserName, so copy model.Username into the Username property of my user. The other piece of information in the input ViewModel is a password, but there is no property available to store a plain text password on the user. Instead, I can pass that password directly into Create Async, and if everything is good, that will create the user record inside of my database. This operation will return a result. Let me call that createResult. CreateResult is the result of awaiting this CreateAsync method, and now createResult will tell me if this operation succeeded or not. So you can see there's two important properties on this createResult. There's a Succeeded flag, did the operation succeed or not? And then there's an Errors collection if something went wrong. If this result succeeded, the user has successfully registered, and what I could do now is take the next step of just going ahead and signing in that user officially. That is something I can do with the signInManager. It exposes a method, SignInAsync, which is why I'm using the await keyword here. And all I need to do is pass in a user that I want to be signed in, and then I have to pass in a flag isPersistent or not. That is, what the signInManager will ultimately do is issue a cookie to the browser. That cookie will be an authentication ticket that the browser sends back on every subsequent request. And the question is, do I want that cookie to be a session cookie and go away when the user closes the browser, or do I want that cookie to be persistent and still around after the user closes the browser and reopens it? Are they still going to be signed in at that point? I'm going to set this to false for now. We do not want that to be a persistent cookie. At this point, the next time the user visits a URL on our website, that authentication cookie will come up, the identity framework will see the cookie, transform it into an actual user identity, and we'll see how to take advantage of that in just a bit. But what do I want to do with the user now? Well, I do not want them to sit here on the registration form and try to refresh it. Instead I just want to redirect them somewhere safe. So let's redirect them to the Index action on the HomeController. They should now be able to click links to create a restaurant or edit a restaurant. If that result did not succeed, something went wrong in the business logic with the identity framework, and what I need to do is look at the errors collection that is in createResult, and somehow propagate that information back to the user and back to the view, so that we can display the errors. Let me write a foreach statement that will iterate through each error in the createResult.Errors collection. And here's what we can do. We can walk up to ModelState, and there's an API here that allows me to add a ModelError. The first parameter to add model error is a key. If I specify a key here, this will associate the error with a specific property on the model for the view, and that would show up in a validation that is associated with username property. With these errors, I don't want to associate them with any specific property, so I'm going to leave a blank key for AddModelError and simply add error.Description to the ModelStateErrors. Since these errors are not associated with a specific property, they should appear in the validation summary. They are ModelOnly validation warnings. At this point, I should be able to save all my files, and now let's try this out, let's go to /account/register, and here is the form for me to register. It's not a pretty form, it could use some css styling, but let me enter a username, a password of 123, confirm a password of 123 and try to register, and what I'll see is my validation summary came back with a number of errors from the identity framework. These errors are all related to password validation, but I can see that I need a much more stronger password. So let me try to enter in a password that might work. But this time I made a typo and my confirm password wasn't the same as password, so I get this validation message. Let's try it one more time, very carefully now, try to get a confirm password that will match my password and that is a strong password. And since I now have made it back to the homepage of the application, I'm going to assume that registration worked. Here's a couple ways to verify it. Let's go into SQL Server Object Explorer and look at the users table. I'm going to right-click and actually view data. Here I can see I do have a record there, that looks good. This record does have a username of sallen, and my password has been hashed. Another way that I could verify that I am in the database now is that the identity framework will issue a cookie when I'm signed in. So if I go to the Application tab of the Google Chrome Developer Tools, let's look at cookies that are associated with the site, and I can see I have two. One is an antiforgery cookie. That's part of the information that validate antiforgery token that attribute look at, and then I also see a cookie named AspNetCore.Identity.Application. That name you can customize, but that is my authentication ticket that the browser will send along on subsequent requests so that I am authenticated. So now that we have the ability to register, let's look at a login feature.

Log in and Log Out

As an authenticated user, I now have the ability to come in and edit a restaurant, but I also need the ability to log out, and once I log out, I'll need the ability to log in. I'd like to have this ability on every page of the application, in other words, have some piece of UI that tells me if I'm signed in or not, and that typically means working with the layout page, since I want something on every page of the application. And this is actually a good place to use another component. What I want to do is await the results of invoking a component that we haven't written yet, but instead of cluttering up the layout view with some sort of UI to display login and register and logout links, let's just create a new component and spell component correctly, and we will call this the LoginLogout component. With that in place in my layout view, let me go ahead and come over to the View Components folder, we're going to add a new class, this is the LoginLogoutViewComponent. Like the other View Component that we wrote, this will need to derive from a base class, ViewComponent, that makes me bring in the namespace Microsoft.AspNetCore.MVC. And it turns out this component is very simple to write at least the C# logic, because this particular component doesn't even need to build a model. I just need the conventional Invoke method, and to return a view result that will render the default view. I don't need to build a model, because all the information I need about a user is available through contextual properties inside of every view. Let me show you what I mean, let's build the view for this. This is a new component, so I will add the folder LoginLogout. Inside of there I want to add a new item, which is the default view, so let me select ASP.NET, MVC View Page, the name of this will be Default. And the reason I don't need a model is because there is a user property available inside of every view. And this user property will give me all the information I need. So first I need to figure out is the user authenticated or not? I need to display a different UI depending on if the user is authenticated or not. So let me write an if statement, if the user, and now I can go to the Identity property and ask, is this user authenticated? If so, we'll display this UI; otherwise, we will display this UI. Let's work on the authenticated part first. If a user is signed in, I might want to say Hello, and then display the username or the name of that user. And this is not the friendly name, this will be the username, like sallen. If you want additional information, that's where you might need to build a ViewModel, query the user's table, bring that information in, and send it to this view. Now I also want a button that the user can press to sign out, and I will want that button to be inside of a form that will issue a post to my server, that's the safest way to do it. It's not going to post back to the ViewComponent here. I need to explicitly say this will go to the account controller, and we will create a new action Logout to respond to this post. I'm also going to explicitly say that I want to create an antiforgery token here. Inside of this form, all I need is a button. So an input whose type is equal to submit, and will display the text of Logout. Let's see if this is working in the UI. If I refresh my view, my ViewComponent should now be rendering on every page and it's going to display Hello, sallen, and a Logout button. Let's implement that Logout feature. Before I do, I'm just going to leave some short text here that just says anonymous. I'll put that inside of a span. That just allows me to know when I'm not authenticated. We'll come back and add login and register links in just a bit. For now, I want to swing over to the AccountController, and I just need to write a fairly simple action. I need an action that only responds to an HttpPost that will validate the AntiforgeryToken that comes in, and this will be a result that is the result of an Async method. I know that because all of the identity framework APIs are asynchronous. I need to call one of those APIs, so I'm just going to make this an Async method from the start. It is the Logout method. And it's a very simple process to logout a user, I just need to go to the signInManager and tell it to SignOutAsync. That will remove the cookie from the user's browser, and that authentication cookie will no longer be there. Now I need to figure out what to do with the user. Well, if they just signed out, there's only one safe place where I can send that user. I should redirect them to the list of movies that come from the Index action of the HomeController. Let's try this. I'm going to refresh to make sure I have the latest code here, and now I'm going to press the Logout button. I can see I am now anonymous, and I'm back on the homepage. That's good. Now let's create our login and register links. That will be in our ViewComponent view, so instead of displaying this text, let's have an anchor tag that displays the text register. When this link is clicked, we will go to the AccountController and go to the Register action that we created earlier, so the text for this is Register. I'm going to make a copy of that link, because I also want a link that will go to a new action that we haven't implemented yet, and that will be the Login action. And now I need to implement a login page. I just want to show you how this should work. If I try to edit anything right now as in anonymous user, the identity middleware will automatically try to redirect me to /Account/Login. Just like if the user clicks the Login button, I want that to go to /Account/Login. But I do want to point out the query string parameter here, ReturnUrl, because ideally what my application will do is I'm trying to edit a movie with an Id of 1. I was denied access, I'm sent over to the Login screen. Once I login, the application should redirect me back to the place I was trying to get to, which was /home/edit/1, and allow me to proceed with my work. So that's something to keep in mind as we implement this login action. Let's go to the AccountController and build this. Just like registration and editing a movie, I'm going to need two sets of actions. One that responds to a GET request and presents me with a login form, and another login action that responds to a POST request, validates the form inputs, and potentially signs in the user. Let's take care of the GET request first. So, HttpGet on a method or an action, a public action that returns IActionResult, we will call it Login, and all I need to do here is return a view that will allow the user to log in. And again, before I implement that view, I need to think about the information that I need from that view and what information do I need to log in a user. Let's create a ViewModel for this scenario. So let's add a class. I will call this the LoginViewModel. It is different information than I need for registration, because typically all I need here is just username and password. So let's create a property of type string for Username. I'm going to mark this as Required. That will require me to bring in the DataAnnotations namespace. Let me get rid of the namespaces that we're not using. I'm also going to need the user to input their password. I will mark this as Required and also give it a DataType of DataType.Password. I also might want to give the user the choice, do I want a persistent cookie, or a session cookie? That would be the RememberMe flag that we see on a lot of websites. In order to get this to display correctly, I'll add a display annotation here, Remember Me with a space, and finally, let's not forget about that return URL. I want to have a property named ReturnUrl. This will automatically grab that information out of the query string for me, and put that information into my ViewModel. That's good. So with the ViewModel in place, I can now think about the view that is required to log in. Let's now add a new item, which is an ASP.NET MVC View Page called Login, and because this view isn't particularly any different from views that we've had before, let me bring in some code from offscreen so you don't have to watch me type everything, but I will explain what I've just done. I want a Login ViewModel as my model. I want to set the title of this page. I want a form that will post back to the same action that it came from, so /Account/Login, and that will include any query string that's in the URL. And now I just need the normal validation summary for the model, I need a label input and span for the username and for the password, and for RememberMe. Since this is a Boolean, asp-for, that tag helper is smart enough to make this a checkbox, and then I just have the Submit button that will post back to the web server. Let's implement the post version of login. So here I need an action that responds to an HttpPost that will validate an antiforgery token, and since I'm going to be working with identity framework APIs, I'll just make this an Async method from the start. So, it returns a task of IActionResult, its name is Login, and I expect to receive a LoginViewModel. So all of the form inputs and the query string, all that information is placed into my input model. As usual, the first thing I'll do is check to make sure that ModelState is valid, otherwise, down here just return a view and allow the user to try again, perhaps they forgot to enter their username, and now how do I validate the user and their password? That again is the job of the identity framework, and it's the job of the signInManager. The signInManager has an API PasswordSigninAsync. This is where I need to pass in the username for the user, the password for the user, the flag about whether to make this a persistent cookie if it's successful or not, that is the RememberMe flag, and then a flag to lockout on failure. In this application, we're not locking users out, so I will set that to false. And this does return a result. So the loginResult would be the result of awaiting that asynchronous method. And we just try to format the code here so it fits a little bit better onto the screen. And now this is where things get interesting. Just like creating a user, this loginResult has a Succeeded flag, so I need to check if the loginResult succeeded or not. And I also want to point out that loginResult, unlike the createResult, does not have an errors collection, but it does have some flags about the user IsLockedOut or IsNotAllowed or RequiresTwoFactor authentication. These are all options that we don't have time to cover in this course, but things like account lockouts and two factor authentications and confirming emails, those are all capabilities that you can have with the identity framework. All I want to do right now is check if a loginResult succeeded, and if so, I potentially want to send the user back to this URL that they were trying to get to, like if they were trying to edit a restaurant. That would imply that I just return a redirect result right away, but I need to do some additional checks. I need to check that the redirect URL is a local URL. So there is a URL helper property that I have inside of my controller, and one of the methods there, IsLocalUrl, I just need to pass in the ReturnUrl that I have, and ask this class to check if it's a local URL. The reason I do this is so that I do not have a security problem in my application with open redirects. Again, a little bit beyond the scope of this course, but if you're a web developer, you should go out and do some research and look up what is an open redirect. This will help prevent open redirects. If it is a local URL, then I am free to redirect inside of this application, so I'm just going to return a redirect result and say please go to this URL. Redirect is something you can use if you have the URL. If it is not a local URL, then potentially there is some sort of problem here, and I'm going to do something safer, which is I'm just going to redirect to the homepage of the application, so Index. And now if the result did not succeed, we're going to fall through this logic, and we're going to end up returning the login view again, and I just want to make sure that there is some sort of error that appears in the validation summary. I'm going to say ModelState. Let's add a model error that is not associated with any property, and just say Could not login. This could cover a variety of circumstances. This could appear if the user enters the wrong password, or enters the wrong username. Generally, because of security, we don't give away too much information, we don't want to tell the user that they had the wrong password, because that would imply that the username is there. So we'll just have a generic message here, Could not login. And now, let's try it all out. Come back to the application. Let's go to the homepage of the application. I'm currently an anonymous user. Let's try to log in this way. This presents me with a login form, so I will enter my username and my password and try to log in. That seems successful. I now have my username up here. I can go in, I can edit a movie. What happens if I log out and try to edit a movie? That will redirect me to the login page. Let me try to log in again. This time, however, I'll use the wrong password just to see if we get Could not login, which we did. Let me try this one more time entering the correct password. Hopefully I will go directly to that restaurant that I was trying to edit. And so that was quite a bit of work, but it should also give you a lot of insight, not only into how the identity framework works, but also how to put together an application with the MVC framework.

Summary

In this module, we worked with the ASP.NET identity framework to add authentication and authorization features to the application. Thanks to the Authorize attribute in the MVC framework, we now protect the edit and create actions from anonymous users, and we created a new account controller with associated views to use services of the identity framework, services like UserManager and SignInManager. We used those services to implement the login, logout, and register pages for the app. Now one topic that we haven't talked about with all of the forms that we've been building, is how to apply some client-side validations. We'll look at that topic in the next module.

Front End Frameworks and Tools

Introduction

Hi this is Scott, and in this module we will turn our attention to front end JavaScript and CSS libraries. We will look at tools that we can use to manage and install these libraries and frameworks. We will also add some style to our application. And finally, we will learn how to support client-side validation in development, as well as production. Let's get started with an overview of the tools that are in play.

Front End Tools

If you have been using Visual Studio at all in the last few years, you probably know about NuGet. NuGet is the package manager for .NET. Behind the scenes the dependencies that we've installed in our application, dependencies like the Entity Framework, these dependencies are managed by NuGet, which can download the software bits and place them on our file system. For a period of time, NuGet with ASP.NET Core was only going to support .NET related binaries, but the team has promised also to support content packages, where content packages can install static files like the jQuery JavaScript library. For reasons that I will explain later, however, I won't be using NuGet to install the front end libraries that we need. Bower is another package manager, a package manager specifically for front end work, and it's become popular over the last few years. If you have used any of the pre-releases of ASP.NET Core, you'll know that Bower is the suggested tool for managing front end libraries with ASP.NET Core project. There is even some integration support for Bower in the Visual Studio tooling. However, for reasons I will explain later, I'm not going to use Bower in this module. You'll find lots of Bower content on Pluralsight if you want more information. I'm going to show you what I think is a simpler approach. Bower is a Node.js tool that you install with npm, and npm is Node's package manager. So, if you're using Bower, you are already using Node and npm. Now the traditional use of npm is install libraries and tools for Node.js, but over the last year or so, Npm has also become more popular for managing front end libraries, and npm is actively working on improving support for front end libraries. This means if you want to use jQuery in your application, you can install jQuery with npm and skip using Bower and NuGet. Why would you do that? Well, you might use npm instead of using Bower, because one tool with one configuration file is easier than using two tools with two configuration files. And you might use npm instead of NuGet, because for any serious JavaScript work these days, some amount of Node tooling is almost required. All the best tools, compilers, and minifiers, they are all tools that run under Node.js. And this is the approach that I will show you in this module. We will be using npm to download the front end frameworks that we need, and then use those frameworks and libraries like Bootstrap and jQuery in the application. So the next step is to understand how to set up Node and npm for our project.

Command Line vs. Visual Studio

There's a few different ways that you can work with npm in an ASP.NET project. One approach is to use tooling and the support provided by Visual Studio. This is the approach that I will show you in this module. Another approach is to use Node and npm from the command-line. The command-line approach gives you flexibility and power beyond what the tooling in Visual Studio provides, but you may or may not need that power. There are other Pluralsight courses that can show you the command-line interface. The Visual Studio approach that we'll be using will behind the scenes use a version of Node and npm that Visual Studio 2015 installs by default with the rest of the web tools. If you are experienced with the command-line, I recommend you download and install Node.js from nodejs.org, so you have more control over the environment. In this module we will rely on the tools that Visual Studio has installed. And to see how this works as a first step, let's see if we can download the Bootstrap CSS framework.

Setting up npm

Inside of Visual Studio, we're going to see that working npm is just as easy as working with project.json. We will see a lot of parallels between project.json and an npm configuration file that we have to create called package.json. Project.json manages our server-side dependencies, frameworks like the MVC framework. We're also going to need to add a json configuration file for npm to manage our front end dependencies. This is as easy as right-clicking the project, I want to add a New Item, and I'm going to search the Install Templates for npm. This should bring me to an npm configuration file. I do want to leave this name here, package.json, and I will add this file to the project. Inside of this package.json, one thing that I want to make sure to change is the name here. I'm going to change this to odetofood. Ideally you want a name that has all lowercase letters and has no spaces in the name. Otherwise, a name that npm judges to be unsuitable will prevent npm from installing dependencies that we need. And now that I have this file on my project, I'm going to save it. I want you to watch over here in Solution Explorer when I save the file, you're going to notice we now have a dependencies mode that pops up, it said restoring there for a bit, and Visual Studio recognizes the fact that we are now using npm in the project. In addition to my server-side dependencies that are here under References, we're going to be able to see our npm dependencies listed here under npm. Currently we don't have any dependencies, but I want to install Bootstrap, the CSS framework. Now I don't want to install Bootstrap as a dev dependency, that's a development time dependency, something I would use during the build. This is where you would place tools that you would use to minify and concatenate JavaScript files together. What I want to specify is a dependency. Specifically, I want to install Bootstrap. You'll notice that I have IntelliSense help, just like I do inside of project.json, and I can specify a library name, and then a version number. I'm going to go with the latest version of Bootstrap, which is 3.3.7. Now I will save this file again. Notice my dependencies are restoring, and I should now have Bootstrap on the filesystem. This is just like saving the project.json file. Visual Studio will go out and use a tool to download the dependencies or the packages that I need. One question you might have now is, where is this Bootstrap.css file? Well, by default npm installs everything into a folder named node_modules. You won't see it listed here in the Solution Explorer, because by default it is hidden. And the idea is that node_modules is not really a part of a project, because it's something that you do not check into source control. All you need to check into source control is the package.json file. And then when you clone the repository for this project or download the code for the application, you restore the dependencies that are listed in package.json, and you never have to check them in. You can check the files in, many people do, but the only thing I need to make sure that I check in the package.json file. Now if I come over to the Solution Explorer window, up here in the toolbar there is a little icon that will allow me to show all the files that are on the filesystem. This includes folders like the bin folder, where our build output is placed. But now I can see node_modules, and inside of node_modules, there is the bootstrap folder where Bootstrap is installed. If I drill into this, Bootstrap comes with a distribution folder, dist, and it's inside of here where I can grab the Bootstrap JavaScript, the font that Bootstrap uses, and the Bootstrap.css file. For this application, we're just going to use the css file. I need to be able to reference that css from my application. How will I do that when this css file lives outside of the web root folder? Currently the only place where we can serve static assets is from that magic wwwroot folder. Let's talk about this next.

Serving File from node_modules

One popular solution to the problem that we face is to use a task runner tool in node.js like Grunt or Gulp. You can use a task runner to create a build system for your JavaScript and CSS and other front end assets, and this build system can copy files from places like the node_modules folder into the web root folder where we serve static files. You can also use these tools to minify files and optimize for a production release. I'm not going to use any of these tools, but there are some courses here on Pluralsight if you want to learn more. I also want to let you know that Visual Studio 2015 includes integration and tooling for tools like Gulp. There's also a brand-new minification and bundling extension that you can install into Visual Studio 2015 to make this process easy. But again, I'm going to take a different approach. All I need to do is serve up a few simple files from the node_modules directory. Later in this module, I'll show you how you can still optimize for production by using a CDN, but you might remember back at the beginnings of this course, we added some middleware during the configuration of our application. So, inside of Startup.cs. This was middleware to create a file server that will serve those files that are inside of the wwwroot folder. This is using the static file's middleware behind the scenes. But what you need to realize is I could install multiple instances of that static file's middleware to serve content from two different directories, not just wwwroot, but also node_modules. To do that, I just need to configure static files. So when I use static files, I have the ability to pass in some options, and these options can specify where to look for these static files. But instead of cluttering up my Startup.cs with all of these options and configurations, I'd like to create my own method that will make it very clear that I'm going to serve files from the node_modules directory. So how can we get that method to work? Well, let's come into the Solution Explorer inside of our project, I'm going to turn off show all files, and I'm going to create a new folder, so Add a New Folder, and call this Middleware. This would be a directory where I can write custom middleware or custom extension methods for IApplicationBuilder, so I can do things very easily, like use node_modules. So inside of this folder, let me add a class, and let's call it ApplicationBuilderExtensions. What I need to do to make this work is make a method an Extension method, UseNodeModules, it has to be an Extension method for IApplicationBuilder. So, Extension methods will go in a static class, and I want a public static method that will return IApplicationBuilder that will make me bring in the namespace Microsoft.AspNetCore.Builder. We will call this UseNodeModules, and it will be an Extension method for IApplicationBuilder, we'll just call that app. Ultimately, we will return that IApplicationBuilder, but before we do, we want to tell this to use static files. Since we're not serving from the default directory, I'll need to create an options object, so new StaticFileOptions, and I'll need to pass these options in, and options has a few interesting properties. One of the interesting properties is the RequestPath. This is where I can tell static files I only want you to try and respond if the RequestPath starts with node_modules. If you see something like /Account/Login, you can ignore that safely. The other thing that I need to do then is to tell the static file middleware where to look for the files, and I do that with a file provider. I'm going to need to create a file provider to assign it here. So the provider is a new instance of there is a class PhysicalFileProvider, which is a class designed to work with the filesystem, I need to bring in the namespace Microsoft.Extensions.FileProviders, and what I need to do here is pass in a path. What is the root for this particular physical file provider? By default, static files would point this to wwwroot. We want to point this node_modules. So let's build that path. Now, I do want to point out PhysicalFileProvider you can see in the documentation that the path I pass in should be an absolute path. That means I need to find out the full path to where this node_modules directory is. One easy way to do that will just be to force the caller of this method to pass in the root of the project. Where does the project.json file live, essentially? And we've done this before very early in the course, you might remember that. So the path that I want to use, I will get by using the Path class in the system.io namespace. This Path class makes it very easy to combine path information into a full legal path, so I want to combine the root path with node_modules, and path will make sure the backslashes appear at the appropriate location. Then I can pass this path in to my FileProvider, and then I can give the provider to the options object. Now one other little change that I'm going to make, is I'm going to put this class into the Microsoft.AspNetCore.Builder namespace. Typically we don't add classes to a namespace that is controlled by some other third party like Microsoft, but it is a common convention that when you are writing an Extension method for IApplicationBuilder that you put that Extension method into the same namespace as IApplicationBuilder. That makes the Extension method easy to find. Let's remove our unnecessary usings. We should be able to close this file. Back in Startup.cs, I now need to pass a parameter in here, the path to the root of my project. We did that before very early in the course in the constructor. We used the IHostingEnvironment and looked at the content root path property. We will do that again. This Configure method already has an IHostingEnvironment object injected, all I need to do is once again look at the ContentRootPath property and pass that along. Now I should be able to serve files directly from that node_modules directory. So let's add the Bootstrap.css file to our layout view, and I'll do that by adding a link here in the head, and the href will look like node_modules, then I know that Bootstrap is installed underneath of there. I know that Bootstrap has a distribution folder, inside of there is a CSS folder, and finally, I will find Bootstrap.css. Let me save all our files, come back, and let's just refresh the edit page that we are on. We should see a change of a typography. And I do notice a change to the fonts that I'm using, so that gives me a pretty good indication that Bootstrap.css was loaded successfully. Let's also go back to the homepage, and let's try to make this look a little bit better using Bootstrap.

Styling with Bootstrap

Let's use some Bootstrap components to improve the look of our homepage. Most web applications using Bootstrap will include a navigation bar at the top of the page. I can do this by using a nav element, and use the Bootstrap classes to say that this should be a navbar, let's make it a default colored navbar. Inside of the navbar, I want a div with a class of container-fluid, these are all Bootstrap classes, container-fluid will allow my navbar to stretch across the screen and fill up the full width of the window. And inside of here I want a div with a class of navbar-header, and let's add an anchor tag with the class of navbar-brand. This will be an anchor tag that stands out a little bit. It will have an href that just points to the root of the website and we will use the text OdeToFood. And let's also take this LoginLogout component and move it into the navbar. So I'll move it inside of the container, but give this div a class of navbar-right to push this to the right side of the screen. Let's see what this looks like real quick. This is my navbar, it's a bit collapsed because I don't have the width here with the browser, but now I have my brand that I can click on to always get to the root of the website. I have my username and Logout button displayed here on the right. Let's improve the looks of the buttons here, that is in the LoginLogout component, let me open up that view. What I want to do is give this input a class of btn, and let's make it a default button. I'm also going to take that class and copy to these anchor tags, so that they appear as buttons instead of links. And now if I save this component view and refresh, I now have a more Bootstrappy looking button. Let's work on the layout of the content now. Inside of a layout view, I might want to render everything inside of a div with a class of container, that will center my content in the page, and I will include the footer with today's message inside of there. Let's see what this looks like. Things should bump to the right a little bit. And now let's make our panels actually look like panels. This is rendered by the summary view that displays a single restaurant. I'll need to open that up from the home folder. Bootstrap includes a component known as a panel. In order to use it, I just need to set this top-level element to be a panel, and let's make it a default-looking panel. My h3 can take a class of panel-heading. All the information about a restaurant will be in a div with a class of panel-body. And I can make the action links down here have a class of panel-footer, and let's also give these action links, make them look like buttons. So I'm going to use Alt and select two rows inside of Visual Studio, so I can just type once and say class, this should be btn, and let's make them primary buttons so they stand out a little bit. Let's see what this looks like over on our page. Now I can have each restaurant with a little bit of a heading, and then there's all the details, and then there's the actions that I can take with that particular restaurant. And for one last change, I might also want to turn this create link into a button. That is on the index view that is rendered from the homepage. This should give it a class of btn btn-primary. This is much easier to do, by the way, with tag helpers compared html.ActionLink, much, much nicer syntax. Now the next thing that I might want to do is come into some of my forms. Bootstrap can make these look much better. But I'm going to address another issue instead. I want client-side validation to work, so that if the user clicks the Save button without filling out a restaurant name, we don't have to have a request go all the way back to the server just to tell us that the model state is invalid. We'll handle that with JavaScript instead.

Enabling Client-side Validation

Inside of the create form, let's inspect this input for the restaurant name. You might remember we built this form using HTML helpers, but the same would be true with tag helpers, and that is that the markup includes these attributes that start with data-, like data-val = true. These are validation attributes that the MVC framework will render by default, and they include all the information to enforce those data annotations that we applied to our model. Like the annotation that said the maximum length of a restaurant name is 80 characters, so you can see the value 80 here, both in a message data-val-maxlength, and also in this attribute data-val-maxlength-max. Now the browser itself doesn't know what to do with these data attributes. The whole idea behind data-attributes is that these are custom attributes for your application, and your application will have to provide some JavaScript to act on those attributes. Microsoft provides a JavaScript library that we can use to consume this validation metadata and enforce validation on the client. The script that Microsoft provides is built on top of a popular jQuery plugin known as jQuery validation. And the validation plugin, of course, depends on jQuery. So what we need to do to get client-side validation to work is to take an explicit dependency on three script files, jQuery, the jQuery validation plugin, and the Microsoft script, which is known as jQuery validation unobtrusive. So let's swing back to our package.json file, and we will add the following new dependencies. First we want jquery. I will take the latest version of jQuery. I also want the plugin, jquery-validation, take the latest version there, and finally, jquery-validation-unobtrusive, that's the Microsoft script. Those are the three dependencies we need. I'm going to save package.json. Visual Studio will restore my dependencies. Now I just need to get these scripts loaded onto a page. If you ever need to look inside one of these dependencies to figure out what exactly is the path to a particular dependency, you can always right-click on a dependency and say open in File Explorer. Here I can see I'm in the jquery folder of node_modules. The way jQuery distributes itself with npm is to create a distribution folder, and inside of there I can load the jQuery script or the minified script right from this folder. Let's do that. I'm going to do that from a layout view. Many people will take the approach of only loading the scripts that they need for a particular page, so only loading the scripts when the user is on the create view or the edit view or the register form, and one way to do that is to render an additional section in your layout view, perhaps at the bottom of the page. You could call it scripts, and that would allow any content view, like the register view, to inject scripts into the layout page at the appropriate location and to provide the functionality that is required for things like client-side validation. I'm just going to take an easier approach and assume that eventually all users will need these scripts. Let's just load them on the layout page right from the start, and then they'll be cached and available for everyone to use. So jQuery comes from the node_modules/jquery folder, the distribution folder that we saw, and then there is a jquery.js file inside of there. I'm going to make a copy of this script tag and paste it here, because jQuery validation follows the same pattern. This is jquery-validation. The filename, which is in the distribution folder, it has dots though, so jquery.validate.js. Copy the script tag once more, because now I need to go to jquery-validation-unobtrusive. There is no distribution folder in the npm installation for this particular library, so I just need to remove dist, but there is .unobtrusive in the filename, and I just have to make sure I spell this correctly, which reminds me of another tip that I need to give you. Let me save the layout view. I think the script tags are correct. But if they're not, I'm going to run into a little bit of a problem debugging things. Over in the startup file, this last piece of middleware in app.run, we've had this around in the application since the beginning, and it proved really useful when we were trying to figure out how routing worked and when we didn't have a controller implemented properly, because the browser would display the text not found. However, this little piece of middleware can also mask errors. If I had a script tag that didn't point to the correct location, I want the browser to respond with a 404 error, so that I know there's a problem. Unfortunately, right now the way the application would behave, if a script file wasn't found, app.run would return this text to the browser with a 200 response, and I wouldn't know that there's a problem. So I'm going to remove that piece of middleware now. Let's save everything and come back out to the browser. I'm going to do a GET request for /Home/Create again. We're going to start off with a fresh form. I'm going to look at the Network tab just to check to see if all of my scripts loaded. It looks like I had a 200 response for each of them, so that looks good. The only error here was that Chrome requested the favorite icon for the site, I didn't provide one, and that's okay, but I should now have client-side validation working. Let me clear the Network tab just to show you that if I try to save now, we did not send a request off to the web server, instead client-side JavaScript jumped in and said, sorry, but the restaurant name field is required. If I come in here and start typing, you'll notice that validation message goes away. If I revert to an invalid state, the validation message reappears. And with a little bit of Bootstrap styling, this form could look and behave in a professional manner, and our users will be happy to see that they have a problem before they try to save everything.

Using CDNs and Fallbacks

For applications that use a large amount of JavaScript, one of the best practices is to have a build process for your JavaScript. This typically uses a task runner like Gulp or Grunt or Webpack, and your build process will concatenate all of your JavaScript files together, minify your JavaScript, and try to minimize the size and number of script downloads that you have on a page. You might also consider putting your custom script into a content delivery network, a CDN. A CDN can typically deliver script files faster than your own local servers, but you always have to do some testing to reveal the true numbers. Now, if you have an application that just relies on a few popular third party scripts like jQuery, you might consider just going the CDN route, and that's the approach I'm going to show you. We're going to use a content delivery network. This is a content delivery network run by Microsoft. You can find out more about it if you go to asp.net/ajax/cdn. On this page you will see a list of all the libraries that are hosted on the Microsoft CDN. This includes jQuery, jQuery UI, jQuery Validation, as well as CSS frameworks, like Bootstrap. If I click on one of these links, this will show me the exact URLs that I need to use to load a specific version of a library. So one way to use a CDN is to simply take these URLs, copy them, and paste them into your own layout view. I could take this URL for jQuery, for example, and come into my layout view and replace my current script tag with that URL. But in many scenarios, it's nice to keep using node_modules for development, and then switch over to use a CDN when you put the application into testing, or staging, or production, and that's the approach that I want to show you. We're going to take advantage of tag helpers again. You might remember earlier in the course I mentioned that there was a tag helper named environment. With environment, I can say render the following markup only when we are in this specified environment or environments. And I can say let's only use this markup when we are in development, and I will surround my script tags that point to node_modules with an environment tag. You might remember earlier we also talked about development versus staging versus production and the environment variable that controls this. Now I can use a different environment for staging and production. And because this is a quite a lot to type, I'm going to grab some code from off the screen, paste it in, and now explain what this is doing. So these are the script tags that we will load into the browser when we are in the staging or production environments. We will load jQuery, jQuery validation, and the unobtrusive plugin all from the ajax.aspnetcdn. And notice these additional attributes here, these are tag helpers, asp-fallback-src and asp-fallback-test, here's how these are useful. Let's imagine that my application is up and running and available to users, but for some reason the CDN is down. That can make my application look weird, it could behave strangely, because my users will still get the content, but the JavaScript and CSS styles will not be applied to my application. What these tag helpers will do is inject some additional JavaScript to run a test to make sure that the source actually loaded, so if jQuery didn't load, there will not be a jQuery object hanging off of the window object, so this test would fail. Then what the code will do is try to load jQuery from this fallback source instead, it'll just go to node_modules, which is local. And so for each of the libraries that I'm loading, there's a fallback source in node_modules and a test to make sure that library was loaded into the browser appropriately. You can also do this for CSS frameworks like Bootstrap. Again, let me just copy in the environment tags that are needed. I'll remove this link tag and paste in two environment tags. For development we will load Bootstrap from node_modules, but on staging and production, we will again load Bootstrap from the CDN. We will have a fallback in place in node_modules, and then a few tests, which will verify that Bootstrap was loaded correctly. And now that we're loading minified scripts and minified CSS from a CDN, the application should be a little bit faster for our end users.

Summary

In this module we learned how to use the Node package manager from Visual Studio to install front end frameworks like Bootstrap and libraries like jQuery. We added these resources to our page and saw how to use some Bootstrap classes, and also enforced client-side validation rules. Finally, we learned about the environment tag helper, and how it will allow us to use local scripts for debugging and content delivery networks for production. And this concludes my course on ASP.NET Core. I hope you enjoyed the course and build many successful applications in the future.

Course author

	
Scott Allen

 Scott has over 15 years of experience in commercial software
 development and is a frequent speaker at national conferences,
 and local user groups. Scott is a Microsoft...
Course info

LevelBeginner
Rating
(121)
My rating
Duration5h 57m
Released1 Oct 2016
Add to playlist
Share course

