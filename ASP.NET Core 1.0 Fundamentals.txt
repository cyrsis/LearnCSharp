ASP.NET Core 1.0 Fundamentals
by Scott Allen

This course gives you everything you need to know to start building your first ASP.NET Core application with the MVC framework.

Resume CourseBookmarkLive mentoring
Table of contents
Description
Transcript
Exercise files
Discussion
Recommended
Course Overview

Course Overview

Hi, this is Scott Allen, and welcome to my course on ASP.NET Core. ASP.NET Core is the new web framework from Microsoft. It has been redesigned from the ground up to be fast, flexible, modern, and work across different platforms. Moving forward, ASP.NET Core is the framework you want to use for web development with .NET. In this course, we will build an application by starting from an empty project, so you can see how all the pieces come together. We'll install middleware to build a processing pipeline and then move on to work with the MVC framework. If you have any experience with MVC or Web API over the last few years, you will notice some familiar features. We still have models used in controllers, but I'll also show you what's new as we look at tag helpers, view components, and how dependency injection is a first-class design pattern. You'll also see how to work with SQL Server using the new Entity Framework, implement forms authentication using the ASP.NET identity framework, and install and use CSS and JavaScript libraries like bootstrap and JQuery. By the end of the course, you will have everything you need to start using ASP.NET core and write an application that can create, edit, and view data from a database. I do expect that you are already familiar with the C# programming language and have some knowledge of HTML and web programming, in general. If not, we have lots of C# and HTML courses to choose from on Pluralsight and after the course, look for new courses covering even more details of programming with ASP.NET Core.

Building Your First ASP.NET Core Application

Introduction

Hi! This is Scott, and this course will help you build your first application with ASP.NET Core. In this course, we'll be using Visual Studio and the new ASP.NET Framework to build a web application that can display and edit restaurant information. I'm assuming you already know how to work with the C# language and can get around in Visual Studio. We'll spend our time together focusing on the new ASP.NET. In this first module, I'll show you the environment that I'm using, and we'll get our first project started.

Setup

For this course, I'm going to be programming with the C# language and Visual Studio 2015. You can see I'm using Visual Studio Community edition 2015. The Community edition is the free version of Visual Studio. You can download this from visualstudio.com. After I install Visual Studio on this particular machine, I also installed the latest release of ASP.NET Core. You can see here in the About window, I'm using a pre-release of the framework, specifically I'm using release candidate 1. You'll probably be using a later version as you watch the course, and that's okay. Let me show you where you can go to get the latest installation instructions and the latest bits. If you point your browser at docs.asp.net, you'll find a website full of information about the latest ASP.NET including some getting started instructions. Since we are using Visual Studio, we'll be working on a Windows machine, although you can also develop and run ASP.NET apps on OS X and Linux. But here on this home page, you can find a link for that getting started information that includes instructions on how to get started with Visual Studio on Windows. The instructions are simple. In the future, Visual Studio might include everything you need already, but you can always check here for updates and currently to work with ASP.NET Core, I need to install some additional bits. So step 1 is to install Visual Studio 2015. Step 2 is to install ASP.NET 5. If I click that link, it will download a setup program that I can then launch. And the current name of this new framework as I'm recording is ASP.NET 5, but that will change by the time you see this recording. So follow the installation instructions listed here, and run any of the installers that you are required to download. And once you're finished, you should be ready to create your first project.

A New Project

Inside of Visual Studio, I want to start the application by going to File, New, Project. And under the Visual C# templates, what I want to build is an ASP.NET web application. Let's call this application OdeToFood. I'm going to put it in a development folder that is in my C: drive. And once I press OK, I'm going to come to a dialog that allows me to select a specific template for this ASP.NET application. Currently in this UI, there are two sets of templates. At the top of this dialog are templates for ASP.NET 4.5.2. This is really the previous version of ASP.NET. What I want to select is one of the ASP.NET Core templates currently listed as ASP.NET 5, and I could select the Web Application template. That will lay out a lot of files on my file system that would allow me to use ASP.NET MVC right away. But I want to start with the empty template so we can build this from scratch and understand all of the pieces involved. Let me turn off Host in the cloud and select OK. Visual Studio will now go out and create that project. And after a little bit of time, I will have the Solution Explorer window populated with all of the files that are in this project. And once the project is ready, let me close some of these files from the editor and run the application. I can do that by pressing Ctrl+F5 or by coming into the Debug menu here and saying Start Without Debugging. Now a brand-new empty ASP.NET 5 application can only do one thing. It can only say Hello World! And we'll dig into that a little bit in this module and the next module and see why that is. But for right now, I want to show you that this is running on localhost:49940. I can see in the window system tray that IIS Express is running. And here is my site, OdeToFood. So if you've been programming with ASP.NET with previous versions of the framework, the way you would interact with Visual Studio and the way Visual Studio uses IIS Express to host your application, all those things will be familiar. But what is going to be different and what I want to take some time to explain in this first module is how this project appears on the file system and how the different files and directories all work together. Let's take a look at that next.

The Project Layout

In the Solution Explorer window, let's right-click the Solution node and select Open Folder in File Explorer. What I want to show you is the default file system layout for ASP.NET Core. I can see in the root directory there are two files. One is the OdeToFood solution file, the file with the .sln extension. Visual Studio has used this extension for years by default, and I can double-click the file if I want to open the app in Studio and work on it. There is also a global.json file. Let me turn on file extensions so we can see that does have a .json extension. And let's look at the file in the IDE. I don't want to go into detail about this configuration file, but I will tell you the project's setting is significant. This project setting tells ASP.NET where to look for my source code and what folders contain my projects. There are two possible folders--src for source and a test folder. Unless my projects and source code are in one of these two folders, the code won't be available to build. I can change these settings if I want, but I'm going to leave the default. Now if I come back to Windows Explorer, I can see there is a source folder on disk. I don't have a test folder, and that's okay. The test folder is where I could place my unit testing projects. But we don't have a unit testing project yet. Inside of the source folder, I can see there is my OdeToFood project, the web application, and it is inside of here, these are the source code files for the application. I can see this folder structure in the files. They are mimicked in the Solution Explorer window. And that's because in this version of ASP.NET, the file system determines what is in my project. If I add a new file to the disk here, the file will be added to the project. If I delete a file, the file is removed from the project. Watch what happens in the Solution Explorer window when I right-click the Readme file and delete that file. Everything stays in sync. And that's a little bit different than previous versions of ASP.NET where a project file, a .cs proj file, that contained a manifest of everything that is in the project. Here, the file system is the project system, and that's important to understand in this version of ASP.NET. It's also good to know that ASP.NET will compile my application when a file changes or a new file appears or I delete a file. As an example, let's open up Startup.cs. I'm going to open this with Notepad so that I don't touch this file inside of Visual Studio. We'll dig into this file in more detail later. But for now, I want to show you this line of code. It is this line of code that is responding to every HTTP request to my application. And it simply responds with Hello World! What I want to do is add a few more exclamation points here just to make the app seem more exciting. I'm going to save this file in Notepad by hitting Ctrl+S. And then I'm going to come back to the web browser and refresh the application. And you can see my changes are reflected in the browser. And, again, that's because ASP.NET will monitor the file system and automatically recompile the application when a file changes. I don't need to explicitly build the application in Visual Studio. In fact, I could use a completely different editor if I wanted to, something like Visual Studio Code. All I need to do with Visual Studio is get the web server started by running without the debugger, Ctrl+F5, and now I can edit files, save files, and just refresh the browser to see the changes. This is a nice new workflow for building web applications with a compiled language like C#. And now that we know a little bit about the directory structure and compilation model, let's take a closer look at these files that are in the project.

The project.json File

Let's take a high-level tour of the files in our web application. First, I want to discuss this project.json file. Again, another file using JavaScript object notation to store configuration information. And it is this file that is really the heart of a .NET application. Without this file, I would not have an ASP.NET Core project here. Once again, I'm going to skip some of the lesser details and talk about some of the most important features of this file. You will see at the top of this file, we have some version information. This is the version number my application will use when I build it. It's version 1. But the most important part of this file really is the dependencies. If my application is going to do any useful work, I'm going to need libraries and frameworks to do that work. Work like talk to a database or render complicated HTML. With this version of ASP.NET, my dependencies are all managed via the NuGet package manager. NuGet has been around the .NET space for a few years, but now the primary way to manage my dependencies, all dependencies, is to use libraries and frameworks that are wrapped as NuGet packages. All of the top-level NuGet packages my application needs will be stored in this project.json file. You can see I have two dependencies in this file. And the exact dependencies will probably change by the final release of ASP.NET. But part of the reason my application can only say Hello World! is because I don't have many features included in the application by way of NuGet packages. When I want to add a new dependence, say like the ASP.NET MVC framework, I can come in and I can type into this project.json file, and you can see that I get some IntelliSense help here, including not just the package name but also version numbers. Or I can use the UI. I can right-click on References, say that I want to manage NuGet packages, and from here I can see that I currently have two packages installed. Those are the same ones that are in my project.json file. And I can also go out and browser other packages, including pre-released packages, which is what I would have to do right now in order to get, let's say, the MVC framework installed into this project. If I install this package right now by using the Install button, the fact that my application is using that package that would be stored in project.json. The other important part of project.json is the frameworks section. This section tells ASP.NET which of the .NET frameworks my application can use. In this case, there are two monikers here--dnx451 and dnxcore50. Dnx451 is the full .NET Framework. This is the .NET Framework that is installed when I install Visual Studio. It's the same .NET Framework that is included with many versions of the Windows operating system. It's the .NET Framework that has been around for 15 years, and it includes frameworks that do everything from web programming to desktop programming. So frameworks like Windows Presentation Foundation and Windows Communication Foundation. It's a huge framework, and it's a framework that only works on Windows. Dnxcore50, this is the .NET Core framework. .NET Core is a cross-platform framework so it can work on various platforms, not just Windows but also OS X and Linux. This framework has far fewer features than the full dnx451 framework. But it does have all the features that we need for ASP.NET web development, so I'm going to leave the framework here. The only reason I would take it away from my work is if I needed features that only the full .NET Framework provides. Moving forward, there should be fewer and fewer features like that, so I would expect most ASP.NET applications will only target .NET Core in a few years. And to tie all this information together, let's look at the References node in Visual Studio. This will look different than it did in the years past. When I expand the References node, the first thing it's going to tell me is that I'm targeting both .NET 4.5.1, the full framework, and also .NET Core. If I further expand one of these nodes, I can now also see the NuGet packages that I'm referencing. For example, the Microsoft.AspNet.IISPlatformHandler. This is a package that lets me take advantage of some specific IIS features in my ASP.NET application, although IIS is not required for me to host and run ASP.NET applications. I can opt in to using IIS, but IIS is the default host when I create a project with the templates in Visual Studio like we have done. I can further expand an individual NuGet package to see that my NuGet packages have dependencies that are also NuGet packages. For example, this IISPlatformHandler takes a dependency on Microsoft.AspNet.Http, as well as some specific framework assemblies that are installed by the full .NET Framework. So in this course, we're going to build an application that can run on Windows on the full .NET Framework or on OS X using .NET Core. We're going to be adding libraries, frameworks, and the infrastructure that we need by adding references to NuGet packages. And that information will be present here in project.json so that anyone else who opens the project will have an environment where these packages are installed and present for them to work on the code too. Let's talk about some of the other files and folders that are in this project, as well as some of the files that are not in this project. One of the folders you'll see in a new ASP.NET project by default is a folder with a name wwwroot. This is folder that I will call the web root because from a hosting perspective, this is the root of the website. In other words, if I have files that I want to server over HTTP, static files that are on the file system, like image files, style sheets, and JavaScript files, I need to place those files into this web root folder to make them available. We'll come back to the web root folder in the next module and see how to serve up a simple HTML file. Another file in this project is the Startup.cs file. Now if you've worked with previous versions of ASP.NET, you probably expect to see a global.asax file, which was one place where I could write code to execute during startup of a web application. And you'd also probably expect to see a web.config file containing all the configuration parameters my application needed to execute. Those files are all gone. Instead, configuration and startup code are loaded from this file, Startup.cs. Inside of this file, there is a Startup class. This is a class that ASP.NET will look for by convention, and it is inside of here where I configure my application and even configure my configuration sources. We will be talking about Startup.cs in more detail in the next module because we'll need to make some changes to build the application that we want. But I do want to show you how to get started in this file as part of this introduction. So, first, there are two methods in here where most of our work will take place. And we'll even add a third one later. The Configure method at the bottom of the class, this is where I build my HTTP processing pipeline. This defines how my application responds to requests. Right now my application can only say Hello World!, and if I want the application to behave differently, I'm going to need to change the pipeline around by adding additional code in this Configure method. For example, if I want to serve up static files like an index.html file, I will need to add some code to this Configure method. If I want to have a pretty error page or route requests to an ASP.NET MVC controller, both of those scenarios will also require me to do some work in this Configure method. And we will take a look at those steps in the next module, I promise. I also have this ConfigureServices method. This is a place to configure components for my application. To be more specific, Configure is a place to set up the inversion of control container for my application. If you aren't familiar with inversion of control and dependency injection, we will cover them very briefly in this course. There are other Pluralsight courses that you can go and view to see much more detail on the topic. For now, I'll just tell you that dependency injection is a technique I can use to get a lot of flexibility and extensibility out of my software. ASP.NET uses dependency injection everywhere to give us a lot of flexibility on how an application behaves. Essentially with dependency injection, I can have my code ask for dependencies instead of instantiating dependencies directly and being tied to some specific component. That sounds very abstract, so let's get an understanding of this by making some changes to how this application behaves. Right now we have a hard-coded string for every response, the Hello World!!!!! string. Instead of hard-coding the string, I want to load this string from some component that knows the text of the greeting that I want to display. This other component might load that greeting text from a database or a web service or a JSON file. It doesn't matter where exactly. I just want to set up a scenario so that I do not have this hard-coded string. And what I'm about to do will be overkill for this simple example, but it will help us understand how to configure any ASP.NET application for real work and give us something to build on moving forward.

Adding a Configuration Source

Inside of my project, I'm going to right-click and add a new item. What I want to add to this project is a JSON configuration file. And I should be able to search the installed templates for a JSON file. And I will call this file appsettings, although the name isn't really important. I could call this webconfig.json if I wanted to, and ultimately what I want to do is instead of having the Hello World!!!!! string and Startup.cs, I want something to be able to read my greeting message from this file, and my message will be A configurable hello, to you! So if I can get that text into the browser, I know I've been successful. Here's how I would set this up. Inside of Startup.cs, I'm going to use a code snippet, ctor, to add a constructor for this class. And I'm going to create an instance of a ConfigurationBuilder. Now the ConfigurationBuilder that I want is in the namespace Microsoft.Extensions.Configuration. I just pressed Ctrl+period(.) to open up this lightbulb on the left-hand side of the screen, and Visual Studio will add a using statement for me if I just select this top line here. And essentially inside of Visual Studio 2015 just like previous versions, if you have a red squiggly on the screen, you can press Ctrl+period(.), and Visual Studio will prompt you on what action you want to take. And many times it can just do things for you like automatically add a namespace that you need. Currently up here, I have a bunch of namespaces that I'm not even using. I could hit Ctrl+period(.) again because I see the lightbulb on the left-hand side in this case and select Remove Unnecessary Usings. And now back here inside of the constructor, the purpose of the Configuration/Builder is that I can use it to define the configuration sources for my application. There are several different sources to choose from, and there's a somewhat fluent or chaining API on this ConfigurationBuilder that I can use to add different sources. So, for example, just looking at the IntelliSense, I can see that I can AddEnvironmentVariables as a configuration source or AddJsonFile as a configuration source. It's the JSON file that I want, specifically I want the JSON file called appsettings.json. And I could continue adding configuration sources with this ConfigurationBuilder, so I could .AddJsonFile file #1 and then .AddJsonFile file #2, and then when I go to access the configuration for this application, the configuration can look through the different JSON files for the setting that I need. One easy way to access that configuration is to store a final configuration inside of a property. So let me define a property of type IConfiguration. I will call it Configuration. And what I can do is I can say Configuration = builder.Build. So essentially build up the data structure that will represent the configuration that I need. And now down here inside of the Configure method, let's create a variable called greeting, and let's set it equal to Configuration. And I'm going to index into my appsettings or into the configuration information. I want to index into this Configuration object with a key of greeting, and that should give me the string value back from that file. So instead of writing async a hard-coded string, I'm going to write out the greeting that I just fetched. Let's save Startup.cs, come back to the browser, refresh, and I can see that, yes, I'm getting a configuration setting out of my JSON file. And that configuration setting could be a setting like a database password or the root URL for a web API that I need to invoke. In this case, we're just pulling out some simple text. But I want to take this example one step further. Instead of having the Configure method access this Configuration object directly, I want this piece of code to go through some service that's available from my container, and that service will be responsible for getting the greeting. The greeting might be in a JSON file, but it also might be in a database. But now we have in place a configuration file where we can store any parameters that my application might need configured at runtime. And for those of you that used previous versions of ASP.NET, yes, the webconfig.xml files, those are all gone from this version of ASP.NET, but we can build our own configuration sources now. We use this ConfigurationBuilder class to help do that.

Creating a Greeting Service

Ultimately in this application, I do not want the code inside of the Configure method to access the configuration source directly. I want this method to go through some application service or application component, some object, to get this greeting information. And that other service might go to a database or to a JSON file. This method isn't going to care. In order to get this to happen, let's go ahead and create a service that I'm envisioning. I'm going to add a new folder to this project. I will call it Services. And inside of that folder, I am going to add a class. Let's call this class Greeter, so a Greeter.cs file. And before I even write the class, I want to write an interface that describes the capabilities of a greeter. I'll call this interface IGreeter, and just to keep things simple, I will keep the interface and the service in the same file. Typically I would break them out. I would expect every greeter to have a public method available that returns a string. Let's call it GetGreeting. And so my Greeter class I want it to implement this interface. And the reason I'm using an interface is because I want all of my application components to program to that interface. They should know if they're using a greeter that talks to a configuration file or a database. There might be multiple implementations of this interface that are available to the application. And that interface provides a nice level of abstraction. A little bit of indirection between what the application needs and the actual component that provides those features. I'm going to use Ctrl+period(.) here inside of Visual Studio to generate the method that that interface requires. And it is inside of this method where I need to access that configuration file. But before I do that, let me just return a string Hello from the greeter!, and we will come back in just a bit and start using the configuration file. Before we do that, I want to focus on what is the really important part here, which is that I should be able in my Configure method to get an instance of an object that implements IGreeter. So I do need to bring in a namespace here, the OdeToFood.Services namespace. I'll do that with Ctrl+period(.). And down here inside of app.Run, I want to say greeter.GetGreeting. So instead of this method directly instantiating some specific class that implements that interface, instead this method is going to ask for a parameter, some object that implements that interface so it doesn't have to know the ultimate type of greeter. Instead, that's going to be configured into the application. Currently, there is no greeter configured. Let me save this file real quickly and show you the error message that I get from ASP.NET. I will get an error message that says, Sorry, but I could not resolve a type of IGreeter for this parameter on the Configure method. That is the framework's way of saying, You needed an IGreeter; I don't know where to find one. And you might say, But what about this other parameter, IApplicationBuilder? Well, it turns out when ASP.NET starts up my web application, it does load some prepackaged services into the container and makes them available to the application. In fact, let's put a breakpoint here on ConfigureServices because ultimately if I'm defining my own services, I need to register them into this ServiceCollection. And I'm going to run this application with the debugger, and what we're going to see is that there are already some services in that ServiceCollection. Where did they come from? Well the framework puts them in there by default. They're available throughout my application without me doing anything. So we just hit that breakpoint, and let's come down and look at that services parameter. I can see there're 17 services that are in there. I can look at the results and actually see some of the details. I can see there is some service that implements the IHostingEnvironment interface. There's an ILoggerFactory and IStartupLoader. And all of these services are available to me anywhere where the container is active and it's invoking a method or constructing a class. This Configure method is one such method. And so if I want to get something that implements IGreeter into the container and make it available to methods like Configure, as well as my MVC controllers and some of the components we'll be building later, I need to use an API on the services parameter to add that particular service, to add my service into the container. Now services can have different lifetimes. I could add a transient service. That means anytime you see something that needs an IGreeter, create a new one and pass it in. Or I could add a singleton, which means create a single instance of the object that implements that interface and reuse it throughout the application for the life of the application. For the greeting service, I'm going to add it as a singleton. And there is a version of this method that is available where you use only generic types to describe and register your service. Essentially I can say whenever something needs an implementation of IGreeter, please give it an instance of the Greeter class. And this is all I need to do. I should be able to save this, restart the web server with Ctrl+F5, and look at the output in the browser. Hopefully we will see Hello from the greeter! So I know that worked. And just to review what we've done, again, it's a little bit of overkill for this simple example, but I've created a custom service that implements an interface. I want other pieces of the application to use this service without necessarily knowing this concrete type, just by asking for something that implements this interface. And in order to do that, all I need to do is register that service inside of ConfigureServices. Now the ASP.NET container will know about that service, and it can inject an instance of that service into methods like Configure, but also into views and models and controllers. We'll see some of that later in the course. But before we leave, there was one bit of unfinished business, and that is that I would like the greeter to not use a hard-coded string. I would like it to pull this from a configuration source. So let's add a constructor to this class. A constructor that demands an IConfiguration source. So IConfiguration, we will call it configuration, and in order to use that interface, I do need to bring in the namespace, Microsoft.Extensions.Configuration. And I want to save off any private variable the result of looking inside of configuration for that greeting setting. I need to create this private variable. That's something I can do just by pressing Ctrl+period(.). Visual Studio will generate a private field for me, and now instead of returning a hard-coded string, I can return _greeting. Now if I were to save this file and refresh the browser, I would have another error very similar to the one we saw before because ASP.NET, the container that is inside of ASP.NET, it doesn't know of any service that implements IConfiguration. This is just something that I built in my Startup class. If I want to make this available to the container, I will also need to make that IConfiguration source that I built available. So let's add another singleton. This time I already have the instance of the service. It's stored in this Configuration property. So I'm going to use a different overload and add singleton, one that takes a lambda expression. You give me a service provider, and I will return the service that I want you to store away. So the code is a little bit weird because I'm not even going to use the service provider. That would be useful if I needed to pull out additional services to create my service. But here I'm saying I want to add a singleton and give it a provider. Well, here's the object that I want you to have. It implements IConfiguration. What the container is smart enough to do, it's smart enough to look at this Configure method, see that it needs something that implements IGreeter. It knows because of my registration code that it should use this Greeter class, and when it looks at this Greeter class, it sees that this class needs yet another dependency, something that implements IConfiguration. Fortunately, we have provided a service that implements IConfiguration here so the ASP.NET container does what all inversion of control containers can do, which is build up an object graph by properly calling the correct constructors. So let's save this file, come back and refresh. And hopefully now we'll be getting information from the configuration file again, which we are. And so we can start to bring this module to a close. But just to review what we've done, I have shown you now how to build a simple configuration source. And also I've introduced some of these concepts around inversion of control containers and dependency injection, and the ability to use some component but not necessarily know where that component comes from. That's the job of the container inside of ASP.NET. Throughout this course, we're going to be adding additional services, additional configuration information, and hopefully you'll remember this quick introduction and remember how all these little pieces can work together.

Summary

In this first module on the new ASP.NET, we have created a new ASP.NET application. We started with the empty template and will be adding just the pieces that we need. And one of those pieces that we'll need is a configuration file. We used the ConfigurationBuilder class to add an appsettings.json file and consume the settings that are inside of that file. And I also showed you how to work with the container in ASP.NET, essentially how to register services so that those services are available to inject into other methods and other components that are inside of the application. That knowledge will be useful as we progress throughout this course.

Startup and Middleware

Introduction

Hi! This is Scott, and in this module, we're going to move forward with our application and set up our middleware. Middleware in ASP.NET controls how our application responds to HTTP requests. It can also control how our application looks when there is an error, and it's a key piece in how we authenticate and authorize a user to perform specific actions. We will learn a little bit about middleware in this module and how to set up the middleware during application startup. And by the end of this module, we will have a processing pipeline that allows us to use ASP.NET MVC.

How Middleware Works

Let's get an understanding of what middleware is briefly so that we can understand why we need to set up middleware for our application. When an HTTP request arrives at our serve, and let's pretend we have an HttpPost request to the URL/reviews, in this example, we need software that will respond to this request. In ASP.NET, it is ultimately middleware components that will determine how to process this request. Each piece of middleware in ASP.NET is an object, and each piece has a very specific, very focused, and very limited role. So ultimately we need many pieces of middleware for an application to behave appropriately. So let's imagine that we want to log information about every request to our application. In that case, the first piece of middleware that we might install into the application is a logging component. This logger can see everything about the incoming request--the path, the query string, the headers, any cookies and access tokens--and the logger can record information about the request. It can even change information about the request if it wanted to or reject the request and just stop processing right away. But chances are a logger is simply going to record some information and then pass along this request to the next piece of middleware. So middleware is a series of components that are all in this processing pipeline. And let's say that the next piece of middleware that we've installed into the application is an authorizer. An authorizer might be looking for specific cookie or access tokens in the HTTP headers. If the authorizer finds a token, it allows the request or proceed. If not, perhaps the authorizer itself will respond to the request with an HTTP error code or redirect code to send the user to a login page. But, otherwise, the authorizer will pass the request to the next piece of middleware. Perhaps this piece of middleware is a router. A router looks at the URL and determines where you want to go next. Do you want to call some method on a class? And that method, it might return JSON data or XML data or an HTML page. The router could look all over the application for something to respond. And if the router doesn't find anything to respond, the router itself might return a 404 Not Found error. Or if it found the right component and that component produces HTML, well now the pipeline starts to reverse itself because the router can return control to the authorizer, and the authorizer can return control to the logger, and when the logger at this point sees that the rest of the pipeline has finished, it might record that fact and log the total amount of time taken to process this particular request. And then it will allow the request to flow out over the server and over the network to the client who is waiting for some result. This is in essence what middleware is all about in ASP.NET. We need to set up a series of components to make our application behave properly and respond to requests. We will need middleware to handle errors. We will need middleware to serve static files from the file system. And we will need middleware to send HTTP requests to the MVC framework, which will ultimately allow us to build this application later that will show restaurant information to the users. I'm not going to go into excruciating details on middleware in this course. I just want to show you enough of the basics to move forward with an ASP.NET MVC application.

Using IApplicationBuilder

We set up the middleware in ASP.NET using the Configure method of our Startup class. We were working inside this method in the last module when we changed the greeting from Hello World! to a greeting that we read from a configuration file via a service. It is inside of Configure where we will invoke extension methods on the IApplicationBuilder interface to add middleware, like this one piece of middleware that is in our project by default, the IISPlatformHandler middleware. This middleware allows us to use Windows authentication tokens that IIS sends along, and we will leave this middleware here even though we don't plan on using Windows authentication for this application. We are going to need to add all middleware, and most middleware components are stored in separate NuGet packages. So let's take a look at the basic workflow. When we last left our application, the only response the application could give was this hello greeting. Let's go into the Startup file and change around some middleware to do some different things. That means I need to go to the Configure method. And as you can see in this comment (once I fit it onto the screen) this is the method that is used to configure the HTTP request pipeline. We configure the pipeline by programming against this object that implements IApplicationBuilder, and there will be methods available to us to add additional pieces of middleware to the request pipeline. There are two pieces of middleware in a new empty project by default. One is the IISPlatformHandler. That allows us to work with Windows authentication. What IISPlatformHandler will do is look at every incoming request and see if there is any Windows identity information associated with that request. And then it calls the next piece of middleware. The next piece of middleware in this case is a piece of middleware registered with app.Run. The Run method allows us to pass in another method, which we can use to process every single response. Run is not something that you'll see very often. It's something that we call a terminal piece of middleware. Middleware that you register with Run will never have the opportunity to call another piece of middleware. All it does is receive a request, and then it has to produce some sort of response. When you write a method, you get a parameter that is of type HTTP context. Every piece of middleware receives this HTTP context. This is how you can look at things like the Request object and look at headers that are available inside of the request. You can find out anything about the request that you want. You also get access to a Response object. And one of the things I can do with a Response object is write out a string. That's how we're producing the Hello World! But if I were to register another piece of middleware after app.Run, that piece of middleware would never be called because, again, Run is a terminal piece of middleware. It will never call into the next piece of middleware. Most middleware that you're going to use in real applications will be middleware that you register with a Use method, like UseIISPlatformHandler. If I look at the methods that are currently available on IApplicationBuilder, the only one of any significance right now is UseIISPlatformHandler. And that's because we started with an empty ASP.NET project, and we're not referencing any other libraries or packages that give us access to additional middleware. Let's change that. I'm going to right-click on my project. I want to manage NuGet packages because I want to install a new NuGet package. I'm going to search for Microsoft.aspnet.diagnostics. And although I say search, that's actually the full name of the package. And I can see this is ASP.NET middleware for exception handling, exception display pages, and diagnostics information. So this one package contains many different pieces of middleware that I can use. And I'm going to go ahead and install that package, click through all the dialogs that appear. And once that is finished, I'll just show you that, once again, I could have done that same installation just by typing into the project.json file. So the NuGet dialog added this line of code to my project.json file. That tells ASP.NET I'm using this diagnostics package. And now if I come back into Startup, I can type app.Use, and here're some additional methods that are available--extension methods for IApplicationBuilder that are registered by that NuGet package. And we'll take a look at some of these pieces of middleware. But right now, I'm just going to invoke UseWelcomePage. If I save Startup.cs and come back to the browser, what I'll see is that I've registered a new piece of terminal middleware, that is, a piece of middleware that won't call into the next thing, and it's going to respond to every request with this Welcome screen. Not entirely useful for a real application, but it can be useful if you're just trying to Bootstrap a project and make sure all of your runtime configuration settings are correct. Let's try something else that might be a little more useful. Instead of using the Welcome page, I'm going to use the RuntimeInfoPage. Now let me save Startup.cs. Open up the browser. I'm going to push it over here to the side, and let's refresh the application. So this RuntimeInfoPage, it is a piece of middleware that will only respond to requests that come in for a certain specific URL. If the incoming request does not match that URL, this piece of middleware just lets the request pass through to the next piece. So what we're seeing here when we go to the root of the website is that that request will pass through the platform handler middleware, then go to the runtime info page middleware. It's not going to create a response. So ultimately, we end up back inside of our app.Run that says, A configurable hello, to you! But if I go to the URL, runtimeinfo, this is a page that is produced by that runtime info page middleware. It's not going to let that request go through to the next piece of middleware, which is the middleware inside of app.Run that says Hello. It's going to produce a response that gives me some information about my runtime environment. I'm operating on Windows, this is the runtime version, the runtime architecture, all the packages that I'm using, etc. And one of the key things to realize here is that the order of the middleware is important. If I were to place UseRuntimeInfoPage as the last piece of middleware in the pipeline after app.Run, I would never be able to get to this page because that piece of middleware would never get invoked. App.Run never calls into the next piece of middleware. So I want to use this before app.Run. And then something else to know about middleware in general is that most pieces of middleware will allow you to pass in some options to configure that middleware. In fact if I look at the IntelliSense window here, I can see there's an overload of this method that allows me to pass in a path, that is, if I want to change the path that this middleware is responding to, I could tell it, Let's respond to /info instead of /runtimeinfo, and now the runtimeinfo URL will pass through and be processed by app.Run. But if I go to /info, I'll get that runtime information. And then so you see one more overload here, many pieces of middleware will also include a full options object that you can instantiate and pass in and that will give you the ability to configure all of the possible options for that particular piece of middleware. And here's what you can take away from this discussion. One is every ASP.NET application will need some middleware registered if it's going to perform any useful work. A typical workflow for registering middleware is, first, you generally need some sort of package that will give you access to the middleware. And once you have that package installed, there will be additional methods on IApplicationBuilder that you can invoke to put that middleware into the pipeline and optionally configure it. And now that we've seen that, let's start adding some other additional middleware pieces into our application.

Showing Exception Details

Let's take a look at an additional piece of middleware that is available through the diagnostics package, and that is a piece of middleware that will help us process errors. And in order to simulate an error, let's go into app.Run and see how the application behaves if I just throw an exception every time we hit this piece of middleware. So we'll just throw an exception with the very generic message of Error! I'll save Startup.cs, come back to the browser, and let's go to the root. That should generate an error. And what I see is a blank page. If I open up the developer tools in my browser with F12, what I'll see is that we failed to load this resource. There was a HTTP 500 error, an internal server error, and this actually happens twice, once on the request to the root of the website and once because the Chrome browser always requests the favorite icon for a site. Both of those generated a 500 response. And that's not particularly helpful. It might be nice to get some exception information without going into the debugger official studio. So I'm going to add another piece of middleware, which is the DeveloperExceptionPage. So this piece of middleware is a little bit different than the other pieces of middleware. The other pieces of middleware are typically looking at the incoming request and making some decision about that request. If the RuntimeInfoPage sees that the request is /info, it generates a response. The DeveloperExceptionPage doesn't care so much about the incoming requests as it does what happens later in the pipeline. It's going to just call into the next piece of middleware, but then it's going to wait to see if anything later in the pipeline generates an exception. And if there is an exception, this piece of middleware will give me an error page with some additional information about that exception. So let's refresh the browser with that piece of middleware in place. And now I get some information that I would expect if there was an error in development. I get a stack trace. I can see there was an unhandled exception thrown on line 43 of Startup.cs. I can also inspect the query string, any cookies, any additional headers that were here. I can see raw exception details. And all of this information can be very useful for a developer. In fact, we probably only want to show this information when a developer is running the application. Later in the course, we will provide a nice error page for users. But in the next clip, we can see how to configure the pipeline so that only developers see this type of exception page.

Middleware to Match the Environment

As we saw in the previous module, this Configure method is injectable. In other words, ASP.NET is looking at the parameters that we require for the Configure method. It's analyzing those and going through the service container to figure out what objects to pass that can implement these interfaces. The IGreeter parameter that we're asking for, that was a custom service that we built, we had to explicitly register that service during ConfigureServices, but IApplicationBuilder, that is a service that we get for free. It's just always going to be in ASP.NET. Another service type that we may be interested in is IHostingEnvironment. An object that implements this interface can give us some information about the environment that we're running inside of. For example, I can look at environment, and I can see it has flags for, Is this development? Is this production? Is this a staging server? There's also a property here that I can use to determine the absolute path to the www.rootdirectory. So if I want to interact with the file system directly, I can always inject IHostingEnvironment and use this WebRootPath to determine where I am on a physical file system. But what I want to do is use this IsDevelopment flag so that we're only using the DeveloperExceptionPage when we are in development. So this is one way to customize the middleware that you're using depending on the specific environment that you're in. But I will wrap the call to app.UseDeveloperExceptionPage inside of an "if" statement so that we only add that piece of middleware when we are in development. Now that raises an obvious question, which is, How does ASP.NET know when we're in development? And by default, what ASP.NET will do is look at some environment variables to figure out the environment. If I right-click on the project and come into the Properties window, there are several tabs here--Application, Build, and Debug. What I want to do is look at the Debug tab. Ironically, these settings also apply when you run from Visual Studio without the debugger, which is what I'm doing. But the important part here is the environment variables. By default when you create a new ASP.NET project, it will be configured to set an environment variable named Hosting:Environment to the value Development. And this is the environment variable that that environment host looks at to figure out if we're in development or production or staging. So it's only when this flag is set that the IHostingEnvironment will say, Yes, you are in a development environment. So it's only when this environment variable is present that I will get a DeveloperExceptionPage. Otherwise, my middleware will be customized for production, and I might need a different sort of error page. That's something that we'll add later in this course, a pretty error page that we might present to an end user. For right now, though, we need to get just a few more additional pieces of middleware in place so that we can build the application that we want to build.

Serving Files

One feature nearly every web application needs is the ability to serve up files from the file system. Files like JavaScript files, images, CSS files that we have on the file system. Currently, our application cannot do that. And to demonstrate the fact and then to show you how we can serve those files up, I want to add a simple HTML file to the application. So this HTML file has to go in the web root folder, wwwroot. By default, that's the only place where we can serve up files directly from the file system. So on that folder, I'm going to right-click, and I want to add a new item. And I'm going to search for the HTML template. This will give me a simple HTML page. Let's call it index.html, that's the default page for many sites. And once I click Add, I will get a simple index.html file here. And let's just write out some simple text, Hello, from the index.html file. And we can give this a title of Welcome. So I'm going to save that file, come back to the browser, and let's try to go to index.html. And what I will find is that I instead hit my app.Run middleware that throws an exception because there's nothing currently in my application. There's no piece of middleware that will go looking for any files on the file system to serve up. Let's fix that. I'm going to come to the Solution. Let's add another NuGet package. So right-click and Manage NuGet Packages. This time I want to search for Microsoft.AspNet.StaticFiles. And I will find the static files middleware. I'm going to install that after accepting all of the terms. And now what I should be able to do just like with the diagnostics package, I should have additional methods that I can use to register middleware here inside of the Configure method. So in addition to UseDeveloperExceptionPage and UseRuntimeInfoPage, I should also now find UseStaticFiles. By default, unless I override the options and pass in some different configuration parameters, what static files will do is for a given request, it will look at the request path, compare that to the file system and what's on the file system, and if it sees a file that it can use, it will serve up that file and not call the next piece of middleware. If it doesn't find a matching file, we'll simply continue to the next piece of middleware. And now if I come out and refresh the browser, I can see that index.html file. So now anything that I put anywhere inside of wwwroot, any JavaScript files or CSS files or HTML files, I'll be able to serve them up. Now what if I wanted index.html to be my default file? This is a feature that IIS has always had. You were always able to give IIS a list of default files to look for so that if someone came to the root of a directory or, in this case, the root of the website, if IIS found something named index.html, it would just automatically serve that file. I don't have that piece of middleware here. That's a different piece of middleware that has that capability. Let's make a few changes in here. First, let's get rid of the forced error. If we fall through to this app.Run, we will simply say whatever the current greeting is. But I'm going to use another piece of middleware, which is UseDefaultFiles. What this piece of middleware will do is look at an incoming request and see if it's for the root of a directory and if it is look inside of that directory to see if there's any matching default files. And you can override the options for this piece of middleware to tell it what are the default files to look for. Index.html is by default one of the fault files. So it should just be able to save Startup.cs, come to the root of the web application, and now I'm serving up index.html as my default file. Again, the order in which you install middleware is important because if I had UseDefaultFiles after UseStaticFiles, I would not get the same result. StaticFiles would say, There's nothing here. It would let things go. DefaultFiles would see there's an index.html file, but this doesn't actually serve up the file. It only modifies that request that's coming through the pipeline to point to the default files. So if this piece of middleware comes after StaticFile, we'll have some rewriting in the request. But things essentially still fall through to app.Run, which would just display a greeting. And now if you're going to use UseDefaultFiles and UseStaticFiles, you might also want another piece of middleware that is inside of Microsoft.aspnet.staticfiles, that NuGet package, and that is the FileServer middleware. This essentially includes DefaultFiles and StaticFiles in the correct order. I can also enable directory browsing. So if I wanted someone to be able to come to my website and see all of the files that are in a directory, I could configure it to do that. That's not on by default, but with app.UseFileServer, I should still be able to get to my index.html file, which I do. I should still be able to get to /info through that piece of middleware. And any other requests, let's say, for /foo, that's going to fall through all the other middleware and eventually reach app.Run, which just displays the greeting. So now we have some ability to see what happened when there's an exception. We have the ability to see our runtime information. We have the ability to serve static files. And then there's one more piece of middleware that we need to install before we can start using ASP.NET MVC. We're going to do that in this module and explain some of the magic behind MVC in the next module.

Setting up ASP.NET MVC Middleware

Ultimately what we want to do is build a web application on top of the ASP.NET, and more specifically, the ASP.NET MVC framework. Although we could technically build an entire application using only middleware, ASP.NET MVC gives us the features that we can use to easily create HTML pages and HTTP-based APIs. We'll see how all that works in the rest of the course. For now, we just want to get set up use the MVC framework. And set up from our nearly empty project requires three steps. Step 1 is installing the Microsoft.AspNet.Mvc package, which gives us access to the assemblies and classes provided by the framework. Once the package is installed, we need to register all of the services that ASP.NET MVC requires at runtime. We'll do this inside of the ConfigureServices method where we also configured our IGreeter service into the application. And, finally, we need to add middleware for ASP.NET MVC to receive requests. Essentially this piece of middleware takes an HTTP request and tries to direct that request to a C# class that we will write. I'll show you a little bit about what the class looks like in this module. But we'll go into much more detail in the next module. So try to remain patient. For right now, we just want to have all the setup in place so that we can move forward. The first step in using ASP.NET MVC is to get the ASP.NET MVC package installed. And instead of using the NuGet user interface, I'm going to go directly into the project.json file this time. And I want to add a dependency on Microsoft.AspNet.Mvc. You can see I get a little bit of IntelliSense help there. And I want to add the version that is the most recent version. And currently that is 6.0 release candidate 1. Once I save this project.json file, Visual Studio should go out and fetch that package. And I will be able to program against the types inside. Let me pin the Solution Explorer window so it is open constantly. And here's the ultimate goal--when you're using the MVC framework, you want to be able to route requests to a class that is a controller. That's what the C in MVC stands for. I promise we'll be talking more about controllers in the next module. But for right now, I want to write a very simple controller just to provide that we have the MVC framework installed correctly. And we can see some output from that controller. So let me add a new folder to this project. I want to call this folder Controllers, and it is inside of here where we can place multiple controllers. So you can have multiple controllers in a project. And later we will be looking at more sophisticated controllers. But for right now, I want to add a simple C# class, and I will call this class (once the user interface catches up), I'll call this class the HomeController. So the idea is that this is a controller that I want to respond to a request when it's for the root of the website. It represents sort of my default page. And for right now, this is going to be a simple C# class. It doesn't need to inherit from any specific base class. And I'm going to give it a single public method that returns a string. I will call that method Index for reasons that we will discuss later, and I'll just return Hello, from a controller! I'm going to save this file and close it out. And the idea is now when I come to the root of the website, I want to be able to see that controller respond with Hello, from a controller. Right now we will be serving up our index.html file. But since I know that static files work now, I'm actually going to go into the root of the website and delete index.html for now. I want the controller to respond instead. And there're actually several ways that I could control that depending on how I add the middleware here. If I were to add the middleware for ASP.NET MVC before this UseFileServer for static files, that would give controllers a chance to respond before the web server started looking for files on the file system. But typically what we do is we add app.UseMvc after any static files. Now there're two methods I can choose from here--UseMvc or UseMvcWithDefaultRoute. I'm going to choose the WithDefaultRoute version of that method for right now. Again, we'll come back and explain this in more detail in the next module. But you also might remember that this was step 3 of the three things that we needed to do to get ASP.NET MVC up and running. I just want to show you what happens now that I have both the NuGet package installed and the middleware installed and a controller in my project. I'm going to refresh the application at the root of the website. And what I'll see is that there is a 500 error. The error says that the framework was unable to find the required services. And the services specifically it's talking about are the services that ASP.NET MVC requires to do its work. So the ASP.NET Framework itself is made up of many different small components, components that have very focused responsibilities. For example, there's a component out there that has to go out and locate and instantiate my controller. That component needs to be in my service collection for ASP.NET MVC to function correctly. So in addition to adding the NuGet package and in addition to adding the middleware, I also inside of ConfigureServices need to say AddMvc. So when I add that NuGet package, there's an additional extension method that is registered against ISErviceCollection. It's called AddMvc, and that will give me all of the default ASP.NET MVC services, everything that ASP.NET needs to do its work. And now if I save the Startup file and come back to the browser, we should be able to get a response from our home controller, which is not HTML yet. We'll build something more sophisticated in the next module. It simply says Hello, from a controller! And that lets me know that ASP.NET MVC, the framework is installed. It's configured correctly. Everything is up and running. And now we can start to learn about that framework and how to build HTML applications on top of that.

Summary

In this module, we learned more about middleware and how to configure middleware in the Configure method of the Startup class. We now have a processing pipeline where a request to the root of the website will travel through several pieces of middleware including the DeveloperExceptionPage middleware to show detailed error information, the RuntimeInfo middleware, and finally reach the MVC middleware, which can then forward the request to a controller class. Right now we have a simple controller that displays a hello message. But in the next module, we will learn more about controllers and how requests can reach different controllers and how we can produce HTML.

Controllers in the MVC Framework

Introduction

Hi! This is Scott, and in this module, we will start learning the ASP.NET MVC framework. The MVC framework gets its name from a popular design pattern which we will also learn about, and then we'll go into the mechanics of how to use controllers to process HTTP requests. We'll see that controllers can produce text, serialize objects into JavaScript, and render HTML to the client.

The Model View Controller Design Pattern

The MVC framework is named for the MVC design pattern where M stands for model, the V stands for view, and the C is for controller. The MVC design pattern is a popular design pattern for the user interface layer of a software application. And in larger applications, you typically combine a model-view-controller UI layer with other design patterns in the application, like data access patterns and messaging patterns. These will all go together to build the full application stack. In this course, we'll just focus on the MVC fundamentals. In MVC, the controller receives an HTTP request. We'll see how to map an HTTP request to a method on a controller class. And once inside of a controller method, the controller has to figure out how to put together the information to respond to this request. Perhaps the user is pointing their browser to the /movies URL of the application. So the controller needs to put together the information to display a list of movies. In this scenario, the controller will build a model. The model doesn't know anything about the HTTP request or the controller. The model is only responsible for holding the movie information that the user wants to see, as well as any logic associated with that list of movies. The model is just another C# class we can use. Perhaps there's more than one class if you have a complex model. But once the model is put together, the controller can then select a view to render the model. The view will take the information in the model, like all the movies and each movie title, and it will use that information to construct an HTML page. And then that HTML is sent back to the client in the HTTP response. And, thus, we've completed an entire HTTP request and response transaction. These are the basics of the MVC design pattern, and we'll be working in each one of these steps in this module. The idea behind this pattern is to keep a separation of concerns. So the controller, it's only responsible for taking a request and building a model. And it's the model that carries the logic and data we need into the view. And then the view is only responsible for transforming that model into HTML. We have three components, each with its own focus on a specific part of the job. In order for all of this to work, we need to find a way to send these HTTP requests to the right controller. And in ASP.NET MVC, this process is known as routing. Let's look at how to route requests to different controllers.

Routing

The ASP.NET middleware we installed in the last module needs a way to determine if a given HTTP request should go to a controller for processing or not. The MVC middleware will make this decision based on the URL and some configuration information we provide. One way to define this configuration information, this routing information, is to define the routes for our controllers inside of Startup.cs when we add the MVC middleware. This approach is often referred to as convention-based routing. And in this approach, we define templates that tell MVC how to look at a URL and find a controller name and an action name where a controller is a C# class and an action is a public method on that class. Another approach to routing is what we call attribute-based routing. With attribute-based routing, we can use C# attributes on our controller classes and on the methods inside of these classes, and those attributes have metadata that tell ASP.NET when to call a specific controller. Let's take a look at these two routing approaches in the next two clips.

Conventional Routes

At the end of the last module, we created a controller in our application. This is the HomeController class we created. And as you can see, this class doesn't need to derive from a base class or implement an interface or have any special attributes. What we have is a plain C# class with a name, HomeController. And as the open browser on the right-hand side of the screen demonstrates, we can see the string this controller Index method returns just by browsing to the root of the web application. Currently, we aren't using models. We aren't using views. We're just going to focus on routing to controllers for the moment. And to understand how this works, let's return to the Startup class where we configured MVC middleware into our application. When we did this inside of the Configure method, I used a method UseMvcWithDefaultRoute. This gives me a default routing rule that allows me to get to the HomeController. But let's make this more explicit. Instead of using UseMvcWithDefaultRoute, let me just use UseMvc, and I want to configure the route at this point. And I'm going to do that using a named method. Typically, you'd just pass in a lambda expression to use MVC and configure the routes that you want using that lambda expression. I'm going to press Ctrl+period(.) and have Visual Studio generate a method for me, ConfigureRoute, and that just makes things a little more explicit. It's inside of here where I am going to configure my routes. You can see that this method has to take a parameter of type IRouteBuilder. Let's call this routeBuilder. And just to reiterate, the goal of routing is to describe the rules that ASP.NET MVC will use to process an HTTP request and find a controller that can respond to that request. You can have one route that can map requests to many different controllers. You can have 100 different routes. But let me show you what the default route is. The default route that MVC would use looks something like this. I'm going to tell the RouteBuilder that I want to map a new route. I can give this route a friendly name. Let's just call it Default. And then I provide the most important piece of routing information, which is the template. The template is a string, and it's going to describe to ASP.NET MVC how to pull apart a URL. So, for example, if the browser sends a request to this application and the URL path is /Home/Index, what I want the MVC framework to do is say, Oh, you want to reach the HomeController, so I can instantiate that controller, and then what do I invoke on that controller? I can see you want to invoke the Index method. We typically call public methods that are on a controller actions because a public method on a controller is something that I can reach via a URL. And even though I don't have the word "controller" in the URL, ASP.NET MVC can just apply a convention where if you tell it to use this first part of the URL as the controller name, it will just tack on the word "controller" and then go searching for a class that has that name in this application. This is the purpose of the template. So I'm going to write a template that says the first part of the URL will be controller. The second part of the URL will be the action to invoke on that controller. And then I can even include additional pieces of information in the URL. For example, the default route will include an Id parameter at the end of the URL. But I will add a question mark here because that parameter is optional. In other words, ASP.NET MVC doesn't have to see some sort of Id here, which might be a number, or it might be some sort of string or a GUID. That part's going to be optional. But because these pieces here are inside of curly braces, MVC knows to treat those portions of the URL as parameters. In other words, controller is in the first segment. The action name, pull that out of the second segment. And if I save my Startup and come back and refresh the browser, what we will find is that I get my greeting message. Remember, the greeting message came from this app.Run middleware, and the reason we're getting a greeting message is because the MVC middleware saw that URL, which was a request to the root of the website, and didn't find a controller name or an action name in the URL, so it just gave up processing that request and passed the request through to the next piece of middleware, which is the app.Run code, which just shows a greeting. And this is because the template that I'm specifying isn't quite like the default template yet. In the default template, there are some default values to apply if a controller and an action name aren't found. And I can specify them just using equal signs and then the name that I want controller to be if MVC doesn't find the controller name in the URL. In other words, if a request comes in to the root of the website, right now the default controller name would be Home. I could change that to Hello or whatever I want, but we're going to leave it as Home. And I will set the default action name to be Index. Now if a request comes in to the root of the website, MVC doesn't see a controller/action type of URL. But it can use these defaults. And so now if I save Startup.cs, I should be able to come back the browser, refresh this request to the root of the website, and now I have a response from my controller. And I can also go to /home. That's going to invoke the default action, which is index. And I can also go to /home/index. And now MVC is pulling the controller name and action name out of the URL. Let's create another controller really quick and see if this works. I want to add another class. Let's call this one the AboutController. And let's give this one some slightly different actions. Let's have a public method that also returns a string. We'll call it Phone. And what this could do is return just a phone number. We'll get into fancy HTML later. Let's just use 555-555-5555. And we'll give it one more action, Country. This one will just return the string USA. Let me save that controller and see how we can get to it. Now obviously if I go to the route of the website since the default says use the HomeController, I'm not going to go to the AboutController. But I should be able to go to /about/phone and see the phone number or /about/country and see the country. If I go to just /about, that again is going to fall through the middleware and go to my app.Run middleware. Essentially what happens here is ASP.NET MVC says, I think you want to go to the AboutController. I see that in the URL, but I don't see an action specified. I'll default to Index. And since this controller doesn't have an Index method, then I have not found a match for this route, and that request will go onto the next piece of middleware. And this is really the essence of routing. I need to describe one or more rules that the framework can apply to figure out where I want to go. What controller do I want to instantiate and what method do I want to invoke on that controller? You can have as many routes defined as you like. But for the most part in this course, we're going to work with this very simple route. However, I do want to show you one alternative to routing. Routing is very flexible in ASP.NET. There are many different ways you can do it. This is what we would call convention-based routing. But in the next clip, let me give you a preview of what it looks like to use attribute-based routing.

Attribute Routes

The alternative to convention-based routing is to use attributes. And before I show you the attributes, let me do just a little bit of cleanup in here. I want to remove this comment, and I want this method name to be ConfigureRoutes because you really can map multiple routes here. Routes are evaluated in the order that they appear, the order that you register them, but it's quite common to map multiple routes particularly if you want to have different parameters in the URL or if you want to have different literals in the URL. So this URL would have to start with company and then do /controller and /action and perhaps a /Id. But another way to define routes, routes that coexist with the convention routes, is to use attributes. So let's imagine here in the browser that I want /about to come to this Country action of the AboutController. If that's the case, then I'm going to enforce some explicit routes for this controller using a Route attribute. This attribute is in the namespace Microsoft.AspNet.Mvc. So I'm going to bring in that namespace, remove my unnecessary namespaces, and now describe to ASP.NET MVC what this route would look like. I want this route to look like about. And for the Phone action, when I specify the template, I'm just going to specify an empty string. That's a way of telling MVC I don't need the action to be specified to get this method, the user just needs to come to /about. Let me save this controller and show you an error that can happen in this case. And the error is that there is an AmbiguousActionException. Essentially, the MVC controller determined that I wanted to go to the AboutController, but it didn't know which method inside of the controller to select. Is it going to be Phone, is it going to be Country? There's no information in the route about which of these actions to select. And so if I wanted Phone to be the default, I could explicitly say, I have to see "country" in the URL to get to this action. And now if I save the AboutController, going to /about should give me the Phone action, which is does. And going to /about/country will still allow me to get to that Country action. Now here's a little tip. If you want a segment of the URL to contain the name of your controller, what you can do is instead of using the controller name explicitly, you can use a token controller inside of square brackets, and that tells ASP.NET MVC to use the name of this controller in this position. This way if you ever rename the controller, you don't have to remember to change the route. The same goes for an action. And implicitly there is a slash (/) between this controller and this action. It's a hierarchical relationship between the controller and the action just like it is inside of the URL, and I should be able to save this controller and achieve the same results I had before. It's also possible for me to put literals in here, so I could say that in order to reach this controller, the URL has to start with company/about. So if I refreshed the existing URL, we don't find the AboutController. Now I need to go to /company/about/country to get here. And if I'm not going to have special routing rules for my actions, and I don't need Phone to be the default action here, what I could do is just go ahead and specify action up here in the controller route attribute. And now refresh, and I'll still be achieving the same result at least when I go to country. But now when I need to get to the Phone action, the route template I'm using now says that the action has to be in the URL. So I have to go to /company/about/phone to get the phone number. And that is a quick demonstration of attribute-based routing. Again, there's a lot of flexibility here. And we will be revisiting routing in the future of this course as we need some special features. But now you know that you can combine convention-based routing with this attribute-based routing. And the attribute-based routing is great for special case routes or actions that need some additional parameters. Convention-based routes don't handle those very well. However, many of the controllers that we're going to write, they will just use the convention-based routing. And now that we know a little bit about routing, let's turn our attention to the controllers.

Action Results

So far in our project, we've been using plain simple C# classes as controllers. These classes don't derive from a base class, and you can use this approach with MVC, but it's much more common to derive a controller from a controller base class provided in the Microsoft.AspNet.Mvc namespace. This base class gives me access to lots of contextual information about a request, as well as methods that help me build results to send back to the client. I can send back simple types like strings and integers in a response. But I can also send back complex objects like an object to represent a restaurant and all the data associated with a restaurant. These results are typically encapsulated into an object that implements the IActionResult interface. And there are many different result types that implement this interface, result types that can contain models or the contents of a file for download. These different result types can allow us to send back JSON to a client or XML or a view that builds HTML. Let's take a closer look to how this works. Inside of our project, let's swing over to the HomeController, and what I want to show you through the IntelliSense window is just the API that I have available to me inside of this controller action. As you can see, there's not much available. Most of the methods here are just the methods that I inherit from my implicit base class, which is system.object. And these members are not really useful when programming a controller action. And that's why most controllers will derive ultimately from a controller based class. Again, this base class is in the Microsoft.AspNet.Mvc namespace, so I'm going to bring in that namespace. I'm also going to go ahead and remove the namespaces that I'm not using. And now if I come into the Index method and look at the IntelliSense window, there's a lot more information available. There's a bigger API. There're a lot of properties in here that represent contextual information. So if I want to find out more information about this action that I'm inside of, the ActionContext property will give me that information. There's also an HttpContext property. Using that, I can get to a Request object and a Response object, and I could, for example, look at the headers in the request, or I could set headers for the response. And I'll tell you now there's typically a better way to do some of these things. I typically recommend that you try to avoid using HttpContext inside of a controller action. And I'll show you some examples as we go through this course of places where you can avoid using HttpContext directly. But then there's also an API available in here, a number of methods that are available, methods that produce results. So, for example, the File method. This is a method that I can invoke and pass in an array of bytes or a path to a file that exists on the disk somewhere. And what the File method will do is build something known as a virtual file result. And I can return this result from my controller action, and the MVC framework knows how to process that result and turn it into something concrete that goes into the response. And there're a number of these helper methods. So there is File. There is View, which creates a view result. We'll be using that later in this module. And there's even one to return simple strings. It is a method named Content. So instead of returning a string from my Index method, I'm going to take my string, pass it into the Content method. This Content method produces (you'll notice in the IntelliSense window) a ContentResult. And that means from my Index method, I can return ContentResult here, and all of these different result types, they all implement ultimately an interface, which is IActionResult. So I could have my return type as ContentResult or IActionResult, either one. IActionResult is a lot more flexible. It could allow me to return different types of results from the singular action, and a lot of people just use IActionResult as the return type for all of their actions. But if you know you're going to be returning a ContentResult, it could be quite helpful to use that as the return type. If you're going to unit test this controller, it does make unit testing a lot easier because you get a specific return type. And at this point, if I save the controller and refresh the browser, we are not going to have a response that looks any different from the response we had before. It's still just going to be a plain text response that says, Hello, from a controller! So you might be wondering what is the advantage of using something that produces an ActionResult. Well the typical advantage is that it's just a formal way to encapsulate the decision of the controller. So the controller decides what to do next. Do I want to return a string? Do I want to return HTML? Do I want to return a model object that might be serialized into JSON? All the controller needs to do is make that decision. The controller does not have to write directly into the response the results of its decision. It just needs to return the decision. And then it's the framework that will take a result and understand how to transform that result into something that can be sent back over HTTP. And this separation of deciding what to do next versus actually doing that thing gives us some additional flexibility, makes controllers a little more testable, and it gives me the ability to do something like the following. Let's go ahead and build a model. I'm going to create a folder in my project. Let's call this folder Models. And inside of this folder, I want to add a class that can represent a restaurant. So the name of this file will be Restaurant.cs. And let's throw something together pretty quickly. Ultimately, I will have Restaurant stored inside of the database, so I want every restaurant to have an integer property that is the Id of that restaurant, its primary key. And I would suspect that every restaurant will ultimately need some name. And let's work with this very simple model for right now, just two properties. We'll add more later. I'm going to remove some unnecessary usings, close my Restaurant.cs file, and now inside of Index, I want to declare a model and set it equal to a new Restaurant, which means I will need to bring in a namespace. And that namespace is OdeToFood.Model. So we'll bring that in. And let's go ahead and initialize the restaurant, just give it an Id of 1. And the name can be Sabatino's. And now instead of returning Content, just a plain textual string, I'm going to produce a different type of result, a result that is known as ObjectResult. It's a bit of a special type in the MVC framework, and there is no helper method for this result. So we have Content, we have File, we have View. Those are all methods that I can invoke on this controller to produce something that implements IActionResult. But if I want an ObjectResult, I need to create or instantiate an ObjectResult and then give it some model object. An ObjectResult is special in the MVC framework because when I return an ObjectResult, the MVC framework looks at this object and says, You returned to me an object, and obviously we need to represent this object somehow in the HTTP response. So should we take this object and serialize the object into XML or JSON or some other format? And ultimately the decision will be made based on some configuration information that you give MVC at startup. Or if you don't configure anything, you just get some defaults, and the default is a JSON response. It's very easy to add in XML support, too, but if I come back to the browser now and refresh, I have a response that I could easily consume from JavaScript. So when you're building an API and returning raw data to a client, you're typically going to build controllers that return ObjectResult. And the framework will take those objects and serialize those objects using some information in the request and configuration information that you provided MVC. The default is just to produce JSON. And this would be an example of where we have a controller that has a method that will respond to an HTTP request. This method that we call an action will build a model. In this case, we're building a very simple model just by making up data in place. But it's typically at this point where you might need to call into some component that makes a request to the database or makes a request to some other web service or XML file. You build a model, and then you use that model to produce a result. Here we are using ObjectResult. That would be very good for an API. But let's also see how to take this model and render that model into HTML with a view.

Rendering Views

With the MVC framework, the most popular method for creating HTML is to use the Razor view engine of ASP.NET MVC. To use this view engine, a controller action produces a ViewResult object, and a ViewResult can carry the name of the Razor view that we want to use. The view will be a file on the file system. And the ViewResult can also carry along a model object to the view. And the view can use this model object when it creates the HTML. When the MVC framework sees that your controller action produces a ViewResult, the framework will find the view on the file system, execute the view, which produces HTML, and it is this HTML which the framework sends back to the client. Let's see how this works in our application. Inside of our HomeController, instead of producing an ObjectResult, let's just return what the View method returns. Now the View method doesn't return an ObjectResult. It creates a new ViewResult, so I will also change the return type of my Index method. And although the View method does accept some parameters, I'm just going to invoke the method without any other parameters, and we're going to see how the application behaves because what we should see---because what I've done by producing a ViewResult is that I've told the MVC framework I've made a decision. I want to render a Razor view, and now the MVC framework has to go out and find that view. Views by default in a C# ASP.NET project, they are files that have a .cshtml extension. And the views follow a specific convention. By default, all views live in a Views folder in the project. And the view location and the view file name will be derived by ASP.NET MVC if you don't give it any additional information. So if I need to render a view from the Index action of the HomeController, the first place that the MVC framework will look for that view is inside of the Views folder. It will go into a Home folder (Home because I'm in the HomeController), and then look for a file called Index.cshtml. The file name starts with Index because I'm in the Index action. The MVC framework will also look in a Shared folder. This is a folder that we'll use later in the course. Views that you place inside of the Shared folder, you can use them anywhere in the application. But in order for my view result to work properly, I'm going to need to create this Index.cshtml file in the correct location. So in the project, let's go ahead and add a folder that will contain all of our views. I will call it Views. And inside of there, I will add a folder for views that are associated with my HomeController. So that folder name will be called Home. And now I will add a new item, and this time I'm going to search the templates for Razor because what I want to create is an MVC View Page. And I do want the name to be Index.cshtml. Now we will be talking about views in more detail later in this course. For right now, I just want to show you some of the very basics. The first thing I'm going to do is delete everything that is in this file and get us started with a very basic HTML template. I can do that just by using a code snippet. Just type HTML and hit Tab. It will expand out to give me an HTML element with head and body inside. So you can see already that a cshtml file, it can contain HTML markup. And any markup that I have in this file, it will be sent directly to the client. So I can give this page a title. Let's just give it a title of Home. And inside of the body, create an h1 element, we could say Welcome!, and perhaps a div that says, This is the home page. I'm just going to save this file, come back to the browser and refresh. And now my controller via a ViewResult has rendered this view to the client. And all of the markup that is in that index.cshtml file, that is what was sent to the client. And now let's go back to the HomeController for a moment. And I just want to show you that this View method, it has a couple of different overloads, and I can if I want explicitly pass in a viewName to use. So if I don't want to use the default view for this controller action, which will be Index.cshtml, I could pass a string Home, and now the MVC framework will go off looking for Home.cshtml. I can verify that by refreshing the browser, and I should see an error message. The framework went looking for Home.cshtml, didn't find it, and now we get an error message. I can also pass along my model and then use this model inside of my view. And when I pass along a model, the view name is still optional, so there is a version of the View method that just takes a model object and that will use the default view, which is Index. And this is the version of the method that I want to use. I just want to pass in that model information and use that model inside of Index.cshtml. And the way I can do that is by using little expressions inside of my Razor view, little C# expressions. When I use the @ sign in a Razor view, I switch from this mode that just takes literal text, like h1 Welcome!, into a mode where the Razor view engine is going to treat whatever I type as a C# expression. And it's going to try to evaluate that expression to produce some value. And when I'm inside of a view, it's as if I'm writing expressions inside of a class because ultimately a Razor view does generate C# code that is compiled and is associated with a specific class. And a Razor view contains some built-in members that I can access inside of these C# expressions. One of the most important ones is capital M Model. When I say @Model, I am getting to the model object that I have passed into the view from the controller. So if I say @Model.Name and my model object is a restaurant, then as long as my restaurant has a name, that should be displayed inside of my view. I should be able to save all my files, come back and refresh the browser, and, indeed, I see the restaurant name. And what we're really seeing here is the essence of ASP.NET MVC and the MVC design pattern. It's very simple at this point. We're not doing much, but I have the controller that provides these action methods that will be invoked when an HTTP request comes in. The action's job is to build up a model by calling into a database or doing whatever work needs to be done to build that model and then producing some sort of result that can consume the model. So in this case producing a view result, we pass the model object along, the model has no idea that it's being used by this controller or by some view. It's just carrying along information and logic. And inside of a view, I can access that model to help sprinkle all of the data that I need into an HTML template. Now one more quick tip: When I'm working inside of this Razor view and I'm using @Model.this and @Model.that, I will not have any IntelliSense because Visual Studio at this point doesn't know that the model should be a restaurant object. If that's something that I want to happen, I can use @model with a lowercase m and tell Razor what the type of model object will be, in this case it will be OdeToFood.Models.Restaurant. So @model, this is what we call a directive. It influences the code that is generated from a Razor view. And the @model directive specifically tells us what the type of model object should be. And then when you're building your HTML, you use @Model with the uppercase M. This is a property that you can access through expressions. And now that we know the type of the model, you'll notice that I get some IntelliSense here. And now I know I'm working with a restaurant. I could show the Id of the restaurant, or I could continue showing the name. And if a controller were to pass in the wrong type of model, perhaps the controller passes along a string instead of a restaurant, then I would have a runtime error.

A Table Full of Restaurants

Let's build on the example that we have and display a collection of restaurants, multiple restaurants, because ultimately I want to hook this application up to a SQL Server database that will contain multiple restaurants. And eventually I want to see all of the restaurants that are in the database. I'm not going to hook up to the database just yet--we'll do that later in the course--but I do want to write a service or a component that will simulate data access. This component will just hold the restaurants in memory, and, later, partly to demonstrate the flexibility of this ASP.NET Framework, we'll swap that component out with another component that actually talks to SQL Server. So we're going to start in the Services folder because I want to write a component that a controller can use to access restaurant information, and the controller doesn't have to directly instantiate restaurants itself. Let's call this RestaurantData.cs. And similar to what I did with the greeter service, I'm actually going to define two abstractions in here, one in interface IRestaurantData and one a concrete class. Let's call it InMemoryRestaurantData to differentiate this class from the class that we eventually want to write which will access SQL Server. This class is going to implement IRestaurantData. And the idea is that I want other areas of my application, things like controllers, to work against this interface IRestaurantData. Controllers shouldn't know that I'm actually using InMemoryRestaurantData versus SQL Server restaurant data. They're just going to program to this interface IRestaurantData, and this interface will define whatever methods are needed that the controllers would need to read restaurant information or update restaurants or create restaurants. So let's start off with a single method here. It will be a method that returns IEnumerable of Restaurant. We'll just call this method GetAll. And in order for this to work, I will need to bring in the namespace, OdeToFood.Models, and now implement this interface or that method with my InMemoryRestaurantData. Let's create some fake restaurant data. I think I will do that through a constructor on this class and give this class a private field of type List of Restaurant. We'll call that _restaurants. And up here initialize this list. Now I do want to caution you that anytime you use something that is just a list of something, list isn't thread safe, so you have to be a little bit careful using it in a web application. But I'm going to assume we only use InMemoryRestaurantData when developing or when testing, so we're not going to have to deal with multiple users. When we actually deploy the application, we'll use a real SQL Server database. And a database can handle multiple users easily. Let's initialize _restaurants to a new List and add some restaurants in here. Let's create one restaurant with an Id of 1. Let's give it the name Tersiguel's. And another restaurant with an Id of 2 whose name could be LJ's and the Kat. And just one more, a restaurant with an Id of 3 who name is King's Contrivance. And now all the GetAll method will need to do is simply return this list of restaurants. And now inside of the HomeController, I want the HomeController to be using this new data source. But I do not want the controller to directly instantiate InMemoryRestaurantData. I only want the controller to program against IRestaurantData, and this is very easy to set up if you remember what we did earlier in the course inside of Startup.cs when we configured a greeter service. Once I have a service registered with the framework, then other areas of the application can simply ask for an IGreeter or an object that implements IGreeter, and the framework will figure out the actual concrete type that needs to be instantiated and passed into this Configure method. I want to do the same thing but with my IRestaurantData. This time I'm going to say services, let's AddScoped for IRestaurantData, please use InMemoryRestaurantData. Now I told you that when we use AddSingleton, that is telling the framework that there should be one instance of this greeter service for the entire application. Every method and component that needs an IGreeter, they will have the same object injected. Scoped is a way of telling the framework that each HTTP request should get its own IRestaurantData. So if there're two or three components that need to coordinate to process a single HTTP request, those two or three components should all get the same object instance. But when the next HTTP request comes in, the framework will create a second instance for all the components that need to use IRestaurantData in that request. So we're scoping the lifetime of the service to a specific single HTTP request. And with that in place, I should be able to come into my HomeController, and instead of manipulating restaurant information directly, let's write a constructor, one that will take IRestaurantData, and call this parameter restaurantData. And for this to work, I'll need to bring in the namespace, OdeToFood.Services, and then I want to save this restaurantData parameter off into a private field so I have access to my restaurant data throughout the rest of the controller. And now instead of a single restaurant, my model will be a collection because I'll say _restaurantData, please get me all restaurants, and I will pass that model into my view. Let me just show you what currently happens if I refresh the browser, and we will have an error message because, you remember, in the Razor view, we said that the model object we expect will be a single restaurant. And the error is telling us that we actually passed in a list of restaurant. So let's fix up the view so it can work with a list of restaurant instead of a single restaurant. And I think instead of explicitly saying that I work with a list, I will say that I work with an IEnumerable of restaurant. So a list is IEnumerable, and many other collection types are IEnumerable. And so this is a nice level interface to work with when all I need to do is loop through some collection of objects because now I don't have a single restaurant. I'm going to build a table and create a table row, one for each restaurant. I can do that using a foreach statement. So in addition to expressions like @Model.Name that will spit out the restaurant name, I can also write code blocks and use C# keywords like foreach. So foreach restaurant that is in capital M Model (remember, capital M is the property that holds my model object), foreach restaurant that I have in that collection, I want to write out information about that restaurant. And what Razor will do is make a copy of this tr, once for each time I go through this loop. So for each restaurant, I want to write out restaurant.Id, and I want to write out restaurant.Name. And, again, we'll be talking about Razor in more detail later in the course, but you can see that Razor views are pretty smart at switching between C# code, which is my foreach statement and this opening curly brace, and switching over into HTML mode where I have tr tags with td insides, and then I'm back to using an expression that is something that doesn't have an opening in the closing curly to write out some data into my HTML. And if I save this view, hopefully I will be able to refresh this page and see the three restaurants. And so this is just a little bit of a preview of the rest of the course. We will eventually work with model data that comes from a SQL Server database. We'll also be looking more in depth at Razor views and the syntax that we're seeing inside of the cshtml file and seeing how to put all these components together--controllers, models, and views--so they can display information and edit information.

Summary

In this module, we learned about the model-view-controller design pattern and began to see how the different components work with each other to process an HTTP request. The controller receives an HTTP request and works to build a model. The controller then selects a view to render that model, and the view renders HTML and places that HTML in the response. In the rest of this course, we'll continue with the MVC design pattern and dig into some details on views and models to show and edit data.

Models in the MVC Framework

Introduction

Hi! This is Scott, and in this module, we're going to take a closer look at models in the MVC framework and working with data in general. We will look at the concept of a view model, both the input and output view models, as well as how to work with the Entity Framework to save our restaurant information into a SQL Server database. To get started, let's talk about the concept of a view model.

Models and View Models

Quite often in MVC development, you find yourself in the following situation. You have an application with a database to store data, and that data could be users, restaurants, movies, invoices, whatever's important to your business. When you store something like a restaurant in this database, the database will require and store specific pieces of data. For a restaurant, imagine we're storing the restaurant name, the address, and the type of cuisine that the restaurant serves. Now somewhere else in the application, you might need to build a view to edit the restaurant information that is stored in the database. The edit view will also have some requirements. It will need the name of the restaurant, the address, and the cuisine type so that it can display these attributes and allow the user to edit the data. But an edit view typically needs more data than what the database even stores for a restaurant in a single table. For example, the edit view might want to create a pick list for the cuisine type, and it needs to build this list by fetching all the possible cuisine types that can be stored in the database. But when we query the database for a specific restaurant to edit, we only get the restaurant data with the current cuisine, not a list of all the possible cuisines. And it's in situations like this where I think of two different model objects. One is what I call the entity model. An entity is an object that I persist into the database. And an entity model typically looks just like my database schema. If the database stores just the name and address for a single restaurant, my restaurant entity also stores just the name and address. The other type of model object I think about is the view model object. A view model is an object that I use to carry information between a view and a controller. It contains everything that a view will need to render HTML. So in the case of an edit view for a restaurant, I need a view model that contains not only information from my restaurant entity with the name, the address, and the cuisine type for a restaurant, but also the additional information that the view needs like the list of all possible cuisines. Quite often, this requires the controller to make multiple queries and pull back multiple entities to build this view model and put all the information inside that the view needs. And that's why sometimes we also call a view model a DTO or data transfer object because this view model carries information around. We don't persist the DTO or save the DTO into a database. But we do often copy information into a view model from an entity and from a view model back into the entity so we can save something in the database. And moving forward, if you can think, there're two different types of models that I can use in my system. They serve different requirements. One is focused on the database. One is focused on the views. That can quite often make your application a little bit easier to build. Let me give you a concrete example. Currently in the application, our home page displays a list of restaurants from the restaurant data store. But let's imagine that the home page needs to display additional information. Not only do we need the list of restaurants, but we also need to display today's current message. And the restaurants might come from a database, and the message might come from a configuration file. Regardless of the different data sources involved, what my HomeController needs to do is put together a model that contains all the information that this view needs. So to pull this off, I would probably do a little bit of refactoring of what we have so far because this Restaurant class that we have I really want to think of this as an entity. It is a class that represents the information I'm going to persist into a database. And it doesn't matter if it's a relational database or a document store. An entity is something I want to persist. And over in the view, although I can still use restaurant data right from that restaurant information in my model, it can no longer be just a simple collection of restaurants. So the first thing I'm going to do to make this a little more explicit is I'm going to change the folder name that is currently Models, I'm going to change it to be Entities. I'm going to close Restaurant.cs and reopen this file because sometimes Visual Studio acts a little bit funny when you rename a folder. The editor doesn't like to work on the files that are inside. But now that I've reopened it, I'm also going to change the namespace because I really like the convention in .NET where the namespace and the directory structure are somewhat in sync. So the Restaurant class is in the Entities folder. It's in the Entities namespace. This will require me to fix up some code through my application, and I'll get to that. But now let me create a new folder, and this folder is going to be called ViewModels. So not every application needs to make a distinction between entities and view models. There're are many simple applications and simple controllers you can write where your entities are your view models. But I do want to show you the example of what a more complex application might look like where you do need to make this distinction between classes that store data and classes that carry information into your views. The view model that I want is a view model that is dedicated to the home page. It will contain the list of restaurants, it will contain the current greeting. So let's call this the HomePageViewModel. I know this class will need to carry along a list of the restaurants into the Index view, but we can work with IEnumerable of Restaurant. So I am going to use my Entity class here inside of the view model. That's not always something you can get away with either. But I am trying to simplify just a few things in this course. I've added the namespace for OdeToFood.Entities. We will call this property Restaurants. And then I also need a property to carry the current greeting along. So let's have a string property named CurrentGreeting. And now I can Ctrl+period(.) and remove the unnecessary usings in this file, save it off, and close it. And let's go to the controller next. My controller, I will change this Models namespace to ViewModels because we're going to be using this HomePageViewModel, and we will be using that instead of just using restaurantData.GetAll as the model. So I want the model to be a new HomePageViewModel, and we'll say that model.Restaurants equals our _restaurantData, we'll get all the restaurants. And then model.CurrentGreeting. Where are we going to pick this up from? Well we will get this from the greeter service, but before we do that, let's fix up a few more things. First of all, a HomePageViewModel, this should be Restaurants with an "r", so I'll save that file again. I want the "r" in here. And _restaurantData.GetAll is currently complaining because I've changed the namespace for restaurant, so the compiler doesn't know where this is. This is now OdeToFood.Entities. Let's, again, remove our unnecessary usings. I think this file is good to go. And now my HomeController is happy. But how do we get the current greeting? Well just like we injected IRestaurantData, we can also inject our IGreeter. I'll call this parameter greeter, and I will also save that off into a private field that I generate just by hitting Ctrl+period(.), please generate this field for me. It is now part of my controller. And inside of the Index view, I can say CurrentGreeting = _greeter.GetGreeting. So now the controller has constructed the view model using a few lines of code and a couple of different services. It's going to take that model and pass it off to the Index view. Let's fix up the Index view. Now we're no longer working with an IEnumerable of restaurant. Instead we are working with an OdeToFood.ViewModels.HomePageViewModel. That will be the type of our model property. Here under the h1, let's add in a heading 3 element that displays the current greeting. And now to display the restaurants, I need to drill into Model.Restaurants. That will give me my IEnumerable of restaurant. Let's save of Index.cshtml and refresh the home page. And we now have a view that displays both a message and the list of restaurants. So in the world of ASP.NET MVC, there're actually a few different ways that you can get information from a controller into a view. I'm not going to provide you an exhaustive list of all those different techniques. I'm simply going to recommend that you build view models for your views and have those view model classes contain all the information that you need to shuttle from the controller into the view. And this has been a very simple demonstration of that technique, but you can extrapolate this out to view models that are very complex.

Detail a Restaurant

Now that we know a little bit about view models used as outputs, let's talk about models that are used as inputs to a controller action. Imagine that we want to give the user the ability to see the details for a specific restaurant, so not a list of all the restaurants. They just want to see a specific restaurant. If that's the case, we probably need to add another action to our controller, one that can return a ViewResult that shows just a single restaurant. And what can we use to identify a restaurant? Well I plan on the Id property being a unique primary key in the database. So it would make sense for the Details action here to take an integer Id parameter and then look up the restaurant using that Id. So anytime I have a parameter on an action, I consider that to be a type of model, an input model. And even though an integer is a simple primitive type in C#, with ASP.NET MVC, I do have the abilities to take complex input models. For example, I could have a restaurant as an input parameter here. But for details, all we need is a simple integer. And then the question is, Where does this integer Id come from? For right now, let's just return a string, and I'll just return id.ToString. That'll show us the Id that we receive. And if I save this controller and come over into the browser, I will show you that if I go to /home/details/2, my details action receives an Id parameter equal to 2. How does the MVC framework do this? Well when you have an input parameter to an action method, the MVC framework will do everything in its power to populate that parameter, and it will look around in the request environment to find something with the same name as this parameter. So I named the parameter Id. ASP.NET MVC is looking for something named Id. And in this case, when the parameter appears here in the URL, it is actually my routing rules that allow this to happen because I said if you see /controller name/action name/a third piece of the URL, then treat that third piece as an Id parameter. It's optional. It doesn't have to be there. But when it is, MVC will take the information contained in that segment of the URL and give it the name of Id. And then when I have an input parameter, the MVC framework looks around in the request environment. So it looks at things like the routing data that was generated from the URL. It also looks at query strings. It also looks at posted form data. And if I come out to the browser and I remove the 2 from here, I could also go to /home/details query string Id=3, and now I've received the parameter 3. So earlier I was telling you quite often you don't need to go into the HTTP context property and look at the request object to find something in the query string of the URL. The MVC framework can actually identify data that is in the request and hand it off to you. And you're probably wondering, What happens if I go to /home/details/1 and then use a query string Id=3, well in this particular situation, the MVC framework favors the Id that was found in route data over the Id that was found in the query string. And that's just an implicit default in the framework. So now let's go to the business of actually finding the restaurant with this Id and returning some sort of result that will display details. So in this scenario, my model, I'm just going to pull out a restaurant from _restaurantData, and that restaurant entity will be my model just to simplify this scenario. And I'm going to need a new method on my _restaurantData service that will allow me to get a single restaurant given the Id. Let's write that real quick. Over in RestaurantData, for the interface definition, I have to say that there is a method Get that takes an integer and returns a restaurant. And now I have to implement that member in my InMemoryRestaurantData. So a public method that returns a restaurant that's called Get that takes an Id parameter. And here I can just use a simple LINQ query to locate the restaurant in the list. So if I am using System.Linq to pull in all of the LINQ standard operators, I'll be able to say _restaurants., and let's use FirstOrDefault, which means LINQ will evaluate the following expression, and the first thing it finds that matches, it will return that. Otherwise, it will return the default value for restaurant, which is a null reference. And the expression that I'll use here, a lambda expression, r for restaurant, r goes to restaurant.id equals the incoming Id. And I just need to have a return statement here, and this becomes a very simple operation. Let's save RestaurantData, come back to our controller, and let's assume for right now that we always find the restaurant. So I'm just going to return a View with that model and save the controller. Now we just need a Details view. So I'm going to actually make a copy of Index.cshtml, so just click on the file, press Ctrl+C to copy, Ctrl+V to paste it, change the name of this cshtml file to Details.cshtml, and let's open it up. And, first of all, I will change the model here. I expect the controller to pass a Restaurant entity. Let's change the title of the page to use the restaurant name. And then down here would be all the details of the restaurant. Really, the only interesting attributes we have are name and Id, and the user probably doesn't care about the Id, so let's just write out the restaurant name in an h1 element. We'll add some more attributes to our restaurant later on. Let's test this out. Over here in the browser, let's go to /home/details/1, and I can see that is Tersiguel's, /2, so I'm pulling back just a single restaurant displaying that in a view. That's good. And what happens if I go to /22? Well now my RestaurantData returns a null pointer. It didn't find a restaurant with that Id. And because the view expects Model to not be null, and I de-reference Model and say @Model.Name, this is throwing an exception because the Model property is null. What can we do in this situation? Well there're a number of different solutions. One thing I could do is I could say if model is null, then do something different. I could, for instance, return HttpNotFound result. What that would do is set the response status code to 404 Not Found. And in order for that to work since I now have two different types of results that I can return, this is one of those scenarios where I can just say this method returns an IActionResult. So this would be one approach. I could also redirect the user. So there are helper methods available in the controller action that allow you to do temporary redirects, permanent redirects. In this case, I want to redirect to an action. Let's say if the restaurant isn't found, I'm just going to send the user over to the page that displays all the restaurants, and I can specify the action to go to here as a string. There's a different overload to this method where you can also specify the action on a different controller, but since we're just going to go to the same controller, all I need to do is specify just the action name. And now if I save the controller and refresh this page, the request for /home/details/ some Id that doesn't exist brings me back to the home page. It also might be nice if I come back to the last working one here if there was a link on this view that would take me back to the list. So some navigational links that work with the routing rules that I have defined. Let's go into Details. And I'll tell you upfront there're a couple of different ways to do this. Essentially what I need is an anchor tag with an href that points to /home/index, or since that's the default route just the root of the website, and I can have it display the text Home. That link would certainly work. But there're also situations where you want to generate a link in a way that works with your routing configuration. And that's where another property that is available on the view, that's where this HTML property comes into play. The HTML property is an instance of an IHtmlHelper. It contains a number of methods that allow you to generate little snippets of HTML. It's all HTML that you could write by hand. But typically, an HTML helper has some additional logic behind the scenes to use some metadata or to use some configuration information that's available in your application. And one example of this is the HTML helper ActionLink. Essentially, ActionLink will build an anchor tag like this, but when it computes the href, it will use some information that you provide to figure out what the correct URL is. So ActionLink is going to be a link to some controller action. The first parameter I pass in is the text that I want to display. So I want to display the text Home, and then you can see the second parameter to pass in is the action that I want to reach with this URL. And if I don't specify a controller name, it just assumes I want to go to this action on the controller that rendered this view. So this would be the Index action of the HomeController since this is rendered by the HomeController's Details action. You can see there're many different overloads of ActionLink that allow you to specify things like a different controller to go to. But this is all we need to get a Home link back to the list of restaurants. So this is two ways to do this. I will show you a third technique in the next module. It's a very useful new technique for this version of MVC. But let's also say when we are on this list of restaurants, I would like to have a link to go to the details. This is where we can use ActionLink again. So in the Index view, instead of displaying just the Id, I want the Id to be in a link that will take me to the details. So I want to use @Html.ActionLink. What is the text that I want to display? Well let me just use the restaurant Id again. Only I will make sure that this is passed as a string, that's my linkText. And when the user clicks on this, what action do I want them to go to? I want them to go to the Details action. And now because Details has this extra parameter, this Id that has to be passed along, I need to tell ActionLink about this additional data. That's the purpose of this routeValues parameter that you see here. Essentially, what you can do with routeValues is pass in an anonymously typed object, which sometimes Visual Studio will fight you trying to create that anonymously typed object, but I want a new object. And then I give this object properties for the data that needs to be passed along. And the names are significant. If I want a piece of data plugged into the Id portion of the URL, then I need to create a property called Id and then just give it the value like restaurant.Id. And now ActionLink will look at this information and say, You want to go to the HomeController because we didn't specify a controller here, and more specifically the Details action, and you want to pass along an Id parameter. Let me talk to the routing engine and figure out what that URL should be. So if I save Index.cshtml and refresh this page, I now have links. And I can see that this link in Chrome is for /Home/Details/3. That perfectly takes me to the Details page. And this Id parameter in the URL, I kind of think of it as an input model. But like I say, you can have more complex input models, and when we want to create an entire restaurant, we'll need more complex input models. So let's look at those next.

Create a Restaurant

What we want to do next is see how to create a new restaurant. With HTML, anytime you want to give the user the ability to enter data into a page, you use an HTML form element. How will we build this form? Well, like everything else with ASP.NET MVC, we will have an HTTP GET request that goes to a controller, and this controller action will return a view that includes the form. So to create a restaurant or edit an existing restaurant, we'll need an action that returns HTML with form inside. And inside this form, we'll have input elements to enter text and numbers. And we might have checkboxes and dropdown lists and sliders. There's a variety of input controls. We'll need this controls to have a name so that MVC knows how to process the incoming data when it comes back to the server. And ultimately this form needs to use an HTTP POST operation to send the form data back to the server where we can process the incoming POST with another controller action. And we'll see how MVC can map incoming form values from our inputs into a model object that is a parameter to our controller action as long as we follow some easy naming conventions. Let's see how it all works. Let's make this creation scenario just a little more interesting by adding some additional attributes to our restaurant. Actually, I just want to add one more attribute. But to make it more interesting than a simple type like string or integer, let's add an enum property to our restaurant. I want to be able to store the type of Cuisine that a restaurant serves. So there will be a property on a restaurant of type CuisineType, and let's just call it Cuisine. And the types of Cuisine would include None, that will be the default value, that's if we don't know the cuisine type of the restaurant. Let's also add Italian, French, and perhaps American. And I will save this restaurant definition, and I need a form now that will allow a user to input the name of the restaurant and the type of cuisine that restaurant serves. In order to build that form, I will need the browser to visit a controller action. So let's go ahead and create an action with the name of Create. And let's just have this action return a view. Since I'm creating a restaurant from scratch, I don't have a model object to give this view, although there are many scenarios that will require a model quite often when you are creating something. You'll need to provide some information on that page that allows the user to pick from a number of different options. Or perhaps you have some default values for some fields. Those are the types of situations where you can build and edit view model and populate that model with information that the view needs to display the correct form. Our scenario's a little bit simpler. And even though the user's going to have to pick the type of cuisine, I'll show you that we have enough information to do that. All I need is a Create.cshtml view. Let me go into the Views and, once again, Ctrl+C to copy a view and paste it into this folder with Ctrl+V and then highlight this and press F2 to rename it. I want this to be called Create.cshtml. And since we are creating a restaurant, I don't have a restaurant name to put in the title. So let's just use the text Create. I'll also use that text here. That's the top header for the page. And now what I need to do is build a form. And, once again, I can build forms, and I can build inputs just writing HTML. But I want to show you how to use HTML helpers to achieve this same effect because the HTML helpers know about the built-in conventions in the MVC framework. And when we follow the conventions, we typically write a lot less code. So I'm going to use the HTML helpers, but I'll show you the HTML that they produce once we have this form implemented. The first help I'm going to use is a helper called BeginForm. This helper is a little bit odd because you actually can wrap it in a using statement because this particular helper returns an object that implements IDisposable in C#. And the way this helper works is when you call BeginForm, it will basically write out the opening form tag at that point. And then at the bottom when the generated code calls dispose on that object, that's when it will write out the trailing/form. So BeginForm gives me an object that will write out my opening form tag and my closing form tag. Now I can just focus on labels and inputs. And I'll tell you upfront that this will not be the prettiest user interface. There're lots of videos and articles about styling forms. We're just going to focus on the ASP.NET MVC part of this. And what I need is to present a user interface so that the user can enter the name of the restaurant and select the cuisine of the restaurant. And once again, I could use raw HTML. I could build an input element myself. But I'm going to use an HTML helper for the name of the restaurant. This HTML helper is TextBoxFor. This builds an input type equals text. And it does this by using metadata about the model object that you're working with. And what I have to pass into this helper is a lambda expression that tells the HTML helper which property of the model do I want you to work with. So I have to pass in a lambda expression that takes one parameter. This parameter always has the same type as the model object. So m is a restaurant, but I'm using m for model. So given a model object m, I want you to look at the name of the restaurant. And you might be saying, But we're not passing in a model object into this view. And that's okay. What this HTML helper is doing is really looking at metadata about this property, what is its name, what is its type, and then building the appropriate HTML. If I was editing a restaurant instead of creating a restaurant, I would pass in a model object. And what TextBoxFor would do is build an input element whose value is equal to the name of the restaurant. So getting an existing restaurant's name into the form, that would be taken care of for me. Now there's also an HTML helper that will build a label for this input. And it also uses a lambda expression. Given a model object m, I want you to build a label for the name input. If I save all of my files right now, and we come back to the browser, I just want to test that going to /home/create actually gives me back a form where I have an input here. So this is good. Now let's allow the user to select the cuisine type. Let me build a label for that. So given a model object m, which is of type restaurant, I want a label for cuisine. And now I'm going to use an HTML helper, which is DropDownListFor. This essentially builds a select element with a number of options. Once again, I have to pass a lambda expression that says this is going to be setting the cuisine of the model object. And now, again, if I was editing a restaurant, that would set the initial value of this drop-down list to the value that is in the restaurant. And then this HTML helper needs some additional information. It's going to need a collection of SelectListItems, which is essentially what are the available options in this drop-down list. That's one of those pieces of information where sometimes you need to build an edit view model to pass into this view so it can build all of the pick lists for a user. But if you are using an enum type, sometimes you can get away with using another HTML helper, which is GetEnumSelectList. Essentially what this method will do is look at an enum type and use the names that are in that enum to build a list of select items, which are then used to build the drop-down list. What I have to specify is the type of the enum that I'm looking for, and I'm going to use typeof(CuisineType). And I'll have a little bit of a problem here because inside of Razor, the generated code doesn't know what CuisineType is. I either have to fully specify the namespace, or I have to add a using directive. So just like in a C# code file, I can have using statements that make the types inside of a namespace available. I can do the same thing in Razor with a using directive. I can say I want to be using OdeToFood.Entities. Now I don't have to specify the namespace here in the model directive. That type will be available. And also CuisineType will be available. So everything in that namespace is now available. And then the last piece of UI that I would need here is a button that the user can click to send this information back to the web server. So I'm going to have an input type="submit" whose value="Save". And now let me save all the files, come back to the browser, refresh, and I now have the ability to input a restaurant name and also select a cuisine type and then press Save. Let's just look at the HTML that was generated here. I'm going to view the page source. And I can see that the BeginForm helper created a form tag. The action for that form tag points back to the action that I came from, so /home/create. But when I click the Save button, what this form will do is an HTTP POST back to the web server. So I use an HTTP GET to retrieve this form. I'm doing an HTTP POST to send this form back to the server. And then I have my cuisine types inside of a select. I have an input for the name. Notice the name attribute of this HTML element was set to Name. That's a very important convention. We'll see how that works in the next clip. For now I just want you to know if I was editing an existing restaurant, the view would almost look identical. The only additional piece of information I would have to store is the Id of the restaurant that we're editing so we can send that back and the server knows which restaurant we're editing. And I could store that inside of a form. That's typically done with something like the hidden fields, so input type equals hidden. That way the user doesn't see the Id on the screen. Typically, they don't care about the Id. But we'd still have that piece of state inside of our form to send back to the server so it knows what restaurant that we're editing. So in the next clip, we'll try to process this form and actually save a restaurant.

Accepting Form Input

Now we are ready to post our restaurant to the web server, and this will reach a controller action that has an input model as a parameter to the action. As I said before, the MVC framework does everything it can to populate your action parameters based on information in the HTTP request environment. Like earlier we took an Id to the Details action, and MVC populated the Id parameter with the Id from the route data. It also worked when the Id was in the query string. For complex input types like a restaurant type, MVC will look at the properties on the type and map route data, query string, and form data into these properties. If we post a form with name and cuisine in the form data, MVC will automatically map those values into their respective properties by name on the input model. So if a restaurant has a name, it will receive the name value from the posted form values. You do have to be very careful when selecting an input model because MVC will, by default, try to set all the properties, and you can never, never trust data coming over the network. We'll talk about that more in this clip and see how it works. To process our posted form values, let's go back to the HomeController. And I know based on the HTML that we looked at that this form is going to post back to /home/create. There are parameters that I can pass to BeginForm to tell it to behave differently, for example, to do a GET request instead of a POST request or go to a different controller or a different action. I'm going to let it come to /home/create, and I'm going to create a different version of the Create action to receive the posted form values. Now I could use Restaurant as my input model. And I am going to bring in the namespace OdeToFood.Entities, but there are several downsides to this. I do not know what data I'm going to receive over the network. And if my restaurant has any properties or any attributes that I don't want network data to get into, then I am much better off not using an entity but using an input view model. It's much safer. And I'm going to demonstrate how we can do that. So instead of taking a restaurant here, which would work, I'm going to create a new input view model by adding a class to the ViewModels folder. Let's call this RestaurantEditViewModel. And I could use this class for creating a restaurant or editing an existing restaurant. The most important thing here is that if I am creating a text box for the restaurant Name input, that will create an input with a name of Name. And in order to receive that input, I will need a property on my input model that has the same name as that field. So the name is Name. And I can also have a property to accept the cuisine type I'll need to bring in the namespace OdeToFood.Entities. But the name for this property will be Cuisine. And even though I'm working with a restaurant model on one end, on the outgoing end, I can still using this edit view model to receive inputs from the form. And in all but the simplest scenarios, that is what I would suggest just so you don't open up any security holes. This view model will contain only the properties that I expect to receive in the HTTP request. So let's close this out. And in the controller with this new Create action, we will take a RestaurantEditViewModel as our model. Now we're not doing any validation yet. But I just wanted to set up the simplest scenario for seeing if we have retrieved the correct information. So let's try to create a new restaurant out of this model information. So in the controller action itself, I will create a new restaurant, and I will map fields from the input view model into my restaurant. So this is a little more work than just using a restaurant itself as the action parameter. But it is safer. And the restaurant.Cuisine would equal model.Cuisine. At this point, I want to be able to walk up to my restaurant data and tell it to add this new restaurant. And then just to see if we get the correct results, for right now, I'm going to return a View result. But I'm going to explicitly return the Details view and pass in the restaurant. I just want the Details view to dump out what information we have on the restaurant. So over in Details.cshtml, we're already displaying the restaurant name. Let's also display the restaurant Id so we can see if the Id gets generated. I would expect most data sources to be able to automatically populate the Id of this new restaurant with a unique identifier. And let's also in the Details view see if we get the correct cuisine, so @Model.Cuisine. And let's just add a little bit of text so we know what we're looking at here. I'm displaying the Id and the cuisine. So we just want to see if we can get the input values into our model, copy these values into a new restaurant, and save it into our data source. There're a couple more changes we'll have to make later, but for right now, what I have to do to get this working is have an Add method on RestaurantData. So let me go to my Services and have a method called Add that takes a new restaurant, and implement this in our InMemoryRestaurantData. So a public method called Add that takes a restaurant, and I want this data source to compute a new Id for this restaurant. And one way I can do that is by looking at my existing restaurants and using a link query to say, Give me the maximum Id that you see in the existing restaurants, and then we'll add 1. So newRestaurant.Id = that computed Id. And then I can go ahead and save this new restaurant into my collection. Now there's one more thing I'm going to change to get this to work. I'm going to make this list of restaurants a static member. And that means that this class is not thread safe at all. And if you ever have concurrent users working with this InMemoryRestaurantData, there's a pretty good chance it's going to explode and die. But I do just plan on using this for testing purposes when I'm an individual developer. And the reason I'm making this static, and the reason I'm changing this into a static constructor is so that I'm always working with the same list throughout the life of the application no matter what happens. I'll always be working with the same list of restaurants. And that sort of simulates a database. It just doesn't handle concurrent users. Let's save everything and refresh this form to make sure we have the latest bits. And you'll see that I've run into an exception. The exception in this case is because ASP.NET MVC sees that I'm trying to get to /home/create, but it sees two actions that match that name. And it cannot differentiate between the two. To me the developer, I know that this one is supposed to give you the form for editing a restaurant, and this one is supposed to receive the form that is editing a restaurant. But the MVC framework doesn't know that. The way I can tell the MVC framework about those intentions is to say that this action method should only respond to an HTTP GET request, and this version of the action should only respond to an HTTP POST request. Those are two different methods, and a GET is usually used to read information, while a POST is used to create or update information. And I only want to use a POST when I'm modifying state on a server. So with those changes, let's save the controller and refresh the page. Here is my form. Let me enter in the name of a new restaurant. We will make this an Italian restaurant, click Save, and here I can see that the response from the HTTP POST version of the Create action is to show the Details view, which does show me that this restaurant does have an Id of 4 and the cuisine is Italian. That looks like everything is working. But there're a few things that we can do to improve this experience. And we'll look at some of those details in the next clip.

POST Redirect GET Pattern

At this point, I want to introduce you to or remind you of the POST-REDIRECT-GET Pattern for web applications. Currently, our client, the browser, has a form that will use an HTTP POST method to send new restaurant data to the server. And currently our server responds immediately with the details of the new restaurant. But responding to a POST operation with an HTML page can cause troubles because if the user decides to refresh the browser, the browser will need to send another HTTP POST message which will try to add the restaurant to the data store again. It is a common practice in web applications that when you have a successful POST operation, you respond to the post with an HTTP REDIRECT status code and tell the browser to send a GET request to read the new data from somewhere else. Remember, POST is for write operations, and GET is for read operations. By ultimately delivering a page for reading, the user can bookmark and refresh the browser at any time without trying to write new data. Let's see how easy it is to follow this pattern in our application. Inside the browser, we are looking at the Details view that was rendered as the result of a successful POST operation, which can be dangerous. And even the browser understands that this can be dangerous. If I try to refresh this page, I will get a warning message that I'm about to resubmit a form, and this might cause any action that I took to be repeated. So refreshing the results of a POST operation can lead to duplicate restaurants, duplicate transactions, charging my credit card twice, and it is generally a situation that we want to avoid. And fortunately it is very easy. Instead of responding immediately with the Details view, it would be better to send back a REDIRECT response and tell the user to go to some other URL and issue a GET request, and from there, the user the can view the details of a restaurant. And this is as easy as this. Instead of returning a view, let's return a RedirectToAction result. I want to go to the Details action. And now instead of passing the restaurant along, remember this is sending a response back to the client, and I need to send a response back that will include enough information for the browser to issue a GET request to the correct Details URL, and that means it needs to include the restaurant Id. So just like when we used the HTML helper to build an anchor tag that included the Id of a restaurant, this RedirectToAction method includes a parameter where you can pass in routeValues. And there's also overloads of this RedirectToAction method that would allow you to redirect to a completely different controller. But we want to go to the Details action on the same controller. We need to pass along some routeValues. So, once again, I just need an object that has properties that represent the state that I want included in this redirect. So I need the Id included. And I will say that the Id should equal the Id of the new restaurant we just created. And I can add as many properties as I want to this anonymous type. All the property values will be bundled up somewhere. My routing rules allow for an Id parameter in the URL. So the Id can go into the URL, and we'll have something like /home/details/4. But if a parameter doesn't fit into the URL, MVC will place that parameter into the query string. So I can get as many parameters as I want, and all I need to do now is change my return type. Let's go with IActionResult instead of a Redirect result because, as we'll see, there's some more work to do inside of this method. But now let me come out, and let's go back to the form where we can create a restaurant. And I'll refresh this form just so we can start with a blank form. And let me use the name Airport Inn. We'll have an Italian cuisine. Click Save. And now you'll notice even the URL in the browser changed. I am not at /home/details/4. And since this was a GET request, I can refresh this page as many times as I want. There's no warning from the browser. There's no chance of trying to create that restaurant again. And this is generally the approach you should use when you have a successful POST operation. But what if the POST operation is not successful? What if the user didn't send correct information to create a new restaurant? And how could we even check to see if all the information we need is there? Let's talk about that next.

Model Validation with Data Annotations

When the user creates a new restaurant, there are some rules we want to apply to the data that they gives us. For instance, we want the restaurant name to be a required field. One of the easiest techniques for enforcing rules like this is to use data annotations that are available in .NET. Annotations are annotations like MinLength and MaxLength, which require a string input to be a certain minimum or maximum size. We can also check the range of a number, match a string against a regular expression, or compare two model values using the Compare annotation. Some data annotations also influence the display of a model value or the label for a model value. These are annotations like Display and DataType. If I tell the MVC framework that a given model value will hold an email address, the HTML helper I use to render the input will render an input element where the type attribute is set to email. And on some devices, this will give the user a different type of input or a different keyboard to enter the values into that input. Let's add some annotations in our project. Let's add some annotations and enforce model validation in our project. To see how we can use data annotations, let's first go back to the view that we used to create a restaurant. And I'm going to refresh so we have an empty form. And I want to inspect the HTML that is on this page. And the first thing I will call your attention to is the label. The label is telling the user that this is where they input the name of a restaurant. And that comes from our Create view that's using an HTML helper LabelFor. Now, remember, LabelFor works against the model type. It retrieves information about the model and specifically about the property that I identify here and uses that information to create the output. And the model that we are using in the Create view is our Restaurant entity. So if I want to influence what LabelFor is doing, I need to add my data annotations to this Restaurant Entity. Right now when I say I want a label for the Name property, really the only information that LabelFor has to work with is the name of this property, which is Name, and its type, which is string. The whole idea behind data annotations is that I can add additional metadata here that HTML helpers can use to build the HTML. So what is a data annotation? Well, for starters, most data annotations are in the System.ComponentModel.DataAnnotations namespace. And this namespace contains more than a dozen attributes that I can apply to models and model properties to provide additional metadata. For example, there is a Display annotation and a DisplayFormat annotation. DisplayFormat is something where I can pass along a formatting string. That's very helpful when I'm working with numeric types or DateTimes because I can tell these HTML helpers how to format that particular value in a specific way. Do I want digits after the decimal? Or for DateTime, do I want to display just the month or the year or just the time information? And let me show you in the Display attribute, I can set properties like the actual name to use in the UI when you refer to this property. So we could say this should be Restaurant Name. And now if I save Restaurant.cs and refresh my form, I will see instead of just displaying Name here, we now display Restaurant Name. So by default, a lot of these HTML helpers will just try to derive some piece of the UI from the property name, but we don't always have C# properties that map well to make a pleasant user interface. We don't put spaces in property names, and we don't use punctuation. But we can do that with the Display annotation. So some of the data annotations are all about presenting things on the screen. Other annotations are used to enforce validation. These are annotations like Required saying that Name is a required field. And you can inside of the square brackets include multiple annotations if you want. Or you could put each annotation on a separate line. It really depends on your sense of style. But let's say that a restaurant name is required, that's its MaxLength is 80 characters. And let me show you one more attribute. I'm going to say temporarily that the DataType of this is DataType.Password. Notice there's a number of different DataTypes to choose from. And these for the most part really just influence the type of input that is rendered. For instance, if I say this DataType.EmailAddress, I can have an HTML helper that renders an input type = email. Let's temporarily choose Password. And in order for this to work, I do need to make one more change in the view. When I use the HTML helper TextBoxFor, I'm explicitly telling the framework I want an input type = text. And in that case, my HTML helper is going to ignore some of the data annotations that I have placed on that property. There's a more generic HTML helper called EditorFor, which uses pretty much the exact same syntax. But now what I'm asking the framework is, Give me an editor, give me the best editor based on the information you have available. I'm not forcing you to use input type = text. You choose what is best. And now if I save my Create view, save all the files, and refresh my form, I'm going to see that my input has changed dramatically. For right now, I just want to call your attention to the type. The type is password. That means if I type in here, the browser knows now to display the characters that I'm typing into that input, which isn't what we want for the restaurant name. So I'm going to remove that particular data annotation. But you'll notice there're a lot of other attributes now in my input. Some of these attributes seem to be implying that the maximum length of this input is 80 characters. These particular attributes, like data-val-maxlength-max, these are used to enforce client validation rules. We're not using the built-in HTML5 attributes. What we will need to do to enforce client-side validation is add some JavaScript libraries to the page, some JavaScript libraries that will detect these attributes and enforce these rules (we'll come to that in the last module of this course) because it doesn't matter if we have client-side validation, we also need to have server-side validation. That's the most important piece because anyone can circumvent client-side validation, so how can I make sure that when the user saves this form, the restaurant name is, in fact, populated? Well that's when I have to think not about the model that was used to create this view, but about the model that receives information from this view because inside of a controller action, I can ask the MVC framework if a particular view model or model or input model, whatever you want to call it, if it is valid or not. So these data annotations, not only can they help you generate HTML in the view, but they can also be used to enforce some validation rules when you are inside of a controller action that's receiving model data. Anytime you have a parameter to an action method, think of that parameter as a model, and the MVC framework does something it calls model binding to move information from the request into that model. And then the framework will also run any validation rules that the data annotations specify. Let's see if we can get this to work. First, I want to come back to my restaurant, and I'm going to remove DataType.Password. But I am going to copy the Required and MaxLength attributes. Let's save restaurant, and I can close that class. Now I will open up RestaurantEditViewModel. And here on the name attribute, I will add Required and MaxLength and also make sure to bring in the correct namespace for these data annotations. And now all I need to do inside of a controller action method is before I go about saving this new restaurant information, I want to check if this model is valid. Well when you derive from the base controller class in MVC, your controller will have a property that you inherit called ModelState. And this property, which is a ModelState dictionary, gives you the ability to add new model errors. So perhaps you want to write some validation code right here in the action method. You can also poke around inside of ModelState and look at specific fields that you've received from the user to see if they're valid or what error message is associated with the particular property. But commonly what we always need to do is just check the IsValid property. So if ModelState is valid, then I know that my model has passed the validation rules. And if it has passed all my validation rules, only then do I want to save the new restaurant and then try to redirect the user back to see the details of the restaurant. Otherwise, what should I do? Well if the user has given me invalid data, I typically just want to re-render the form so that the user can try again. But I will also want to display error messages to the user so they know what they did wrong. And the error messages I can add with some additional HTML helpers. So typically for every editor, you have a Label, an Editor, and then a ValidationMessage that is associated with that particular model property. So this is telling the MVC framework if there're any validation messages that were generated for the Name property, show them here inside this div. And I should also add that ValidationMessage for the cuisine in case something went wrong here. And there's also an HTML helper validation summary that you can use to group all the error messages if you want into a single location. With this UI, we will display the validation messages right alongside the input. And now let's save everything, come back to our browser. I'm going to turn off the inspector for now. Let's refresh this form to get a fresh form and try to save a restaurant with no name. And what our controller has done is it has detected that ModelState is not valid. And it has re-rendered this view so that the user is again presented with the form information. But this time, there've been some validation messages associated with some of the inputs. So we are displaying them too. And hopefully this gives you an idea of how data annotations, HTML helpers, and ModelState can all work together. You can use the built-in data annotations. You can also implement custom data annotations. And that's one way to automatically enforce some validation rules on your model objects. And it's also a way to influence the display of the values that are in your model objects. And then inside of the controller actions that receive the information from a form, you always want to check if ModelState is valid before you accept that input and try to save it somewhere.

Summary

In this module, we made a distinction between entities and models. And I gave some examples of different types of models--input models and output models. We saw how to use data annotations to influence the labels and inputs created from models by HTML helpers. And we saw how HTML helpers work with forms and controllers and validation rules to produce ModelState and validation messages. In a controller, you always want to check ModelState that is valid to make sure an input model is properly populated. And if that test fails, you typically re-render the view that displays the input form to the user so they can fix any validation problems and resubmit the form. Later in the course, we'll get the client-side validation working too.

Using the Entity Framework

Introduction

Hi! This is Scott, and in this module, we're going to set up and configure our application to save and read data from a SQL Server database. To work with a database, we're going to use the Entity Framework, which is freshly rewritten to work with the new .NET Framework, although if you have worked with EF in the past, you'll see many familiar pieces. To get started, let's first talk about your SQL Server installation.

SQL Server LocalDB

In my application, I'm going to use SQL Server LocalDB. If you aren't comfortable with SQL Server, you can use any database that you like. Local databases, remote database, as long as you have permission to create a new database on the instance, you should be just fine. But I'll be using LocalDB. This is a special edition of SQL Server that is optimized for developers. Visual Studio 2015, even the Community edition, which is the edition I'm using, the setup program for Visual Studio will install LocalDB by default. You can also install some additional useful tools by making sure the Microsoft SQL Server Data Tools option is checked when you install Visual Studio. If you're not sure, you can always run the installer again. It gives you the ability to modify an existing installation. I just want to start the module by showing you some tips on how to verify the LocalDB installation, as well as how to connect to LocalDB using some tools you might find useful. One of the easiest ways to verify that you have a LocalDB installed is to use a very simple command line tool. To run this tool, I have to open a specific command prompt, so I'm going to go into Windows and search for Developer because one of the best matches that should appear for that search string is the Developer Command Prompt for Visual Studio 2015. This is a command prompt that Visual Studio configures when it installs. And the installation sets up the path so that you can reach all of the developer command line tools. The tool that I want to execute is sqllocaldb. If I run this command with the info argument and it doesn't produce an error, it gives me some output, I can be pretty sure that LocalDB is installed and correctly configured for me to use. I can see here I have two LocalDB instances. The one I'm going to be using is MSSQLLocalDB. And I can even get additional information about that instance if I run sqllocaldb info and then the name of the instance, so mssqllocaldb. This will tell me this is a version 12 instance, which is essentially SQL Server 2014. Now I'm going to leave this developer command prompt open because we'll come back and use it a little bit later. The other tool I want to show you is under the View menu, if you install the SQL Server Data Tools, you should be able to get to an option, the SQL Server Object Explorer. This is a really great tool if you have to work with SQL Server because it allows you to explore databases and browse data and even create data inside of a database. When you first open it, it might take a little bit of time, but it should connect to LocalDB for you automatically. And from here, I can do things like browse the available databases. Ultimately, this is the instance that I want to hold data for the OdeToFood application So eventually I'm hoping that an OdeToFood database will appear here. Right now there's nothing else here except for some default things that get installed. And I will show you that if you right-click on the server and go to Properties, you can see in this Properties window a connection string for this database. Connection strings are important. We will have to add a connection string to our application so that it can get to the correct database. But right here is the connection string. I could take this value and copy it out of here and use that in other tools or applications to make a connection to SQL Server. The most important part here is the data source. SQL Server LocalDB uses a special connection string. When I specify the data source, which is essentially the server and instance that I'm trying to reach, I use LocalDB inside of parentheses and then slash, the instance name, which in this case I do want to use that MSSQLLocalDB instance. So now that I've verified that I do have a LocalDB and it appears to be in working order, let's get the Entity Framework up and running.

Installing the Entity Framework

The first step in using this version of the Entity Framework is to install the Entity Framework NuGet package. I can do that using the UI in Visual Studio or by editing the project.json file directly. We've used both approaches in this course, and this time I will edit the project.json file directly because there're actually a few changes that I want to make here. The first change is to add new dependencies. I need to take a dependency on EntityFramework.MicrosoftSqlServer. And I'll use the latest available version, which is version 7-rc1. And there's one more package I want to grab, and that is EntityFramework.Commands. I'll also use rc1 for this. The command package is here because there are some tasks that I want to perform with the Entity Framework, tasks like creating a database schema based on my C# Entity classes. And these tasks are available from a command line tool where the logic lives inside of the EntityFramework.Commands package. In order to use this command line tool, I need to make an additional entry into this commands section of project.json. We haven't talked about the commands section. But later in this module, I will show you how these commands, like web, these are simple names that you can use from the .NET command line tool. The web command specifically, it exists as a command that I can use to run my web application from the command line using a web server named Kestrel. Kestrel is a cross-platform server, so it works outside of Windows. And it's also a server I could use if I didn't want to use IIS. In fact, even when I use IIS, it's really Kestrel that is serving up my ASP.NET application. I want an additional entry here, I'll just call it ef, that will map to this EntityFramework.Commands package. And I'll be able to use this friendly name, ef, to get access to some of the logic that is available inside of EntityFramework.Commands, logic that can give me database migrations and create my database and update my database to the latest schema. Again, more on that later in the module. For right now, we've made all the project.json modifications that we need to get started and use the Entity Framework. All I need to do is save this file. Visual Studio will add those new dependencies to the project. And in the next clip, we'll write a DBContext.

Implementing a DbContext

To use the Entity Framework, you need to create a class that derives from the Entity Framework's DBContext base class. Each DBContext class that you write will give you access to a single database. And I don't mean physical databases. You can always change connection strings so that a single DBContext class can point to many different physical databases. But logically, a DBContext maps to a specific database that has a schema that the DBContext understands. And on that DBContext class, you can create properties that are type DbSet of T. The generic type parameter T will be a type of entity like restaurant is an entity in the OdeToFood application. So if I want an OdeToFood database, I'll create an OdeToFood DBContext class and implement a DbSet of restaurant on that class. Each DbSet will map to a table in the database. So if I have a property DbSet of restaurant, and the name of that property is Restaurants, the Entity Framework will by default look for a restaurant's table inside of my database. Now there's lots of mapping and configuration that you can do to override some of these defaults. We won't need to do any of that in this application. But let's dive in and see how this works. In the application, I need a class that derives from DBContext, and I think I will put that class here in the Entities folder. Even though this class is not an entity itself, it does put together all my entities so that I can use them with the database. In larger projects, some people put their DBContext and all their entities into a separate project. But we'll keep things here. I want this class to be called the OdeToFoodDbContext. And the implementation is very simple because we only have a single entity to work with. But this is a class that derives from DbContext. I need to bring in the namespace, which is Microsoft.Data.Entity. And now I can create a DbSet property for each of my entities. Since I only have a single entity, that means I only need one property, DbSet of Restaurant. We can name this property Restaurants, and this is the only code I need so far. I'm going to remove the unnecessary usings and save this file. And now the question is, How will I use this class? Well, I could set things up to inject this class directly into controllers, and the controllers could then use OdeToFoodDbContext to query the database, but we already have a bit of an abstraction to work with, and that is the IRestaurantData interface. I want controllers to continue to program against this interface, and I want to provide a new implementation that instead of storing restaurants in a list will store and query restaurants from this new DBContext derived class. Once again, I'm going to put that class in this same file. This is something I'd never do in a real application. I'm only doing this during the video so that we don't have to flip through as many files. But I should have a file for IRestaurantData, a file for InMemoryRestaurantData, and now I want to create a class. Let's call it SqlRestaurantData. It will also implement IRestaurantData. And we'll see that the implementation is actually very close to InMemoryRestaurantData. It will be using the same LINQ queries. This class will need a constructor, a constructor that will take my OdeToFoodDbContext, and I'll call that the context. I could also call it something like db. And I want to save that context into a private field that I'll generate, so Ctrl+period(.), on _context, it doesn't exist yet. I'll tell Visual Studio to generate that field. And now we just need implementations of IRestaurantData members. So Ctrl+Period(.) on IRestaurantData, tell Visual Studio to implement this interface. This will give me all the methods I need and save me some typing. So what do we do when we add a new restaurant? In that scenario, I just need to walk out to the context and tell it to add this new restaurant. The context is smart enough to say, Oh, that's a restaurant. I know where that goes. But I also need to tell the context to save changes. And where you place the call to save changes, actually, that really depends on the application you're building. I'm going to build something where as soon as you tell the SqlRestaurantData object to add a new restaurant, it's going to use the DBContext to issue an insert statement and immediately finish up that transaction. If you needed the ability to add two or three restaurants in a single transaction or add a restaurant and then some customer objects in the same transaction, you'd probably have to pull SaveChanges out of this method and make it another member on the interface IRestaurantData so that SaveChanges can be called explicitly from the application code. But we don't need anything quite so complicated. I also need the ability to get a restaurant by Id. That's as simple as walking up to the context, going to my Restaurants DbSet, and asking for the FirstOrDefault where given a restaurant r, r.Id = this incoming Id. And one other note about Add--in the InMemoryRestaurantData implementation of Add, we needed to generate a new unique Id. We're sort of simulating that here. But that's something that SQL Server and the Entity Framework will take care of for me when I save changes. We'll see how it treats the Id property of a restaurant as the primary key. And the Entity Framework will mark that Id property as an identity column, which means SQL Server is responsible for generating the Id. And after I call SaveChanges, the Entity Framework will be bring back that new Id and set it on my restaurant. So we will have the proper Id for our restaurant. And now when we get a restaurant by Id, we just need to return the results of that query. And here when I call GetAll, I can simply return context.Restaurants because a DbSet of T implements IEnumerable of T. I could also force that query to execute right away by using a ToList here. Of course, that's not something you'd want to do against a large database table. You would want to leave ToList off because presumably the application will use things like skip and take to apply paging to a large data table. But this should be everything that we need for the controllers to ultimately query the database. The question is, How do we get a SqlRestaurantData into a controller? And how does our OdeToFoodDbContext get configured with the right connection string and then injected into SqlRestaurantData? We'll do all this in the next clip.

Configuring the Entity Framework Services

To have a usable Entity Framework DBContext, I need to change the configuration of the application. I'll need to add a connection string so my DBContext knows what server to go to and which database to query. Since connection strings change all the time, we'll put the connection string in a JSON configuration file. I also need to add some more services during the ConfigureServices method of the Startup class. The Entity Framework, just like ASP.NET and the MVC framework, the Entity Framework relies on dependency injection, and for injection to work, the runtime needs to know about the various services that the Entity Framework uses. Fortunately, there is an easy configuration API that will add all the default services that I need. Let's take a look. Let's swing over into our Startup class where I need to add some additional services for the Entity Framework to work properly. Specifically, there're three things here that I need to do that are related to the Entity Framework. I need to add the core Entity Framework services. I also need to add the SQL Server-related Entity Framework services. And I need to tell the Entity Framework about my DBContext. All of this can be done through methods that are available as extension methods on IServiceCollection. And the first method is AddEntityFramework. This will add the core Entity Framework services, the default services. But since the Entity Framework is now designed to work with different sorts of databases, including non-relational databases, I need to make a second call to tell the Entity Framework to add its default SQL Server-related services. And then I also need to tell the Entity Framework about my DBContext class so it can construct instances of that class appropriately. I do that through a third method, AddDbContext. This one takes a generic type parameter where I specify the type of my DBContext derived class, so that is OdeToFoodDbContext. I will need to bring in the namespace here, OdeToFood.Entities, for this to work. And then inside of AddDbContext, I need to describe some options for my DBContext. This can be done by passing in a delegate, so I could use a named method, but I can also use a lambda expression. It is an action where I receive an options parameter. And, again, since the Entity Framework can support different databases, I need to tell the Entity Framework that this particular DBContext is going to UseSqlServer. Now this method is a method that is available in a different namespace. It's an extension method. I have to bring in the namespace Microsoft.Data.Entity. I'll do that with Ctrl+Period(.) and UseSqlServer. This method requires a parameter which is the connectionString to use. What server and what database will this OdeToFoodDbContext work against? And as I said previously, we like to keep connection strings in a configuration file or at least have a configurable connection string. There're many ways to do this so that you don't have it in a configuration file that gets checked in the source control. But our connection string will not have a password. So it is not a huge concern. And I'm going to set up the connection string like this. I'm going to have a member on my configuration called database because there might be multiple options that I need to specify for a database. And I'm going to have a member here called connection. And I need to use a connection string like we saw in SQL Server Object Explorer earlier. I'm going to say that the DataSource=(localdb)\\mssqllocaldb, and then a semicolon so that tells it what server and what instance to connect to. And then I have to specify the database or the Initial Catalog. I want this to work against a database called OdeToFood. And this is all I need in my connection string. By default the Entity Framework will just be using my identity to connect to the LocalDB. And as long as I have permissions in the LocalDB, I should be fine. So now how do we pull this connection string out to use inside of Startup.cs? First, let me try to get this code to fit on the screen without horizontal scrolling. And you'll remember earlier in the course, we set up this Configuration property on our Startup class. It's of type IConfiguration. And currently the only configuration source is that appsettings.json file that I just modified. But you can add additional configuration sources. I need to pull the connection string out of that configuration source. And I can do that by indexing into an IConfiguration. Since I created a complex object in that JSON file, I need to say, I need something from the database object, specifically the connection property. Bring that back as a string. And I should now have everything that I need for the Entity Framework to work properly. I've added the core services. I've added the services to talk to SQL Server. I've told the Entity Framework about my DBContext and the connection string that it uses when that context comes to life. The last change I'm going to make inside of ConfigureServices is that instead of using InMemoryRestaurantData, now I want the application to use SqlRestaurantData, which uses that DBContext class. So now all of my operations should be going against the database, but I don't have a database as yet. Let's use some of those Entity Framework commands that we talked about earlier to create the database and put the proper schema inside.

Entity Framework Migrations

One way to get a database set up is to use the Entity Framework to create the database. This is a two-step process. The first step is adding migration code to my project. Migration code is C# code I can execute to create a database in a database schema. The Entity Framework can actually generate this migration code for me. What it can do is look at the database and look at my entities and figure out what schema changes are require to make the application work. So as I add additional entities or make changes to existing entities, like the Restaurant class, I can continue to add migrations to my project and keep my database schema in sync. I also need to explicitly apply those migrations to update a database. I do this once the migration code is in my project. And both of these tasks can be achieved by using some easy commands from a console window. This is where we circle back to the change we made in project.json to add a command where ef maps to EntityFramework.Commands. I will tell you now that I know the syntax of these commands will change at some point in the future. So watch for updates to this module. Let me show you how this currently works. Let's go back to the command prompt that we opened earlier to run the commands that we need to add the migrations and apply the migrations. And the easiest way to do this is to go to the directory where the application lives, the root of the project. For me, that is under \OdeToFood\src\ and the OdeToFood again is the root of the project. If you're in the folder that has the project.json file, then you're in the correct folder. You're in the root of the project. And from here things might get slightly tricky because as I'm recording this, the command that I want to use is dnx, but in the future this command will be dotnet. But chances are if all you've done is install Visual Studio 2015, you won't be able to execute either of those commands just yet. Before I can execute one of those commands, I have to use something known as dnvm. This is the .NET version manager. What I need to do is use dnvm and tell the system what runtime I want to use because if I do a dnvm list, chances are you will have multiple runtimes installed on your computer. I have some beta8 runtimes for the core CLR and the full CLR. And I also have my rc1 runtime. What I need to do is tell dnvm that I want to use one of these specific runtimes, and that will give me access to the dotnet command or the dnx command that I want to execute. So if I dnvm use1.0.0-rc1-update1, and I include a -p, then I won't have to execute this command again unless I want to change the runtime that I'm using because what dnvm will do is set up my path and the environment variables to include a bin directory that will give me access to this dnx utility. And, again, if you're watching this in the future and I haven't updated this video as yet, the plan is to use a command dotnet. I'll be using dnx. This is the .NET execution environment. Using dnx, I can call into commands that I have listed in my project.json file. Specifically, I want the ef command. And you'll see once you have everything set up, you have a runtime selected, you know you're using dnx or dotnet, executing these commands is generally very easy because if you just type dnx ef, you'll get a help screen. You don't have to remember all the options. When I type dnx ef, I can see the available commands from Entity Framework Commands. There're three of them. There's database, dbcontext, and migrations. I know I need to add a migration, so let's see what happens when I type dnx ef migrations. Again, I will get a help screen. I can see I can add, list, remove, or script in migrations. It sounds like what I want to do is add a migration. So if I run that command, I'll see that I have to give my migration a name. So let's try this one more time. I will type dnx ef migrations add v1. And because I only have a single DBContext instance out of my application, the Entity Framework will go out and will find that context and will look at the entities that are inside. It will know that there's no previous migration. And so it's going to generate the first migration. I call it v1 for version 1 of the database. Where does it generate this code? This code will live by default in a Migrations folder. You can change the output destination with another command line argument to the migrations add command. But I'll use the default. And let's open up a migration to see what it looks like. A migration is essentially C# code that will be used to generate SQL commands to modify the schema in a SQL database. I can see something is going to create a table called Restaurant. This table should have three columns--an Id, a Cuisine, and a Name column. And by convention, when the Entity Framework sees that you have a property called Id, it will make that property or, rather, make that column a primary key in the database. And because we're using SQL Server, again by default the Entity Framework will make that an IdentityColumn, which means SQL Server will generate the Id's for me. So my migration is in place. Now let's see how we can apply this to a database. Let's type dnx ef again. I can see one of the other available commands here is database. And if I do a dnx ef database, I can see the only command available here is update. So what I want to do is a dnx ef database update. Well when I do this, I'm going to create an error because I left a small problem in my connection string earlier. I did this to demonstrate something that surprised and mystified me when I first started working with this technology. It's not immediately obvious, but what this command is going to be doing is actually going out to my OdeToFood application and executing code inside of the Startup class to figure out the connection string that I want to use. What database do I want to update? By default, this command will execute the Startup code to see how I've configured the DBContext. Remember I said that the DBContext should be using this connection string that is in my configuration file. And what this error is indicating is that I left a space out of that connection string. It should be Data (space) Source. So now you know when you run into a problem applying a migration that it might actually be a problem with the configuration in your application. I found that surprising. Let's go into the appsettings file and make a change so that we have a proper connection string. I'll specify Data (space) Source, and I'm also going to open up the SQL Server Object Explorer. You'll see inside of here currently I have no OdeToFood database. But with my fixed connection string, let's again try dnx ef database update. And after a short pause, hopefully I will see a success message. And here I can see that that command has applied the migration. If I swing back into SQL Server Object Explorer, let's refresh the databases, I can see now I have an OdeToFood database. I can drill into the tables for that database. And here I can see my Restaurant table. I can even look at the columns for that table and see that I have my primary key Id column. Here's my Name column. Notice it's an nvarchar(80). How did the migrations know to make this column an nvarchar(80)? Well it turns out the Entity Framework also respects these data annotation attributes. So when it sees the annotation that says a name should only be 80 characters, that fact will be reflected in my schema also. So now I'm pretty sure I have a working DBContext, I have a working SQL Server database. In the next clip, let's give this a try with the application.

Up and Running

Before we run the application since I have this window open, let me right-click on the Restaurant table and select the View Data option. In addition to viewing data, I can also edit data through this window once it appears in Visual Studio because it would be nice when I launch the application to see some data from the database. All I need is the window to appear in Visual Studio. There we go. And let me just add a couple rows of data here. Now the Cuisine column is a numeric column. I need to store the integer equivalent of my enum value where 0 is none, and then I believe we have Italian, French, and American. So let me enter LJ's and the Kat, and let me also enter Tersiguel's. Notice how SQL Server generated the Id's for me. And now run the application, Ctrl+F5 to run without the debugger, and the home page for my application displays the two restaurants in the database. Let's also try to create a restaurant. Currently, I don't have a link to the create form that we added to the application. We will add that link in the next module using a new feature of ASP.NET MVC that we haven't talked about yet. For now I'll just manually go to /home/create, and let's enter King's Contrivance, a cuisine of American, which I'm sure some people find funny. Try to save this. I properly go to the Details screen with the new Id for the restaurant. That looks good. And if I come home, it appears as it everything is working properly. Let's just refresh our table to make sure we see the data in the SQL Server database, and it does appear as if everything's working for us properly.

Summary

In this module, we saw how to work with the database using the Entity Framework. We installed the Entity Framework NuGet package, specifically the package allowing ef to work with Microsoft SQL Server. Then we wrote a class derived from DBContext. Once we configured the Entity Framework and the DBContext into our application services, we created migrations and then applied those migrations to create a database. Then our application was off and running with SQL Server. Now let's turn our attention back to ASP.NET MVC and work with some more features of the Razor view engine.

Razor Views

Introduction

Hi! This is Scott, and in this module we will be focused on features of the Razor view engine. Although we've already been using Razor to render HTML with our model data sprinkled inside, we can make some improvements to the application by using some features we have not looked at yet and some features that are brand new for this version of MVC. The first feature we will look at is a feature to give us a more consistent structure across the application. And this feature is the Layout view feature.

Layout Views

Most websites and web applications will want to create pages that present some common elements. You typically have a top area on every page where you display a logo and a navigational menu. Then you might also have a sidebar with additional links and information and probably a footer at the bottom of the page with some small print. Every page of the application will want to have these common pieces, but we don't want to duplicate these pieces in every view that we write. This is where Layout views are helpful. A Layout view is a Razor view with a .cshtml extension, and you can name a Layout view whatever you like. I'll be using a Layout view with a name of _Layout.cshtml. This is a common name for a Layout view, and the leading underscore isn't required. Again, that is just a convention that many developers follow to identify a view that is not a view that you render as a view result from a controller action. Instead, it's a special kind of view. But once we have a Layout view, we can set up our controller views like the Index view for the home page. We can set up this view to render inside of the Layout view at a specific location. This Layout view approach means Index.cshtml doesn't need to know anything about the logo or the top level navigation. The Index view only needs to render the specific content for the model the controller action gives this view. And the Layout view takes care of everything else. Now, of course, we'll try it out. Inside of the application, we have three views that are rendered by the HomeController, so they are in the Home folder. And they all contain some amount of duplicate markup. They all have an opening HTML tag and a head tag and a body tag. And even though we don't have a navigational menu in this application, chances are in a real application I would want to have one. And I don't want to duplicate that markup in every view. I would want to create a Layout view. And I will add the Layout view to a new folder named Shared. This is a conventional folder that the MVC framework knows about. It knows that views inside of here might be used by multiple controllers across the application. It's inside of here where I want to add an MVC View Layout Page. The default name here is _Layout.cshtml. But you can name a Layout view whatever you want. You can even have multiple different Layout views and choose the Layout view that you want to use at runtime depending on the user or the season. We'll see how to select the Layout view in just a bit. I'll go ahead and click Add, and this is what I will get by default for my new Layout view. I do want the Layout view to be responsible for managing the head and the body. And it is a Razor view, so I can still use C# expressions inside of here. I can still add literal text. So may a div that displays DateTime.Now. And let's just use Year. And then you'll notice two other expressions inside of here. Let's talk about RenderBody first. When an MVC controller action says, I want to render the Index view, and there's a layout page involved, the Index view, the HTML it produces will be placed here where the method call to RenderBody exists. So I can expect all of the content views throughout my application to appear inside of this div where RenderBody is called. The other expression inside of this file is ViewBag.Title. So, first, I'll explain ViewBag. This is a data structure that you can add any property and any data that you want to into the ViewBag. So I could add a ViewBag.Title. I could add a ViewBag.CurrentDate. I could have any properties that I want on the ViewBag--we'll see how to set one in just a moment--because the expectation is that individual views like Index.cshtml and Details.cshtml, they will set a title property on the ViewBag. And this is because the Layout view is responsible for rendering this title tag. But since the Layout view is going to present multiple different content views, it doesn't know what the title should be. And what the ViewBag allows me to do is pass along some information from my content view like Index.cshtml, pass that information along into the Layout view so my title element has the proper text inside of it. And there's one more expression that I'll show you that is quite commonly used inside of a Layout view. And let's actually create a footer element here at the bottom of the page. And that is RenderSection. RenderSection is useful when a content view like Index.cshtml might need to output markup into different places in the Layout view. So by default everything that Index.cshtml produces will go where RenderBody appears. But from Index.cshtml, I can also have named sections, and Index.cshtml has the ability to say, This chunk of HTML I want to render into the section called footer, and it's up to the Layout view to place that into the page at the correct location. So with my call to RenderSection, if a specific view says I want to render a footer section, it will go down here at the bottom of the page inside of a footer element. And notice the second parameter to RenderSection is a required flat. By default, this section is required, meaning every view I create will need to render a footer section. If I want this to be optional, I can pass in a false flag. And if that view doesn't have a section, then we won't have anything inside of our footer element. Now let me save Layout.cshtml and see how we can get this working in our Index view. The first thing I'll do is remove the markup that we no longer need inside of the Index view. So I can remove things like the HTML tag and the head tag. We'll have to come back and remember to set the title later though. We do that with a ViewBag. I also don't need the opening body element or the closing tags down here. And now if I hit Ctrl+K, Ctrl+D in Visual Studio, that will apply some formatting and get rid of the indentations that I don't need. And now I am down to the essence. I am only rendering from Index.cshtml, that content that is specific to the home page. But I still need to do two things. I need to tell the MVC framework that I want to use that Layout view from this view, and I need to set the appropriate title by adding some information into the ViewBag. And I will do both of these things by creating a block of C# code. So when I just use an expression like @restaurant.Name, the Razor view engine knows that I have this little C# expression that should be evaluated, and the result of that expression should just be placed into the HTML. But when I start using curly braces like this, now I have a block of C# code. It's not going to output anything into my page, but it does give me the ability to execute code and change my environment and give the view engine some instructions. So, for example, one thing I can do is tell the ViewBag that it should have a new title property, and that title should be Home. And when I'm inside of a block of code like this, the normal C# rules apply. So I have to start using semicolons in the appropriate location. The other thing I can do is tell the MVC framework about the Layout view that I want to use. So Layout and ViewBag, those are both properties that I inherit when I'm inside of a Razor view. And I need to explicitly set the layout that I'm going to use. And unlike other view conventions, I need to provide an explicit path to the Layout view. So I'm going to use a tilde. That tells the framework to go to the root of the project, then go into the Views folder, then go to the Shared folder, and then use the file _Layout.cshtml. So, obviously, this is a place where you could apply some logic and perhaps dynamically determine which Layout view that you want to use. But we're always just going to use this one. And now if I save everything, let's come out and refresh our home page. And it's still going to appear mostly the same. We did add one feature, which is to display the year. But now using the Layout view, I don't have as much duplicated HTML throughout my application. And I can easily manage an element that has to appear everywhere like a navigational menu. Let's go back to the Layout view and remove this DateTime.Now.Year. That was just a test to make sure we were using the Layout view. And let's also render a footer section from Index.cshtml. So let's say instead of displaying this current greeting at the very top, maybe that's something that should appear at the bottom of the page inside of the footer. The way to do this is to use an @section directive. I give this section a name, so I'm telling Razor that I want to render the following inside of the foot section. And it's almost like writing a block of code because everything inside of these curly braces will go into that section. And instead of an h3, let's just make this a normal div. Let's see if the current greeting appears in the right location, and it does. And so now that we have a Layout view in place and we know it's working, the next goal would be to fix up the Details view and the Create view that we have to also use this Layout view. But before we do that, let me show you a way that you can avoid specifying the Layout view inside of every single content view.

_ViewStart

The Razor view engine in MVC has a convention where it will look for any file with the name _ViewStart.cshtml and execute the code inside of this file before executing the code inside of an individual view. The code inside of a ViewStart file cannot render into the HTML output of a page, but it can be used to remove duplicate code from the code blocks inside of the individual views. In our example, if we want every view to use the Layout view that we just created, we could put the code to set the Layout view inside a ViewStart instead of having the code inside of every view. Let's see how this works. In the application, I don't want every view to have to specify that its Layout view is Layout.cshtml, so I'm going to cut this line of code out of my Index view, and I'm going to execute that line of code from a ViewStart file instead. If I right-click on the Views folder, which I'll talk about while we're adding this to the Views folder directly in just a minute, there is a specific template in ASP.NET MVC for a ViewStart page. And really the most important part here is that this file is named _ViewStart.cshtml. And the primary use for a ViewStart file is to set the Layout view. So I'm just going to replace what is here with the line of code that used to be in my Index file. And here's how ViewStart really works. When the MVC framework goes to render a view, it will see if there's a ViewStart file somewhere in the folder hierarchy. And since we placed _ViewStart directly into our Views folder, this is going to impact all the views through all of the folders that are inside of here, both the views inside of the Home folder, as well as the Shared folder, as well as any other controller folders that we might add in the future. If I were to, instead, take ViewStart and place it only in the Home folder, then this little bit of code would only execute when I'm rendering one of those views in the Home folder. And I can even have multiple ViewStart files, so I could have a ViewStart.cshtml here in the Views folder that sets the Layout view for all views. But if I wanted to change that default for all of the views just in the Home folder, I could have another ViewStart in the Home folder that sets the layout to something else. I can also still override the Layout view if I wanted to from Index.cshtml. If I did something like Layout view equals and some other cshtml file, what I specify in the Index view would win because the ViewStart code runs before this code that's in my view. I can also say Layout = null, which is a way to tell the framework, I don't want to use a layout page. But I should be able to have that in my ViewStart file. And if I save everything, my home page still renders just the way it did before, and I still have the Layout view in effect. I just don't have to specify it everywhere. Now I can come into the Details view. I can get rid of everything except for the content that I really need and Ctrl+K, Ctrl+D to do some formatting. I still want to set ViewBag.Title here, so ViewBag.Title = and in this case, we're using the name of the restaurant in the title. So now the Details view is good. And let me also do the same for the Create view. Again, we can get rid of all the opening HTML. That's taken care of by the layout page. Ctrl+K, Ctrl+D to do some formatting. And then I just need to set the title. And now my entire application should be using this Layout view. So I should be able to see it from the home page, also when I go to a Details view, and also when I try to create a restaurant. Now there's one more special view to talk about. It's a view that can help me remove using statements from individual views.

_ViewImports

In addition to the ViewStart file, there also a ViewImports file that the MVC framework will look for when rendering any view. Like the ViewStart file, I can drop ViewImports.cshtml into a folder, and the ViewImports file can influence all the views in the folder hierarchy. This view is new for this version of MVC, and here's the idea. In previous versions of MVC, we could use an XML configuration file to configure certain aspects of the Razor view engine. Those XML files are gone. I use code instead. The ViewImports file is a place where I can write code and place common using directives to pull in namespaces that my views need. So if there are namespaces that I commonly use in my views, I can have using directives appear once in my ViewImports file instead of having using directives in every view or typing out the full namespace of a class. View Imports also has another purpose, but we'll talk about that in the next clip. For now, let's see how to move our using directives into ViewImports. Inside of the Create view, I have a using directive to bring in the namespace OdeToFood.Entities. And that will allow the code that is generated from this Razor view to compile correctly because without that using directive, the C# compiler won't be able to find this restaurant type, and I could prove that if I just swing over into the create action. One of the errors that I'll see in here is the type or namespace 'Restaurant' could not be found. And it might be that several of my views need that same using directive. So instead of placing that inside of each view, let me create in the Views folder so that it will add using statements to every view here a new item, which will be a View Imports Page. It has to be named _ViewImports.cshtml. And just like ViewStart, I cannot use this file to render HTML, but if I paste my using statement into ViewImports, now all of my views that appear in this folder or any subfolder will be able to use types from OdeToFood.Entities without specifying that exact using statement. So I can see the Create view is back to working. And for our next topic, we're going to add something else into the ViewImports. We're going to add some tag helpers.

Tag Helpers

Tag helpers are a new feature in this version of MVC. Tag helpers, just like HTML helpers, will help us render HTML. In many cases, you can replace an HTML helper with a tag helper. Why would you use tag helpers instead of HTML helpers? Well, tag helpers blend in to the HTML because they appear as if they are HTML attributes or HTML elements. Like the asp-for attribute you see here on the screen, this is a tag helper, and it blends into the HTML much better than in Html.EditorFor or Html.LabelFor. We use those helpers when we added a Create view two modules ago. So whether you choose to use HTML helpers or tag helpers, it's really a matter of personal preference. Many people are finding tag helpers to be easier on the eyes, and they make for views that are easier to author and maintain. In order to use these tag helpers, we do need to install a NuGet library and also add an addTagHelper directive to the view or views that use these tag helpers. Let's get an introduction. The first step in using tag helpers in our project will be to add a dependency on tag helpers because we started this project from scratch. And although tag helpers work very closely with the Razor view engine, they are not part of the Microsoft.AspNet.Mvc package. So I went to take a dependency on Microsoft.AspNet.Mvc.TagHelpers, and I'll pick the latest version, which is version 6-rc1 currently. And now anybody can author a tag helper, so if you can think of a tag helper that you need, you can write your own tag helper. You can place it right inside of your application project. But you do need to tell the Razor view engine about the tag helper because, by default, these tag helpers, even though they look like they blend into the HTML, they aren't just rendered down to the client. Instead, Razor will call into some code to process a tag helper. It can remove itself from the HTML. It can add additional HTML. There're all sorts of wonderful things that you can do with a tag helper. But you do have to register your tag helpers with Razor, even the Microsoft tag helpers, in order for Razor to be able to spot these tag helpers in the markup and to be able to call into the code that processes the tag helper. The directive to do that is addTagHelper, and you can place this into an individual view, or if you plan on using tag helpers throughout the application, you can use addTagHelper inside of the ViewImports file. So in addition to adding effectively this using statement to all of my views, I'm also going to tell Razor to register the following tag helpers. So the syntax to register all of the tag helpers that are in an assembly is to use asterisk comma (*,) and then the assembly name, Microsoft.AspNet.Mvc.TagHelpers. Because this first piece here is really a type name, this is where I could list a specific tag helper if I only wanted to use one. But if I just wanted to take all the tag helpers that are in this assembly, I can just use the asterisk. There are many tag helpers available. I encourage you to go out and look at the tag helper library and see which ones might be interesting to you. Let me demonstrate a few of them. Over here in the Index view currently, we already have an HTML helper using ActionLink to generate an anchor tag that will point to a URL that allows me to get to the details of a restaurant. And there's actually another link, now that I think about it, that we should really add to the home page, and that is I need a link that can send me over to that form where I can create a restaurant. So from here, the only way I can create a restaurant is to type into the address bar. And if I wanted to use a link, I could use Html.ActionLink. Sometimes that feels a little bit cumbersome. So now let me just use an anchor tag that displays the text Create. But I want to set effectively the href attribute. I want it to point to /home/create, and I could just use HTML, but I can also use some tag helpers that just like HTML ActionLink will use some information that I provide to figure out what the URL should be if I want to reach some controller and some action on that controller. These tag helpers are asp-controller, I can say I want to go to the HomeController, and asp-action says which action that I want to reach on that controller. And just like the HTML helper, if I just want to go to the Create action on the same controller that rendered this view, I can leave off the asp-controller part. But I will leave both of them there just to show you that some of these tag helpers, they work together. Asp-controller and asp-action will combine their information together to figure out what the href should be here, and if I save this view and come back, I should now have a working link to create a restaurant. And now that we have that, I'm going to remove asp-controller just because it's not required here. And what about the ActionLink that I'm using here. This one is interesting because I need to pass along a restaurant Id. Well in this case, I'll have an anchor tag that says Details, and I'll say asp-action="Details." That's the name of the action that I want to get to. And then any parameters that you want passed along, you can use the asp-route tag helper. And what's interesting about this tag helper is that you add the identifier for the data after asp-route. In other words, if I want to include a parameter in the URL that is named Id, then I can use asp-route-Id. If, instead, I wanted to pass something called title, I could use asp-route-title. And I could have both of those, -Id and -title, if I needed two pieces of information to build the complete URL. But in this case, I only need one, and this has to be the restaurant.Id. So let's use that one, get rid of the HTML helper, save my file. And let's just make sure that works by coming back to the home page, doing a hard refresh. And I know this worked because previously I was displaying the Id as the linking text. Now I'm showing the text Details. But I'm still building the correct URL now using tag helpers instead of HTML helpers. In addition to the tag helpers I've shown here, there're also tag helpers for building forms. I'm going to show you those. But there're also some very useful tag helpers that I won't have time to demonstrate, tag helpers like cache. The cache tag helper is actually a custom element. And, remember, these tag helpers, they're processed on the server side, so it's not like I'm sending a cached element down to the client. Instead, the tag helper code will jump in and rewrite some of the HTML for me. But with the caching tag helper, I can cache the content that is inside of these elements, these tag helpers, and they're programmable with attributes. So I can set different expiration policies using some attributes here to expire at a specific point in time or to vary by some specific header. So I encourage you to look at some of the other existing tag helpers. We're going to take a look at some of the form-related helpers.

An Edit Form

To see how the form tag helpers are used, let's build an entirely new feature for our application and give the app the ability to edit an existing restaurant. So I will start by adding a link on the side of each restaurant that will go to an Edit action on the HomeController. We don't have that action yet, but I'll need to pass along the Id of the restaurant that I wish to edit, and I want to display the text Edit. And to make the UI a little less ugly, I'm going to cut that table cell so it's not the first table cell, and have these links appear after the restaurant name. Later in this module, we will even get rid of the table. But for now, I'm going to save the view and come over to our controller where we will follow a very similar pattern to what we did with Create. We're going to need an Edit action that returns the view that gives the user a form to edit a restaurant. And then we'll need a second Edit action that will respond to an HttpPost. So, first of all, we need the one that will respond to a GET request. It's going to need to take a restaurant Id. And inside of here, actually, we'll have very similar code to the code that we have in the Details action. So I'm going to copy that code because, just like that code, I will first need to go out and get the restaurant that the user wants to edit. I'll have to make sure that that restaurant actually exists. If it doesn't, we will redirect the user back to the Index view. So let's change the return type here to IActionResult. But when we do have the restaurant, we will render the Edit view. We don't have that view yet, but let me take the Create view. I'm going to make a copy of that, Ctrl+C, and place it into this folder with Ctrl+V, and then just rename it to Edit.cshtml. I'm going to close this preview window just because sometimes Visual Studio gets confused during a rename. But now I've double-clicked to reopen it, and I feel pretty confident that I'm editing the correct file. For the title of this page, I can say that we want to edit and then provide the restaurant name. Let's actually use a C# 6 feature, string interpolation, and say $"Edit (Model.Name)". This dollar sign in front will allow the runtime to replace Model.Name with a value that is in that property, so the name of my restaurant. And now that I plan on using tag helpers, I'm going to get rid of things like Html.BeginForm and, instead, just use a regular form tag. So open form and close form. On the side of the form tag, I can still use tag helpers like asp-action and asp-controller so that when the user submits this form, we go to a specific controller action. In this case, I want to go to the Edit action on the same controller that I came from. And I do want to explicitly say that the method on this form, it should be using an HttpPost. The default method for a form is a GET, and I do not want to edit a restaurant using a GET operation. That's a little bit dangerous. And now instead of using an HTML helper to build a label, I'm just going to use my regular Html.Label and then use a tag helper, asp-for, to say that this is a label for the Name property of the model. And behind the scenes what this tag helper can do is set up the Html.For attribute to have the correct value and to set the inner text of this label so that it actually displays what I want, like restaurant name or Name, just like Html.LabelFor would do. What is one advantage to LabelFor, well this is a strongly typed expression here. If I were to ever rename a property, my refactoring tools could often change the expression that is inside of LabelFor, whereas with a tag helper, I really just have a string here. So there are some advantages to the HTML helpers. There are some advantages to the tag helpers. You'll just have to make the decision which one you like. Do you prefer the clarity of the HTML, or do you prefer the strong typing and IntelliSense? And now I need an input. And once again, I don't have to declare the input type or the input name or the input value. All of that will be taken care of for me if I just have an asp-for tag helper and say this is for the Name. Same thing for the validation message. This time I will create the span and use the validation-for tag helper to say that this should be validation messages for the Name property. Let's do similar things for the cuisine. I need a label that will be for cuisine. And, again, I don't have to set the text of that label. The tag helper will do that for me. And now the drop-down list is a little bit interesting. What drop-down list actually renders is a select element. And I can still say asp-for="Cuisine" so that the select has a proper name. And how do I generate my list of items? Well, I can still use this HTML helper to generate the list of items that I need. So let's cut it out of there, and I will combine that HTML helper with a tag helper, asp-items, and I'll paste my HTML helper in here. Now I will need an at(@) sign because this is a C# expression. And I'll need to make sure that I cut out the right number of parentheses. I need another parenthesis here. But this just goes to show that there is not a tag helper equivalent for every HTML helper. But in this case, there is an items helper that will allow me to specify the options for the select. And now we just need the validation span, so a span that provides validation for cuisine. This should give me everything I need to render the correct form and allow a user to edit a restaurant. Let me save the form, and let's come back to the HomeController. And now let's respond to the HttpPost that that form will send. So using the route constraint, HttpPost, give me a method IActionResult Edit. Once again, I will take a RestaurantEditViewModel, not a restaurant itself, because I only want to capture items that are in that form. And now there're actually a few different techniques that people commonly use to implement an edit action. I could new up a restaurant right here and copy over the view model inputs into the real restaurant. Or I could pull the restaurant again out of my restaurant data, and I'll do that by passing in an Id. That means I'll need an input parameter here, Id. Where does this come from? Well the edit form should always be delivered from an URL that has an Id in the URL according to my routing rules, so something like /home/edit/3. And the form is always going to post back to that same URL, /home/edit/3. And the MVC framework will be able to pull that Id out of the URL and pass it into me here as a parameter. Some people also like to add explicitly hidden inputs to their form and rely on that hidden input to deliver the Id just in case the user is fiddling with the URL for some reason. So that's one decision you can make. I'm just going to rely on the Id coming in from the URL. And now remember I always want to check if ModelState is valid. So, really, I want to check to make sure that this restaurant is in the database, so it's not null, and I want to make sure that my ModelState is valid before I try to do any update operations in the database. If none of that is true, I'm going to return a view with that restaurant and allow the user to try again, although in a real application with concurrent users, if the restaurant is null, maybe someone else deleted that restaurant. If that's the case, maybe I want to separate these two checks, and if the restaurant doesn't exist, tell the user that the restaurant doesn't exist. Otherwise, go on and then check ModelState. And if ModelState is invalid then return a view and allow them to fix their edit so everything is valid. We're going to forge ahead here. ModelState is valid. So let me copy into this restaurant that I pulled out of the database, copy in the name from the Input view model and also the new cuisine because the user might have changed either one of those. Now I will need to do something with restaurant data. I'll come back to that in just a second. But assuming all of this works, then I can redirect to the Details action just like we do in the Create scenario. So a new anonymous object specifying that the Id to include in this redirect action is the restaurant Id. Now the only question is, How do I want my data access layer to behave? Do I want to say something like _restaurantData.Update and pass in my restaurant? That would be the approach of what I could call a traditional data access layer where anytime you call a method to add or edit or delete something, the changes are immediately persisted into the database. And that's what we've done so far with our restaurant data. If we open up this service, you might remember earlier in this course, we had a discussion about the Add method. Do I want to call into the Entity Framework and immediately save changes? Or do I just want to add the restaurant and allow the application to add other things and modify other pieces of data and then explicitly call SaveChanges or some commit operation? Because the Entity Framework itself, it doesn't actually flush anything to the database until I call SaveChanges, and with the Entity Framework, I have the ability to pull a restaurant out of the database, modify some of the properties, and then just ultimately tell my DBContext object to save changes. It knows what restaurants have been pulled out of the database, and it knows which properties have been changed. I don't need to tell it to explicitly update or save a restaurant. When I call SaveChanges, it's going to flush all those changes to the database. And I'd like to show you this approach, an approach where RestaurantData implements a unit of work design pattern. You can find out more about that pattern in our Patterns course at Pluralsight. But it's very easy to implement that pattern because a DBContext object implements that pattern. In other words, instead of saving changes here, what I'm going to do is come out to RestaurantData and explicitly add a Commit operation. This is a way of saying, I want to commit my changes to the database. It's going to return an int because when you call SaveChanges on a DBContext, it can return the number of records affected. And I'll just go ahead and pass that back. How do I implement Commit on my SqlRestaurantData? Well that is as easy as just returning the result of _context.SaveChanges. And now I really don't need an explicit method to say, I want to update a restaurant. Instead, I can just get a restaurant using the Get method, execute some code that will apply changes to that restaurant, and then commit. The DBContext has tracked that restaurant. It will issue an update statement for me. And now since I'm keeping the InMemoryRestaurantData around (you can use this if you don't want to use the Entity Framework), let's also add a Commit operation here. But I'm just going to return 0. Essentially, if someone has retrieved a restaurant from this list, when they execute code that changes a property on that restaurant, those changes will already be reflected application-wide; there really is no commit for my simple InMemoryRestaurantData. So, again, it's only useful for development work when there's a single person running the application. Now that we have this in place, let's come back to the HomeController. And with this type of data access object, all I need to do at this point is tell RestaurantData to commit all the changes that have been made to any entities. Let's save everything, come back to the application. Now I have an Edit link available. Let's edit LJ's and the Kat. What I'll do is just add an extra t and change the cuisine to American. I can see those changes were applied here. There's the extra t. The cuisine is American. Let's fix the extra t, take that off, save again, and I'm pretty confident that I Edit view that I built with a tag helper is working. We're actually saving these changes into the database. I did see one change that I want to make, and I can think of one other small change that needs to be made. On the Edit view, we're still displaying the text Create. Let's instead mirror the title of the page to say we are editing a restaurant with this name. And the other change I want to make is in the HomeController. Now that we've changed around RestaurantData a bit, and we no longer immediately save changes when we add a new restaurant, then I do have to come into the Create action and say _restaurantData.Commit so that the restaurant data that I've added to the data source will be saved to the database.

Partial Views

The MVC framework has the concept of partial views. As the name implies, a partial view, which is just another Razor file with a .cshtml extension, a partial view is a view that renders just a part of the full view. There are two use cases for partial views. One use of partial views is when you have some view code that you want to re-use in the application. Let's say, for example that you have a Layout view, and the Layout view is selected by an Index view that renders in the body of that Layout view. The Index view receives from the controller a model object that is a list of restaurants. And the Index view has to display summary information about each restaurant. And this restaurant summary might require a block of Razor code that also appears in other views that are displaying restaurant information. If that's the case, I can take the common code and put it in its own view, let's call it _Summary, and render that partial view from the Index view using an HTML helper named Partial. With Partial, I pass the name of a view and optionally a model object for that partial view to work with. So you can also use partial views to take a complex model object and break down the rendering of that object into smaller views. The key point here is that when using Html.Partial to render a partial view, the partial view relies on model data from the parent view. The partial view cannot go out and get a model independently. If you do need a different model for a partial view, this is where view components come into play. View components are new in this version of MVC. Imagine I have a layout page that is again selected by the Index view, and the Index view has a model which is a list of restaurants. But a Layout view also needs to display some advertisements about restaurants using information from the database. I don't want the Index view to provide that ad data since the Index view is only concerned with the restaurants themselves. This is where I can build a view component and use Component.Invoke to render a component anywhere on the page. I can use Component.Invoke from an Index view or a Layout view or any other partial view. And the wonderful part about view components is that they are separate objects, which can be instantiated and perform their own data access, build their own model objects, and render their own partial views. So unlike Html.Partial, a view component doesn't rely on the parent view for anything. Let's look at using Html.Partial now and then create a view component in the next clip. Back in the application, I'm tired of using a table to display all of my restaurants. Instead, I want all of the restaurants to appear as cards. So I'm going to render all the restaurant information inside of a div or inside of a section. And later some CSS wizard will be able to come along and make these individual restaurant displays look really attractive. Now this scenario doesn't force me to use a partial view, but it will demonstrate how to use a partial view. And I think you'll see it cleans up the Index view quite a bit. So inside of the Index view, the goal here is to get rid of the table and instead do something like this. I'll still have a foreach statement, but now for each restaurant that I have in my collection, I want to use Html.Partial to render a partial view. Let's just call it _Summary. And each time I render that Summary view, it will need the information about the restaurant that it has to display, and I can pass that as the second parameter to Html.Partial. Let's go ahead and create that view. I can create this partial view in the Shared folder. That means any view in the application can render this partial view. Or I can just place it here inside of the Home folder where the rest of my restaurant-related features are. And now anybody that needs to display summary information about a restaurant can use this partial view, even the Details view could use this Summary view if it provided enough detail. So I right-click on the Home folder. I'm going to add a new item. I want to create an MVC View Page, and this will be called _Summary. After I add this file, I'm just going to remove all the code that's in here. I know my model will be a single restaurant. And in order to style this appropriately, I will render the restaurant inside of a section. Let's start off with an h3 element that will display the restaurant name and then perhaps a div that will display the restaurant's cuisine. And now I still want my links that allow me to edit and detail a restaurant. So coming back to the Index view, I'm just going to copy these two links and paste them into my Summary partial view. I will need to change restaurant.Id to just Model.Id because that is my model object now. I don't have a restaurant variable declared. And now I have a nice simple reusable view that displays summary information about a restaurant and provides links to get to the details and edit that restaurant. I'm going to close the partial view. And all I need to do now is fix up the Index view. I no longer need this table, but while I'm looking at it, I might place this Create link inside of a div. That might be important for spacing later. And you can see the Index view becomes very simple. I receive a somewhat complex model object, but I'm just going to delegate the rendering of each individual restaurant to a partial view, and I'll have a lot less code here. So let's save all the files and see that this looks like. I'm going to refresh the home page. And we still don't have the prettiest UI in the world, but I'm sure someone's going to be able to apply some CSS to make this look much better. So now that we've seen how to use Html.Partial where I can pass in model information for that partial view to use, let's take a look at how to build a view component.

View Components

Here's my scenario for using a view component. Let's say that we now want this configurable greeting to display on every page of the application at the bottom of the page, and, therefore, it's no longer the responsibility of the Index view to display this greeting. And I would probably go into the HomePageViewModel and remove the current greeting from that model and remove any reference to the IGreeter service and the current greeting from my HomeController. I'm going to leave that as an exercise for you. All I'm going to do is remove the section that displays that current greeting in the footer. I now want to give all responsibility for displaying that greeting to the Layout view. The problem with the Layout view, though, is I really cannot use an @Model directive here. I cannot rely on a controller action to build a model that the Layout view can consume. It is possible, but it always creates difficulties in applications. Instead, I want the ability to use a view component, which is completely independent of whatever controller is currently executing and whatever model is being used to render the view because the Layout view will be used with different views that use all sorts of models. This view component is responsible for getting the greeting and rendering some HTML into my Layout view. And the way I invoke a view component is to use the component helper and tell it to invoke and then the name of the view component. I'm going to create a view component called Greeting. Ultimately this view component will render a partial view, and the output of the partial view will appear here where you see Component.Invoke. Now a view component is more than just a partial view. A view component is almost a complete MVC abstraction. There is a class with a method that will get invoked. The method needs to build a model and pick which view to render. It's just that that view is going to be a partial view that appears to render part of the page. If you have used previous versions of MVC, you might have used the Html.Action helper to execute a child action. In this version of the MVC framework, child actions are gone, and we use view components instead. It's a much better solution to this problem of I want an independent component that can render a partial view with its own model into my page. To create this view component, I'm going to create a new folder. So in addition to the controller's folder, I'm also going to have ViewComponents. And inside of ViewComponents, I'm going to add a class because, as I said, a view component is really all the MVC pieces put together. You can almost think of the view component as a controller. We just never route to it. I want to create a view component called Greeting, so this will be the Greeting.cs class. And a view component can inherit from a view component base class. This is in the Microsoft.AspNet.Mvc namespace. So we will bring that namespace in, remove the namespaces that we don't use, and just like a controller, a view component can have dependencies injected in. And if I want to get today's current greeting, I need to ask for an instance of the object that implements IGreeter that's in the OdeToFood.Services namespace. We'll call this greeter. Just like I do with the HomeController, I will save the greeter off into a private variable. I just need to use Ctrl+period(.) to generate that field. And now the primary method that you implement for a view component is a method called Invoke. So, again, this isn't a controller. This isn't something that I route to. It's not going to have multiple methods that get reached by different URLs. It is a view component, and there's one method that gets invoked when I use @component.invoke in some other view. It's a method called Invoke. This is going to return something that implements the IViewComponentResult. So you'll notice a lot of parallels between controllers and view components. In controllers we have IActionResult. It's the result of an action. This is a IViewComponentResult called Invoke. And my model object is really just asking greeter for the current greeting. And now just like in a controller action, I can return a view. Now one word of warning about the View helper method, and this is true both for view components as well as controllers, if your model is a simple string and you pass this string as the first parameter to the View method, the MVC framework sees that as the name of the view that you want to render. It doesn't see it as the model object. If I want a string to be my model object, I have to explicitly specify my view name and then pass in the model object. So I want to render a view called Default passing in the string as my model, and the name Default would be the default for a view component. I just need to create that view. Now the location for view component views, it follows a convention much like the convention we already have where all of the views related to a specific controller, like the HomeController, appear in a folder, and shared views appear in the Shared folder. View component views will always appear in a Components folder, and I'm going to place this Components folder in the Shared folder. That means this is a view that is rendered by a view component that can be used from anywhere in the application. I could also place a Components folder into the Home folder for views that will be rendered from view components that the HomeController uses. And then inside of here, I need a folder for each view component. Since my view component is named Greeting, I will also call this folder Greeting. And then we explicitly said that we wanted to render a default view, or the name of the view is Default, so let me create a new MVC View Page that is called Default. And this can be a very simple view. All I need to do is declare my model. It's of type String. And inside of a section, let's render in small print the model value. I'm going to save all my files, come back to the browser and refresh. And now I have my message in slightly smaller print, but that message should now appear on every page of the application because it's rendered from a view component using Component.Invoke from my Layout page. And a view component is a very robust abstraction. I could inject IRestaurantData into the view component, and it could retrieve restaurant information if it needed to. And it gets to build its own model and render its own partial view.

Summary

In this module, we worked with Layout views and partial views, as well as new features in this version of MVC, features like tag helpers, view components, and the ViewImports file. Using all of these view techniques we learned about, they all allow you to create maintainable view code by avoiding duplication and decomposing complex views into smaller pieces. That's the ultimate goal of many of these features. They give you the ability to create good maintainable code.

ASP.NET Identity

Introduction

Hi! This is Scott, and in this module we will set up the ASP.NET Identity framework to implement forms authentication. There are many options to choose from for identifying your users including Windows Authentication and all of the third-party identity providers like Google, Microsoft, Facebook, and GitHub. We're going to choose and focus on building up a traditional forms authentication scheme from scratch so we can understand the primary pieces of the Identity framework. Let's start with an overview.

ASP.NET Identity Overview

The Identity framework is another dependency that we will add to our application in the project.js file. This framework allows us to add features where users can register and log in with a local password. The framework also supports two-factor authentication, third-party identity providers, account lockouts, and other features we won't have time to cover in this video. We're going to focus on the scenarios where a user can register and log in and log out. To do this, we're going to need to create a User entity. This class will inherit from a base class in the Identity framework, and the base class gives us our standard user properties like username and email address. We can include as many additional properties as we want on this class to store information about our users. We can store their favorite cuisine or favorite color, for example. We need to take this User class and plug it into a UserStore class provided by the Identity framework. The UserStore is the class that our code will talk to to create users and validate user passwords. Ultimately, a UserStore will talk to a database, and out of the box the Identity framework supports the Entity Framework and all of the databases that can work with the Entity Framework. But you can implement your own UserStore to work with any data source. In order to work with the Entity Framework properly, our User class will also plug into an IdentityDb class. This is a class that uses an Entity Framework DBContext to do the actual database work. We'll need to include this IdentityDb into our application by having our existing DataContext class inherit from IdentityDb instead of the Entity Framework's DBContext. So it's the IdentityDb and the UserStore that work together to store user information and validate user passwords, the hashed passwords that are in the database. And then there's just two more pieces of the framework to know about. One of these pieces is the SignInManager. As the name implies, the SignInManager can sign in a user once we validated their password. We can also use this manager to sign a user out. With forms authentication, the sign in and the sign out are done by managing a cookie. When we tell the SignInManager to sign a user in, the manager issues a cookie to the user's browser, and the browser will send this cookie on every subsequent request so that we can identify that user. Reading this cookie and identifying the user, this happens in the final piece of the framework, the Identity Middleware. We'll need to configure this middleware into our application pipeline to process the cookie set by the SignInManager. We'll also see some other features of this middleware. And as we go along, we're going to learn how to use the Authorize attributes to restrict access to specific controller actions. We'll also see new scenarios for view model, model validation, controllers, and Razor views. So this will be a good overview of putting together everything we've learned in the course so far.

Using the Authorize Attribute

So far in our application, we will allow anonymous users to do anything. They can create restaurant, edit restaurants, and view details. We want to change this behavior so that in the future, anonymous users can only see the list of restaurant on the home page, but every other action requires the user to identify themselves and sign in. We'll do this with the Authorize attribute. You can place the Authorize attribute on a controller or on individual actions inside of a controller. When we place the Authorize attribute on the controller itself, the authorize attribute applies to all of the actions inside. The MVC framework will not allow a request to reach an action protected by this attribute unless the user passes an authorization check. By default, if you use no other parameters, the only check the Authorize attribute will make is a check to ensure the user is logged in so we know their identity. But you can use parameters to specify any fancy custom authorization policy that you like. There is also an AllowAnonymous attribute. This attribute is useful when you want to use the Authorize attribute on a controller to protect all of the actions inside, but then there is this single action or one or two actions that you want to unprotect and allow anonymous users to reach that specific action. Let's try these attributes out in our application. In the running application, I am an anonymous user, and I can edit a restaurant. But I want to change this and force a user to log in and identify themselves before they can edit a restaurant. So let's go into our HomeController. And if I just wanted to restrict access to one or two actions, I could always place the Authorize attribute on those specific actions that I want to protect. But I can also place the Authorize attribute on the controller itself, and this Authorize attribute, it is in the Microsoft.AspNet.Authorization namespace. And as I say, if you have fancier authentication and authorization schemes, you can pass in parameters to ask for a specific authorization policy that you can configure during the startup of your application. But that's a little bit beyond the scope of this course. All we're going to do is use the Authorize attribute and force users to identify themselves to get into this controller except for the home page. The home page that displays the list of restaurants I'm going to use the AllowAnonymous attribute, and now I'm going to save this controller. Let me refresh the home page and also open up the developer tools with the F12 key. And there're a couple of things that I will want to watch in the developer tools through this module just so we can see how things work. And let me dock these tools at the bottom of the browser, come over to the Network tab, and show you now what happens when I click on the Edit link. Now I'm left with a blank page, and you can see that the HTTP status code that was returned from the server was a 401 status code. The 401 status code tells the browser that the request was not allowed through because it lacked valid authentication credentials. And this tells me that the Authorize attribute is working. What's bad is that the user is left on a blank page. And unless they have the developer tools open, they may not know that this was an authentication problem. And this is where the Identity framework can step in and help. The Identity framework can detect when a piece of the application wants to return 401 status code because the user is not allowed to get there, and the Identity framework can turn that into a login page and allow the user to get past this problem. We'll see how that works once we get the Identity framework installed and configured. But right now, we can see that the Authorize attribute is working. And now we need to allow users to register and log into this site.

ASP.NET Identity Configuration

Now we are ready to install and configure the Identity framework, which takes just a little bit of work. And I do want to point out that if you go into Visual Studio and create a new ASP.NET application, and you select the full web application template with authentication set to individual user accounts, that new project will include all the bits of the Identity framework set up for you. But since we started from an empty project, we'll set up the Identity framework from scratch, which is, I think, a good way to learn about all the pieces that are in the full application template because it can be confusing if you haven't worked your way through all the code in detail. For us to get started, we will need to install the dependency, which is Microsoft.AspNet.Identity except we will actually install Microsoft.AspNet.Identity.EntityFramework so we have an implementation of the Identity framework that works with the Entity Framework and, therefore will work with our SQL Server database. If I take a dependency on Identity.EntityFramework, that package, I'll automatically have the Identity package included. If you build your own data stores, you can work just with the Identity package. Once my dependencies are installed, I can create a customer User class with all the information I want to store about a user. For this application, I'm going to inherit from a class provided by the Identity framework. And that class will give me all the essentials like the Username property and a place to store the hashed passwords. I will also need to modify my OdeToFoodDbContext class to inherit from the Identity framework's IdentityDb class. The IdentityDb gives me everything I need to store user information with the Entity Framework. And once I have a User class and a DBContext set up, I'll need to configure the Identity services into the application during the ConfigureServices method of Startup class. Just like when we needed to add services to support the MVC framework, the Identity framework needs services added to the application in order to work. And these services include services like the UserStore service and the SignInManager. We will be injecting those services into our controller to create users and issue cookies at the appropriate time. Finally, during the Configure method of startup, I'll need to add the Identity middleware. This middleware will not only help to turn cookies into a user identity, but also make sure that the user doesn't see an empty page with a 401 response. Let's work on these steps now. Inside the application, let's do everything we need to get the software configured. And that includes adding a dependency on the Identity framework, and I'll do this just by typing into the project.json file. We want to bring in Microsoft.AspNet.Identity.EntityFramework. And this will include all of the other necessary Identity packages that we need. And once I save this file, and Visual Studio restores the packages, we'll be able to add our User class. And that seems to have worked. So let's add the User entity. It is an entity because it is a class that represents all of the information that I want to store in a database. So I will right-click on the Entities folder. I want to add a class called User. And, again, this is where you can add properties to this class to hold any information that you want to store about a user. So favorite number, favorite color, pet's name, and so forth. All I'm going to do for this application is derive from a class provided by the Identity framework, and it is the IdentityUser class that is in the Identity.EntityFramework namespace. So let's bring in that namespace, remove the namespaces that we're not using. And let me go to IdentityUser, put the cursor on that symbol, and press F12 to see Visual Studio's metadata view. And I can see that IdentityUser derives from IdentityUser of string. If I want to change the type of the primary key, I can do that by deriving from IdentityUser and specifying my generic type parameter here. So if I wanted to store things with a primary key that was an integer value, I could do that. But let's also place the cursor on IdentityUser of string and press F12 again to go to this metadata view. And here you can see all of the information that we will store about a user by default. This includes many fields that we won't use in this application, but they are available for use. So the Identity framework can keep track of the number of failed login attempts for a particular user and can then lock out that account for a period of time. We also by default have fields to store the PasswordHash, the PhoneNumber, and really the two important fields that we will be using are the PasswordHash and the UserName. We'll also be implicitly using the primary key, the Id property of a user, and you can also use that property if you need to query for a specific user. So it wasn't completely necessary that I add this User entity. I could just use IdentityUser, but I'll leave this as a placeholder here in case you need to plug in some of your own custom fields. Now what I will do with that User is make sure that it is included on my DBContext. And the way I can do that is to open up the DBContext that I have, OdeToFoodDbContext, and instead of deriving directly from DBContext, which is the built-in Entity Framework base class, I'm going to derive from IdentityDbContext. This class is also in the Microsoft.AspNet.Identity.EntityFramework namespace. And when I derive from this class, I can specify the type of user it should store. So I'm going to select my User entity that I just created. That way any additional fields I add to that User class I can be sure they will get into the database. And this IdentityDbContext, it brings in additional DbSets, not just to store a user but also information about user roles and user claims. We will see that when we create the database using Entity Framework migrations like we did earlier in the module. But for now with these two pieces, my User class is ready, my OdeToFoodDbContext class is configured to work with the Identity framework, I can now go into Configure and ConfigureServices to set up the Identity framework. I'll start with ConfigureServices. In addition to my MVC services and my Entity Framework services, I need to add my Identity services. This will add in all of the services that the Identity framework relies on to do its work. And some of those services like the SignInManager, I'm also going to use for my code. This method takes two generic type parameters. You'll see this as a recurring theme with the Identity framework because they want it to be extensible. They want it to be flexible. It's designed to be able to work your type of User entity and your type of role entity. And the two generic type parameters here are the type of my user, which is that User entity I just created. And then the type of Role class that I want to work with, and I'm going to use the built-in IdentityRole. So just like the IdentityUser that we just derived from, IdentityRole is a base class that you can extend to add your own custom properties about role-based information. We're not going to work with roles in this application, but you can set up roles like administrators, users, sales, accounting, and so forth. This class is in that EntityFramework namespace. I will bring that in. And this configures the core pieces of the Identity framework. When I'm using the Entity Framework with Identity, I also need to invoke a second method, which is AddEntityFrameworkStores. This will configure services like the UserStore, which is the service we can use to create users and validate their passwords. It knows how to work against the Entity Framework, but I need to tell it the DBContext derives class that it will use to communicate with the Identity schema in the dataset. And that class is my OdeToFoodDbContext because that is the class that I derived from IdentityDb. So these two lines are all we need to do to configure the services for the application. We also need to add the middleware. The location of where I insert the middleware is important because if I insert the middleware too late in the pipeline, it will never have the chance to process a request. And if I require authorization checks inside of my MVC controllers, I need to have the Identity middleware inserted before the MVC framework to make sure that cookies are processed successfully and 401 errors are processed successfully. And so this is the location where I will add that Identity middleware. Now there're lots of configurable options both in the services and in this middleware. I'm just going to use the defaults for now. I'll point out some of those extensibility points later in the video. For now, I should be able to Shift+Ctrl+B to build the application, just make sure I don't have any errors. And since I do not, the next thing I'd like to do is add another Entity Framework migration to make sure we have the Identity schema in our SQL Server database. Let's do that in the next clip.

Identity Migrations

Anytime you make a change to one of your entity classes or you make a change to your DBContext derived class, chances are you will have to create a new migration script to apply to the database and bring the schema in sync with what is in your code. And this is certainly the case in our situation because the IdentityDbContext that we now derive from, it contains its own DbSets, and it wants to create a schema to store all the information about the entities that it manages. So just like we did before in the Entity Framework module, let's open up a command prompt and make sure we are in the location where the project.json file exists for our project. That's the root of the project. And we want to make sure that we can execute the dnx command, which in the future will be the dotnet command. But currently here in release candidate 1, it is still dnx. And you might remember we can get to some Entity Framework commands by typing dnx ef, our project.json file has a section that maps this ef moniker to Entity Framework dot commands. And it's from here where I can add a migration. So just like we did earlier in the course, I want to do dnx ef migrations. I want to add a migration. I have to provide a name, let's use v2 for version 2. And when this is complete, I will have a v2 file in my migrations folder. I now want to apply that to my database. Let's just take a quick look. In SQL Server Object Explorer, currently we just have the restaurant table effectively. But when I tell dnx to run the ef command, specifically the database update command, the Entity Framework will see there is a migration that needs to be applied. And it will execute that migration. If I now come into SQL Server, and let's refresh our table list, I will now see in addition to the restaurant table that we created earlier, I now also have tables to store users, claims, roles, and the effectively some mapping tables that map users to specific roles. These are all related to the entities that the Identity framework provides. Let's just take a quick peek at the users table. I want to show you that the columns inside of here include columns to store all of those properties that we saw before on the Identity User which we inherited from, and it's fields like UserName and PasswordHash. And if I ever want to work against this users table directly, let me just add a quick test method to my DBContext, just an instance method so that I can show you there is now a Users DbSet property available on my OdeToFoodDbContext. I could now start using LINQ operators to query this table and work with user information directly. But as you'll see in a bit, you can get quite far just using some of the built-in Identity services because they also contain an ability to create a user and validate a user's password. And to do all those safely without me having to worry about things like, What is the best hashing algorithm to use? But we do now have a working database, and it's time to start adding some of these features to the application.

User Registration

Now that we have our software configured and we have a working database schema, let me come into the application and try to get to the Edit view again. Previously when I did this, the MVC framework detected the presence of the Authorize attribute and returned a 401 status code because the user wasn't logged in. And let's see what the experience is like now. And you'll notice that this time, I get a message on the screen, A configurable hello! And here's what happened. My browser still requested the edit page, and the MVC framework again decided the user is not authorized to view this resource. So somewhere inside of the MVC framework, a 401 status code was generated. But because I have the Identity middleware in place, the Identity middleware looks at that 401 status code that's going to go out to the user and replaces it with a 302 status code, which is a redirect status code. The Identity framework knows that the user will have to try to log in before they can reach this resource. And the Identity framework sent us to this URL, which we can see the full URL in the address bar. It's /Account/Login. Now this is a configurable endpoint with the Identity framework. Inside of Startup when you are registering these services and registering the middleware, there are many different options you can set. And one of the options is to change the login URL. By default, it's going to be /Account/Login. Currently, we don't have an account controller, so we're falling through to the last piece of middleware that we configured into our application. We did this at the very beginning of the course. It's the app.Run middleware that just displays a greeting message. If it wasn't for that message, we'd essentially have a 404 error, Resource Not Found. So ultimately what we want to do is build an account controller and allow a user to log in. But before a user can even log in, they will need to register on the site and save their username and a password. Both the login and the register, both of those features can be part of an account controller So let's go ahead and add a new class, AccountController. I'll add this to the Controllers folder. And just like we've done before, we will make this derive from the MVC framework base Controller class. Just bring in that namespace. Once again, remove some of the namespaces that we're currently not using. And I need to set up a feature where a user can register for this site. It's going to be much like an edit form. The user wants to register, so I will first display a form that allows them to fill out some information, and then they can post that form to the site. And if everything is good, we will save their information into the database. So let's create first the action that will return a view when we go to /account/register. I don't need to look anything up. The user's going to provide all the information that we need. And quite often before I build the view, I will build the view model for that view. And that gives me a chance to think about what information do I need the view to display? What information do I need to receive from the user? Let's create a view model for this scenario. Right-click on ViewModels. I want to add a class. Let's call this the RegisterViewModel. And for this application, we're going to recover the bare minimum information. I'm not even going to worry about an email address. I just want someone to give me their preferred username and a password. So let's create one property that will hold the username. Let's create another property that will hold the password that they've chosen. And like most good registration forms, we should also have the user confirm their password by typing it in twice and making sure that those both match. And just like we've done with previous view models, let's add some annotations that can help us validate this model, annotations from the System.ComponentModel.DataAnnotations namespace. We've used these before. I'll make the username required. And if you remember when we looked at the database schema, the column to hold a username was 256 characters long, so we'll also apply a MaxLength attribute there. A password is going to be required, and when I render an input for this password, I want the input type to be of type Password so that the characters don't display on the screen. The confirm password is also going to be DataType Password. And then there's an additional attribute, a new attribute that we haven't used yet. I want to compare the ConfirmPassword field with this other property that I can specify, which is the Password field. Now quite often, I've been using string literals to point to other properties and so forth, but just so you know, there is a feature in C# 6, the new nameof operator, or I can say, Please give me the name of the RegisterViewModel.Password property. And that will get rid of that string literal if I don't want to have that there. And in this case, since I'm looking for a property on this class, I can completely remove the type name there. Sometimes when you're trying to specify a controller and an action using strings, your nameof expression will have to include the type because you're not inside of the controller. But that's one random tip for this module. Let's remove our unnecessary usings here, and let's create the view that we need. I will need to add a new folder to the views, this one called Account, so all of the views related to the AccountController. And inside of here, let's add a new item. I want an MVC View Page. I want it to be called Register. And after I delete the existing code that is inside of here from the template, let's specify the model as the RegisterViewModel that I just created. I don't believe our ViewModels namespace is included by default. Let's go ahead and add that to ViewImports. So in addition to using the Entities namespace, let's also add a using for the ViewModels namespace. And now I will also set the title for this page using the ViewBag to ViewBag.Title equals, let's just say Register. And now I just need to create a form. Again, this will not be the best-looking form in the world but a form that will post. I always want to make sure that I post to the AccountController, specifically the Register action. And for this form, I'm going to include a div that will display a validation summary. I'll explain more on why we have a validation summary when we get a little bit further along. But when I use ASP validation summary, I need to specify what errors are to appear in the summary. I can have all the errors appear in the summary area, or I can say ValidationSummary.ModelOnly. And the only errors that will appear from model validation inside of the summary will be validation errors that are associated with the model and not a specific property of that model. In other words, if the user doesn't fill out their username, well the username is required, and there will be a validation error for that specific property. But you can also generate model errors that are not associated with a specific property. They will appear in this ValidationSummary. Now what I need are labels and inputs for all of the different fields that I have in my ViewModel. So I need a label for the Username. I need an input for the Username. And I would like to have validation messages for the Username. And since the other two properties that we need the user to enter are much the same, let me go ahead and grab a little bit of code offscreen and bring it here and paste it in. And all I've pasted in is the code that will have a label and input and a span for the Password and a label and an input and a span for ConfirmPassword. And I don't need to specify the input types here. The ASP 4 tag helper will make sure to set that input type as a password for me. And then I have the button that says Register that when the user clicks this, we will submit the form back to the controller. So from the controller, I will implement an HttpPost method. Let's return an IActionResult. I expect to receive a RegisterViewModel. And to do that, I'll just need to make sure I have the namespace, OdeToFood.ViewModels, included. And from here, I'm just going to need to interact with the Identity framework to make sure that the user is valid, to tell the Identity framework to create that user, and then since they've just created the account, go ahead and log them in. We will look at implementing those steps in the next clip.

Creating a User

One of the first checks that we should always make inside of a post back is the check to make sure our ModelState is valid because if it is, we know the user gave us a username and a password and confirmed the password, and if not, we're going to need them to provide the correct information. So we will just re-render the RegisterView and allow ModelState to repopulate the inputs. But if our ModelState is valid, now we need to talk to the Identity framework, and we need to create a new instance of our User entity, which requires me to bring in the namespace, OdeToFood.Entities. And just like we did with the restaurant edit scenario, we can copy our input model values into properties on this User entity. So I can say that the UserName property equals model.Username. But I'm not going to copy in the password because there is no place to store the plain text password in the User entity. Instead, I'm going to pass that directly to the Identity framework, which will hash the password. So now it's time to work with the Identity framework. And you might remember at the beginning, we talked about two of the core services of the Identity framework. One is the UserManager, and the other is the SignInManager. I'm going to need to inject both of those services into my controller so that we can call the appropriate APIs when we need to create a user or sign in a user. I'll give our AccountController a constructor, and I'm going to ask for a UserManager of User, our type, and that requires the namespace Microsoft.AspNet.Identity. We'll call this parameter the userManager. And then I also need a SignInManager of User. We'll call this the signInManager. And I want to save both of these off into private fields. So _userManager equals the incoming userManager, and a new field _signInManager equals the incoming signInManager. And let me use Ctrl+period(.) to generate the userManager field and Ctrl+period(.) to generate the signInManager field. Now we have all the requires services available. Let me go into Register and show you that there is a userManager.Create Async. Now this is an Async method where I pass in the user that I want to save, so the User entity that we just created, and then the password for that user. So I can pass in the input model's password property. But this is an Async method, and Async methods are a little bit beyond the scope of this course. So let me just show you the simplest possible things to do. The simplest possible thing to do with Async methods is to always use the C# Async and Await keywords, which allow me to write code like this. I do need to get a result from CreateAsync. That method call will give me back a result that tells me if this succeeded or failed. And if it failed, it will give me some of the possible reasons why it failed. But to grab that result, I need to use the Await keyword or at least that's the easiest safest approach. As soon as I use the Await keyword inside of a method body, I need to add the Async keyword to my method definition, and I need to wrap the result that I return inside of a Task. Task is inside of a namespace we don't currently have. It's the System.Threading.Tasks namespace. Let me bring in that namespace. And I now have a perfectly valid Async method. The MVC runtime understands how to work with actions that return a task. And the framework will do the appropriate thing. Now that I have a result, I can see if the result succeeded. So you can see there are two significant properties on the result. There's the Succeeded property, which is a Boolean, and then there's an Errors property, which we'll have to look at in just a second. If the result succeeded, now I can sign in the user. They just created an account. They just added their password. Why not ask the SignInManager to go ahead and sign this user in? This is also an Async method. I need to pass in the user entity that I'm signing in. And then there's a flag here, isPersistent, which basically means, Do we want to issue a cookie that is a session cookie, which is a cookie that will go away when the user closes their browser? Or do we want to issue a persistent cookie that will stick around until some point in the future? Let's just choose a non-persistent cookie, a session cookie at this point. And because this is an Async method, I'm also going to await that method. And once that is complete, let's just redirect the user back to the home page. So I can say, Go to the Index action of the HomeController. You will now be authenticated. And, again this is another place where I could use the nameof operator in C# 6. Now if the result did not succeed, then I should try to tell the user why. And, fortunately, that result that comes back from the UserManager has a collection of errors that I can iterate through. So I can say for each error in result.Errors, what do I want to do with them? Well, if I add those errors into ModelState, they will be available in the view for tag helpers like the validation tag helpers, to display information on the page. And all I need to do to add each error into ModelState is to say ModelState.AddModelError. Here's where I can provide a key to associate an error with a specific field. But I'm just going to use a blank string and add in the description of the error that was provided for me. And this is the implementation of our Register method. Let me save all the files, and let's see what we can do back here in the browser. I'm going to go to /account/register and here is our form that still needs some serious design work. But let me try to enter in a username and a very simple 3-character password and click Register. By default, the Identity framework tries to enforce some rules around passwords. The passwords have to have at least 6 characters, one has to be lowercase, one has to be uppercase, there's one non-digit character. Again, these are all options that you can configure during Startup when you're adding in your Identity services. But the reason these errors appear here is because I have a validation summary on the page that is picking up the errors that come back from the userManager.CreateAsync result. And now that I know a little more about what the password rules are, let me try to create a sufficiently complex password and click Register. And because I have now ended up on the home page, I'm going to assume that operation worked. We'll add some details to the UI so that we know this worked. For right now, let's just peek inside of SQL Server. I want to open up the AspNetUsers table, and I want to view the data inside. And now I can be pretty sure that the user was created successfully. I can see a new record in the Users table. And I can see that there is a hashed password value inside, as well as a username that is the username I registered with, sallen. The other way I could've double-checked this is inside of the browser, when I sign in a user with the IdentityManager like this, there will be a cookie set. So if I go into the Resources section of the Chrome developer tools, and I look at Cookies, then this cookie here, the one that has the name .AspNet.Microsoft.AspNet.Identity.Application, this is my authentication ticket. This is the cookie that the browser will send along on every subsequent request, and it's the one the Identity middleware will inspect and figure out my identity based on the cryptographic information that is inside. And now that we have the ability to register, let's look at the login feature.

Log in and Log Out

Now let's build the login feature. And while we're at it, we should also add a logout feature. The logout is rather simple to implement. And I'm going to do this by actually starting in the Layout view because what I want to do is build a UI that has some links that will allow a signed in user to log out and also display their username. And for an anonymous user, we can go ahead and show a login link. Now quite often I would put this sort of markup inside of a partial view that I render from the Layout view. That way the Layout view stays simple. But for this example, I will add this to the Layout view directly. All the information you need to build this UI is available from the Razor view context so you can easily make this a partial view or even a view component. Specifically what I'm talking about is there is a User property that is available inside of every Razor view. And if I want to build a UI that will display let's say the logged in user's name, then there is an extension method available on this User property. All I need to do is bring in the namespace System.Security.Claims. And I now have access to a couple of methods, but one of them is IsSignedIn. So I can invoke this method. And if it returns true, this is where I can place some markup to display the username, display a logout button. Otherwise, I have an anonymous user, and I can show a link that will go to the AccountController, specifically to the Login action, and it can display the text Login. And I'm going to make a copy of that link because while we're at it, we could also build a link for new users to register and go directly to the Register page. Now if the user is signed in, I can display the user's username using another helper method that is available, GetUserName. I'll invoke that, and it will return sallen. And then I want to build a logout button. And I want to do this inside of a form that will post to the web server because you can create some unsavory conditions if you allow a simple Get request to low a user out. Then it becomes very easy for someone who is malicious to log out a user by sending them, let's say, links in an email or a picture with a source attribute that is set to the logout URL. So we're going to force this to be a post, and when the user submits this form, all we need to do is hit a Logout action, which we will implement on the AccountController, and that will logout the user. All we need here is an input type submit whose value will display the text Logout. Let me save the Layout view, and let's go over to the AccountController and implement that action quickly. I'll place it down here at the bottom of the controller. This is an action that I only want to respond to an HttpPost. It's going to be an async action because I have to call another asynchronous method on the Identity framework. So I can return a task of ViewResult or IActionResult or RedirectResult. Let's go with IActionResult. And this action name is Logout. All I need to do to logout is to await the SignInManager's SignOutAsync method. No parameters required. What that will do is unset the cookie from the browser so that authentication ticket goes away. And then because the user context has just changed, we now have an anonymous user. Let's send them somewhere safe like the home page and go back to the list of restaurants. Let me save everything, and we'll try this. Over in the browser, let me refresh to get the new UI. And, yes, we still need some design work. But there's my username displaying properly. Here's my Logout button. And when I log out, I come back to the home page, and I can see there are now Login and Register links because I am no longer signed in. So let's build our Login feature. But before we do, I just want to show you that when I try to go to edit a restaurant now, I've been redirected to /Account/Login so I can log in. And notice there's a query string parameter here, the return URL. What the Identity framework will do is place that into the URL so that once I do log in, the application can take me back to the URL that I was trying to get to when I was denied access. So I should be able to log in and then go right /home/edit/1 and continue working by editing that restaurant. So let's see if we can get this URL to respond with a Login view instead of with a greeting message. And once again, I'm going to need a pair of actions. I'm going to need one that responds to an HttpGet request and displays the form that I can use to log in, and then I'll need one that response to a Post request. So this one will respond to the Get request. And I want to take as a parameter the returnUrl that is in the query string. It might not always be there, so I will default this to an empty string. But when that return URL does appear in the query string, I want to take that information and use it appropriately so I can redirect the user. And I am going to need a new view model to pull this off because logging in is very different from registering. So let me add a new class called the LoginViewModel. So when the user logs in, they really have to provide me three pieces of information. They need to give me their username. They also need to give me their password. And this I'm going to pull in the DataAnnotations so that we can use the tag helpers. And I'm going to say that this is a Password field. And then the third piece of information most login UIs have that little checkbox that say, Do you want to remember me? And that's really the choice between Do I want a session cookie, or do I want a more permanent cookie? And we will allow for that feature by adding a Boolean property here. Let's call it RememberMe. But I'll use a Display annotation so that when we build a label, we will display the text Remember Me with a space. And then the last piece that I actually want as part of this view model, I want to have a property that will store that ReturnUrl. The user doesn't have to supply that. That might be in the query string, and the MVC framework model binding will put it into my view model for me. So let's remove the unused namespaces, close our view model, and now let's implement this login action. I'm going to build a new instance of the LoginViewModel, and I will set the ReturnUrl to this incoming parameter returnUrl. That's going to make it really easy to hand that information off to the view. So now we need a new view called in Login.cshtml. So let me add a new item. I'll select the MVC View Page. This is going to be called Login.cshtml. And since this form looks much like some of the other forms that we have built, I'm not going to force you to watch me type this all out by hand. Instead, let me just add some code into this view and then talk about what we're doing here. We're going to set the title of the page to Login. We're going to have a form that will post to the AccountLogin action. And we're going to use a tag helper, asp-route-returnurl, to make sure that the ReturnUrl is there in the URL that the form posts back to. I need to send that ReturnUrl back to the server once again so that if the user does successfully log in, I can send them over to the place they were trying to get to. So you might remember we used asp-route before, and anything that you add after asp-route-Id, -ReturnUrl, whatever you have there, that's going to go into the request somewhere, either into the URL path or as a query string parameter. We have our ValidationSummary. We have our inputs for Username, for Password, for RememberMe, only this is just Remember. And I believe I called the property RememberMe. And then we have a Submit button. That's everything that we should need. Let's go back to the AccountController, and now let's implement the Post action, so an action that responds to HttpPost. This will be an Async method because we'll need to call into the Identity framework so we can return a task or IActionResult. We call this Login, and now I expect to receive a Login view model. As always, I want to check if ModelState is valid. And if so, we're going to call into an API on the SignInManager. The method is PasswordSignInAsync. The overload I'm going to use here is one where I have to pass the Username, the Password, a Boolean flag to indicate if I want a session cookie or a more persistent cookie, that's the RememberMe flag, and then do I want to lock out on failure. I'm going to set this to false for this application. This will return a result. So we will have to await that method to grab the result, and if the result succeeded, I know the user has logged in successfully. And if that have logged in successfully and I have a return URL, in other words, if not, string.IsNullOrEmpty(model.ReturnUrl). Now I want to send them back to the URL that they were trying to get to, which might be the URL to edit a restaurant. But there's actually one more important check that I want to make here. If there is a return URL, I also want to make sure that the URL is a local URL. Otherwise, we would have a website with a security vulnerability known as an open redirect. And open redirects can be very bad for our users. It opens us up to all sorts of fishing attacks. So now if we have a return URL and it's a local URL, I just want to redirect directly to that return URL. Otherwise, the user has just logged in. They didn't have any specific place to go. So we will redirect them to the Index action of the HomeController. Now if we never did one of these redirects, we're just going to re-render the view with a model, but we might be in a situation where they provided an invalid password or an invalid username. So I am going to add a model error that just says Invalid login attempt just so the user knows that something went wrong. Let's try this out. I'm going to save everything, come back to the application. Let's go back to the home page of the application. I'm currently an anonymous user. I'm going to try to edit a restaurant. I am redirected to the new Login view that we just created. Let me log in with my username and my password. I can select Remember Me. And because we processed the return URL appropriately, I am sent to that URL that I was trying to get to, /Home/Edit/1, and I can see positively that I did log in successfully.

Summary

In this module, we worked with the ASP.NET Identity framework to add authentication and authorization features to the application. Thanks to the authorized attribute in the MVC framework, we now protect the Edit and Create actions from anonymous users. And we created a new AccountController with associated views to use services of the Identity framework, services like UserStore and SignInManager. We used these to implement the login, logout, and register pages for the app. Now one topic we haven't talked about with all of the forms we've been building is how to apply some client-side validations. We'll look at that topic in the next module.

Front End Frameworks and Tools

Introduction

Hi! This is Scott, and in this module, we will turn our attention to front-end JavaScript and CSS libraries. We will look at tools that we can use to manage and install these libraries and frameworks. We will also add some style to our application. And, finally, we will learn how to support client-side validation in development, as well as production. Let's get started with an overview of the tools that are in play.

Front End Tools

If you have been using Visual Studio at all in the last few years, you probably know about NuGet. NuGet is the package manager for .NET. Behind the scenes, the dependencies that we've installed into our application, dependencies like the Entity Framework, these dependencies are managed by NuGet, which can download the software bits and place them on our file system. For a period of time, NuGet with ASP.NET Core was only going to support .NET-related binaries. But the team has promised to also support content packages where content packages can install static files like the jQuery JavaScript library. For reasons that I will explain later, however, I won't be using NuGet to install the front-end libraries that we need. Bower is another package manager, a package manager specifically for front-end work, and it's become popular over the last few years. If you have used any of the pre-releases of ASP.NET Core, you'll know that Bower is the suggested tool for managing front-end libraries with ASP.NET Core projects. There is even some integration support for Bower in the Visual Studio tooling. However, for reasons that I'll explain later, I'm not going to use Bower in this module. You'll find lots of Bower content on Pluralsight if you want more information. I'm going to show you what I think is a simpler approach. Bower is a Node.js tool that you install with npm. And npm is Node's package manager. So if you're using Bower, you are already using Node and npm. Now the traditional use of npm is to install libraries and tools for Node.js. But over the last year or so, npm has also become more popular for managing front-end libraries. And npm is actively working on improving support for front-end libraries. This means if you want to use jQuery in your application, you can install jQuery with npm and skip using Bower and NuGet. Why would you do that? Well you might use npm instead of using Bower because one tool with one configuration file is easier than using two tools with two configuration files. And you might use npm instead of NuGet because for any serious JavaScript work these days, some amount of Node tooling is almost required. All the best tools, compilers, and minifiers, they are all tools that run under Node.js. And this is the approach that I will show you in this module. We will be using npm to download the front-end frameworks that we need and then use those frameworks and libraries like Bootstrap and jQuery in the application. So the next step is to understand how to set up Node and npm for our project.

Command Line versus Visual Studio

There're a few different ways that you can work with npm in an ASP.NET project. One approach is to use tooling and the support provided by Visual Studio. This is the approach that I will show you in this module. Another approach is to use Node and npm from the command line. The command line approach gives you flexibility and power beyond what the tooling in Visual Studio provides, but you may or may not need that power. There are other Pluralsight courses that can show you the command line interface. The Visual Studio approach that we'll be using will behind the scenes use a version of Node and npm that Visual Studio 2015 installs by default with the rest of the web tools. If you are experienced with the command line, I recommend you download and install Node.js from nodejs.org so you have more control over the environment. In this module, we will rely on the tools that Visual Studio has installed. And to see how this works as a first step, let's see if we can download the Bootstrap CSS framework.

Setting up npm

Inside of Visual Studio, we're going to see that working with npm is just as easy as working with project.json. You'll see there're a lot of parallels between project.json and an npm configuration file that we have to create because project.json manages our server-side dependencies, frameworks like the MVC framework. We're also going to need to add a JSON configuration file for npm to manage our front-end dependencies, and this is as easy as right-clicking the project. I want to add a new item, and this time I'm going to search the installed templates for npm. What I should find is a npm configuration file. Just like our ASP.NET project.json file has to be named project.json, you have to name this file package.json. I'm going to add it to the project. And one change we're going to need to make is we're going to need to change the name that is mentioned here. You'll notice there's a lot of the same information in package.json. Just like project.json has a version number and list of dependencies, package.json has a version number and a list of dependencies. But this name I have to change just because npm is a little sensitive about the name. Ideally, you'll use all lowercase characters, have no spaces in the name. Otherwise, a name that npm judges to be unsuitable will prevent npm from installing the dependencies that we need. And once I have this file in my project, I'm going to go ahead and save it. I want to call your attention to the Dependencies node in the Solution Explorer. Notice it is now saying Restoring. And this is one of the interfaces that Visual Studio provides to interact with npm. Just like our project.json file controls what is underneath the references, our package.json file can control what is underneath the dependencies. Visual Studio is now aware of this file, and currently we don't have any dependencies. We want to install Bootstrap. That will be a new dependency. Now I don't want to install Bootstrap as a dev dependency. Typically what you list as a dev dependency are the tools that you need for development and for building the application where the build would be tasks like minifying and concatenating JavaScript files together. Those are tools we need at development time. What we want to specify are dependencies. And you'll notice I get some IntelliSense help here. I want to install Bootstrap, so I'm going to type in Bootstrap. There're a number of different add-ons and extensions for Bootstrap. And just like in my project.json file, I can specify a version number. Npm has a syntax where I can tell npm, I want the latest version where the major version is 3. So install the latest version, which is 3.3.6, but I will allow you to install anything that is version 3 up to version 4. And I just need to make sure that this is a valid JSON file (include my comma there). Now I'm going to save package.json. Notice Visual Studio is restoring dependencies. This is just like saving the project.json file. And Visual Studio goes out and downloads packages. And now just by saving this file, I should have Bootstrap on my file system. I can right-click this node at any time and force Visual Studio to restore packages. And now the question is, Where is the Bootstrap.css file that I need? Well by default, npm installs everything into a folder that is named node_modules. You won't see it listed here in the Solution Explorer because, by default, it is hidden. And the idea is that node_modules is not really part of a project because it's not something that you check into source control. All you need to check into source control is the package.json file. And then when you download the code for this application, you restore the dependencies that are listed in package.json, and then you never have to check those files in. You can check the files in, but a lot of people go with this workflow, only check in the package.json file. If I come to the Solution Explorer window, there's a little icon, the Show All Files icon. I can click this, and now I can see my node_modules directory. Inside of here is where Bootstrap was installed, and under the dist folder, short for distribution, I will find Bootstrap.css both a full version and a minified version, source maps, everything I need to work with Bootstrap. In this module, we will only be working with the CSS. Some of the Bootstrap widgets require JavaScript support. And if that's the case, the JavaScript files are under the js folder. So if I want to use Bootstrap, I need to include one of these CSS files into my application. How can I do that when the CSS file is outside of the wwwroot folder, which is the only folder that serves static assets by default. Let's talk about that next.

Serving File from node_modules

One popular solution to the dilemma that we are in is to use a Node tool known as Gulp. Gulp is a task runner that executes in Node.js. You can use this task runner to create a build system for your JavaScript where the build will copy files underneath the webroot folder. You can also combine and minify files to optimize for a production release. I'm not going to use Gulp, but there are some fabulous courses on Gulp if you want to learn more, and vs 2015 includes integration and tooling for Gulp. If you have an application that uses a lot of JavaScript, I would suggest looking at Gulp. I'm going to take a different approach. All I need to do is serve up a few simple files from the node_modules directory. And later in this module, I'll show you how you can still optimize for production. But you might remember back at the beginning of this course, we added some middleware during the configuration of our application, middleware that by default will serve files from that webroot folder. If you don't pass any options into UseFileServer, it will serve from wwwroot by default. What I want to do is add a second instance of the file server or of the static files middleware, which is underneath the file server, which will serve up our files from the node_modules directory. So you can have multiple instances of the static files middleware inside of a single application. But I'm going to need to configure the static files so that it knows to serve files from node_modules. And although I could place that configuration inline here and start up that cs, I want to keep this Configure method relatively clean. So I'm going to write a new method, one that I'll call UseNodeModules, which will do all the configuration that I need. UseNodeModules just has to be an extension method for the IApplicationBuilder face. So let's go into the project and add a new folder for this class. It doesn't fit into any of the existing folders very well. I will call this folder Middleware. And inside of here, I want to add a class that can hold some extension methods. So add a class, let's call it ApplicationBuilderExtensions. And this class will have to be a static class so that it can hold extension methods. And I want an extension method called UseNodeModule. So a static method, it can return an instance of the IApplicationBuilder. That's a common convention for these types of extension methods. This requires me to bring in the namespace Microsoft.AspNet.Builder, and this will be an extension method for IApplicationBuilder. Let's call that app. Ultimately, I will return the instance of IApplicationBuilder. But before I do, I will use static files to install the static file middleware on this application builder. But I'm going to need to pass in options to tell the middleware to serve files from node_modules. So let's create an instance of the StaticFileOptions class. This is going to require me to bring in the namespace Microsoft.AspNet.StaticFiles. And one of the properties that I can set on this options is what request path to look at. I'm going to set this to /node_modules. This means that this static file middleware will only respond when the URL starts with /node_modules. Otherwise, this middleware just lets the request pass to the next piece of middleware. But when the request path does start with node_modules, now I want to serve up some files. And to do that, I have to set a FileProvider on these options. This FileProvider will be an instance of the PhysicalFileProvider, and this class is in the Microsoft.AspNet.FileProviders namespace. And when I construct a new PhysicalFileProvider, I have to pass in an argument that specifies the root of where this file provider will look on the file system to serve files. Notice in the comment that this should be an absolute path. That means it has to be a path like C:\ and then all of the directories that lead up to my OdeToFood project where it is running on the web server and then go into node_modules. The easiest way to get the full path to your application is to get hold of an object that implements the IApplicationEnvironment interface. I will call this parameter env. This is in yet another namespace, Microsoft.Extensions.PlatformAbstractions. Let's bring in that namespace. And this object will have a property, which is the ApplicationBasePath. That will be the full absolute path to the directory containing the project.json file, the root of my project. I just need to take this pat and combine it with the node_modules folder that is inside of this path, and I'll have the full path to where I want to root the physical file provider. The easiest way to combine these two pieces of information is to use the Path class in .NET. That's in the system.io namespace. I'm going to say Path.Combine, the base path with node_modules, and Path.Combine will make sure all of the symbols are correct and the path is built correctly. I will pass that path into the PhysicalFileProvider, and then I will set that provider on the FileProvider Property. And I almost forgot when I created this method to give this method a name. Let's give this method the name UseNodeModules. This should be everything I need to serve up files from the node_modules directory during development. So let me save this file and come back to Startup where we will invoke this method. And this method requires a parameter, an object that implements that IApplicationEnvironment interface. Where will we get that? We will simply ask for the runtime to inject that for us. So I want an IApplicationEnvironment. I'll need to bring in the namespace, the PlatformAbstractions namespace. And let's call this appEnvironment. And I just need to take appEnvironment and pass it to UserNodeModules. The last thing I need to do to make this extension method available is either bring in the namespace where the extension method exists, which is OdeToFood.Middleware, or to change the name of my namespace to be Microsoft.AspNet.Builder. Typically, you do not define a namespace that is the same as something that Microsoft provides. But it is a common convention that when you're providing extension methods for IApplicationBuilder that you go ahead and put those extension methods into the namespace where that interface is defined so that they are always available when someone is programming against that interface. I'm going to remove our unnecessary usings, save all my files, and let's just give this a try from the browser. What I want to do is go to localhost/node_modules/Bootstrap/dist/CSS/Bootstrap.css, and I can see that this request worked. And now we can start using Bootstrap in the application.

Styling with Bootstrap

Typically when you use a CSS framework like Bootstrap, you include a link to the CSS file in your Layout page. Let's do that and see if we can pretty up the application just a little bit. So inside of the Layout view and inside of the head element, let's add a link to a style sheet, and I'll paste in the URL to the Bootstrap.css file, paste that in as the href attribute. And now this isn't a course on Bootstrap, unfortunately, but let's use some Bootstrap components to improve the looks of the page, at least a little bit. One component that Bootstrap provides is a navigation bar. That's typically built inside of a nav element. The outer structure of that navigation bar is built by applying classes of navbar, and this will be a default-looking navbar. And inside of here, I typically use a fluid container to allow the navbar to stretch across the screen. And as part of the navbar, you might want to have a header. And inside of the header, most sites will use a navbar brand class, so navbar-brand, on an anchor tag that is a link to the root of the website or the opening page of the website. And we'll use the text OdeToFood. Now the user always has a place to go to click when they want to get back home. Let's also take all of this ugly UI that we built to login, logout, and register--I'm going to take this div and cut it and place it inside of the fluid container div, so after the navbar header but still inside of the container-fluid. And I want this to be part of the navbar, a navigation part of the navbar, but I want this to appear on the right-hand side of the page. So push this content out to the right. I can do that with navbar-right. If the user is signed in, I want to display their username, but I'm not going to put that into a div. I don't want any vertical space added. Instead, I'm just going to embed that here inside of the form. And if I give my form a class, a class of navbar-form, Bootstrap will make sure the form is vertically centered inside of the navbar, and the logout button is going to look like a usual browser button unless I apply some Bootstrap classes. Let's make it a btn-danger button so there's a little bit of red in the color. I'd also like these links to appear as buttons and not just links. That will provide a more consistent look to the application. So let's give these a class of btn, a default-looking button. Let me make them extra small buttons. And this last class, navbar-btn, that will again make sure that this content is vertically centered inside of the navbar. I'm going to copy that class and also paste it here for the Register link. And let's just save the file and see what damage we've done so far. So back in the application, let me refresh the Edit page, stretch the browser out so we can see things a little bit better, and I have something which is now arguably a marginal improvement from what I had before. But I now have a link to get to the home page. I now have a better-looking button that I can use to log out. And then I have the buttons that I can use to log in and register. Let's also see what we can do here for the home page to make it look a little bit better. Typically, I want my content rendered inside of a container. So I'm going to use RenderBody and also place the footer inside of the div that has a class of container, save the Layout view. and most of what we are seeing here or at least the list of restaurants, that is coming from the Summary view that we built earlier, Summary.cshtml. Let's try to improve the looks here just a little bit. I'm going to give this section a class of panel panel-default. This will set each individual section off from one another a little bit more. And instead of using an h3 here, let me have just a normal div but make this a panel-heading. Some people would call these Bootstrap panels cards. And we're going to have a heading and a body on each card. This div can represent my panel-body. And let me add some text so we know we're looking at the cuisine. And let me take these links and place them inside of the panel-body. And we can make these links appear a little bit better if we make them buttons. Let me show you one trick. You might know this about Visual Studio. But I'm going to hold down the Alt key and make a columnular selection, so drag the mouse down so that I now have two lines of code selected. And now when I type, I can type into both lines because I want to make these both btn btn-default. And let's save the Summary and refresh our home page. So we could still really use a splash of color here, but you can see how easy it is to add bootstrap to the project, include Bootstrap in the Layout view, and then start using Bootstrap classes to change the appearance of the user interface. We could go through and do the same with our forms like the Edit forms that we have. I'll leave that as an exercise for you. But what I do want to have happen on the forms is some client-side validation. I want JavaScript and the browser to be able to tell me that something is wrong before I even send a Post request to the server. Let's look and see how to do that next.

Enabling Client-side Validation

Inside of the Edit form, let's inspect this input for the restaurant name. You might remember we built this using tag helpers, and we looked at this markup before. The markup includes these attributes that start with a data-, like data-val="true". These are validation attributes that the MVC framework will render by default, and they include all the information to enforce those data annotations that we applied to our model, like the annotation that said the max length of a restaurant name is 80 characters. You can see that value 80 is in the data-val-maxlength-max attribute. Now the browser itself doesn't know what to do with data- attributes. The whole idea behind data- attributes is that they're custom for your application, and your application will have to provide some JavaScript to act on those attributes. Fortunately, Microsoft provides some JavaScript that we can use to consume this validation metadata and enforce validation on the client, the script that Microsoft includes built on top of a popular jQuery plugin known as jQuery Validation. And this jQuery plugin, of course, depends on jQuery. So what we need to do to get client-side validation to work is take an explicit dependency on three script files--jQuery, the jQuery Validation plugin, and then the Microsoft script is known as jQuery Validation Unobtrusive. So let's swing back to our package.json file. We're going to add some additional entries here, and we will see those entries appear inside of node_modules and inside of the dependencies for the application. I want to install jQuery. We'll take the latest version. I want to install jQuery-validation. I'll take the latest version there. And then the Microsoft script is jQuery-validation-unobtrusive. We'll take the latest version there also. Let me save this file. Visual Studio will start restoring these dependencies. And when that's complete, those libraries will be available to me from the node_modules folder. Now I need to get these scripts into the application, at least on the page that displays the forms that need client validation. And for some applications, people like to include these scripts only on the pages that need validation. To do that, you could always have another section in your Layout view, perhaps call it Scripts. And then a Razor view that creates a form could make sure to render script tags that point to jQuery Validation into that section. Or you could just take the approach that these scripts will eventually be needed by most users. So let's just get them out of the way by loading them on the Layout page, and then they'll be cached and available for every other view in the application. I will, however, load those scripts at the bottom of the page so that the browser has a chance to download the CSS and the content and start displaying a UI. I need to add the scripts in a specific order. jQuery has to come first before any plugins. So from the node_modules directory, there will be a jQuery folder that just like Bootstrap has a distribution folder. And inside of there will be various flavors of jQuery. I'm just going to take the full script, not the minified script. And once I have my double quote in the appropriate location, I will make a copy of that script tag because the other two scripts are very similar. For jQuery Validation, I go to the jQuery-validation folder. It also has a distribution folder. And the name of the script file inside of there is jQuery.validate.js. And for the Microsoft script, which is jQuery-validation-unobtrusive, that's the name of the folder, it has a slightly different layout. There is no distribution folder. The script I need is right there, and that is jQuery.validate.unobtrusive.js. Those are the three script files I need. Let me save the Layout view, come back and refresh this Edit page, and now I don't see any errors, so I think all three scripts have loaded successfully. What I should be able to do now is start providing invalid inputs and trying to post the form with the Save operation, and the client-side scripts will detect that invalid data and prevent the form from posting back to the server instead giving me validation messages without a roundtrip to the server. And now as I type interactively, the validation message will come and go. And these scripts work for all of the common data annotations that you might use, like Required and MaxLength. And all you need to do is get those three scripts onto the page, and the metadata and the validation rules are taken care of for you. You can also write custom client-side validation rules. But now that we see how all of this works, you might be wondering, What about when we go to production? Let me show you a couple of tips for that.

Using CDNs and Fallbacks

For applications that use large amounts of JavaScript, the typical best practice is to build your JavaScript, that is use a task runner like Gulp and concatenate all of your JavaScript files to together, minify your JavaScript, and try to minimize the number of script downloads that you have on a page. You might also consider putting your custom script into a content delivery network, a CDN. A CDN can typically deliver script files faster than your own local servers. But you always have to do some testing to reveal the true numbers. On the other hand, if you have an application that just relies on a few popular third-party scripts, like jQuery, you might consider just going the CDN route. And that's the approach I'm going to show you. We're going to use a content delivery network. This is a CDN run by Microsoft. You can find out more about it by going to ASP.NET/ajax/CDN. On this page you will see a list of all the libraries that are hosted on the Microsoft CDN. This includes jQuery, jQuery Validation, also Bootstrap is on this list. If I click on one of these links, it will give me the exact URLs that I need to use to bring in, for example, a specific version of the Bootstrap.css file. So one way to use a CDN is to simply take these URLs and copy them and paste them into your Layout view. I could replace this source, for example, with the CDN source for jQuery. But in some scenarios, it's nice to use node_modules for development and then switch over to use a CDN when you put the application into testing or staging or production. And that's the approach I want to show you. We're going to take advantage of two features that we've talked about previously in this course. The first is tag helpers. There is a tag helper named environment. And what environment can do is choose to emit the markup that is inside of the environment element or not. It all depends on the name of the environment that you are in. So if I say environment name="Development", these script elements will only be rendered when I am running in an environment with the name of Development. And when we run with Visual Studio, whether it's in the debugger or not, by default we are set up to run in a development environment. If we deploy the application to some other server and there is no environment set, we'll be running in production. So what we can do is if we only want to serve these files from node_modules when we're in development, we'll set up one environment with develop, and we can set up another environment for staging and production. Now because this bit requires a little bit of typing, I'm going to save you the pain of watching me type all of this out, and I'm just going to throw in some code that you would find if you generated a new ASP.NET full web application. In a full web application, they have the scheme set up where files can be either served locally, or if we are in staging or production, we're going to bring in the jQuery script from the ASP.NET CDN. We can also do that for jQuery Validation and for jQuery Validation Unobtrusive and also the Bootstrap resources that we might need like the CSS files and the fonts and the Bootstrap.js file. Two other features that I'll call your attention to. You can also use tag helpers to set up a fallback source. And the way this works is that if your application is up and running but the CDN is down, the user might have a very confusing experience because your application appears to be running but it might have no style sheets and no JavaScript because the CDN is currently unreachable for some reason. That's when a fallback source becomes useful. A fallback source works in combination with this fallback test. These tag helpers will emit some additional JavaScript to test to make sure that this script file was loaded from the CDN. They will do that by evaluating this expression. When you load the jQuery script, it should produce a global variable named jQuery. And in JavaScript on the browser, global variables hang off of the window object. So if window.jquery is defined, we know that jQuery was loaded successfully. If not, perhaps the CDN is down, and then we will go to the fallback source, which will just try to pull jQuery from the node_modules directory. Any you can see that the fallback source and the fallback test, they are set up for each of our scripts. We can also set up fallbacks and tests for CSS frameworks like Bootstrap. And now we have the best of both worlds. When we're working locally and doing development, we have scripts that are served from our file system that are easy to debug. When we push to production, we have a different set of scripts that are minified, they're served from a CDN, and they should be as fast as possible. But just in case that CDN is down, we still have a fallback.

Summary

In this module, we learned how to use the Node package manager from Visual Studio to install front-end frameworks like Bootstrap and libraries like jQuery. We added these resources to our page and saw how to use some Bootstrap classes and also enforced client-side validation rules. Finally, we learned about the environment tag helper and how it will allow us to use local scripts for debugging and content delivery networks for production. And this concludes my course on ASP.NET Core. I hope you enjoyed the course and can build many successful applications in the future.

Course author

	
Scott Allen

 Scott has over 15 years of experience in commercial software
 development and is a frequent speaker at national conferences,
 and local user groups. Scott is a Microsoft...
Course info

LevelBeginner
Rating
(394)
My rating
Duration5h 15m
Released12 Mar 2016
Add to playlist
Share course

