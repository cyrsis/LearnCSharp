
Building Applications with Aurelia
by Scott Allen

Aurelia is a next generation JavaScript framework using the newest versions of the JavaScript language. In this course, we'll demonstrate the simple conventions to follow with Aurelia to build a rich web application.

Start CourseBookmarkLive mentoring
Table of contents
Description
Transcript
Exercise files
Discussion
Learning Check
Recommended
An Introduction to Aurelia

Introduction

Hi. This is Scott, and I'm pleased to introduce you to Aurelia. Aurelia is a JavaScript framework for building applications with HTML, but it's not like frameworks we've used in the past. Aurelia is designed using the latest specifications for JavaScript on the web, which means Aurelia takes advantage of ECMAScript 2015 features and even features beyond today's current specs. These features help to give us a framework that is in many ways simpler and more elegant compared to frameworks of the past. Since Aurelia builds on these cutting edge features, we do need a few tools to help us deliver applications to the browser, and in this module I want to give you an overview of Aurelia, as well as cover the tools and the setup we will use in this course. First, let me give you a quick example of what Aurelia can do.

Aurelia in Action

Aurelia is an open source framework. You can find all of the source code at Aurelia's home page, GitHub.com/Aurelia and one of the repositories in this list is a simple application named app-contacts. You can find this repository, clone this repository, and there's just a few simple steps that you need to take to get this up and running. If you already have Node.js and some of the Node.js tools installed, there are even fewer steps that you have to follow. And this is what the application looks like once you get it up and running. First, there is a splash screen. It's very easy to show a splash screen to the user while your scripts and data are loaded for the application. In this case, we're loading a list of contacts. These contacts are displayed on the left-hand side of the screen. I can click one and we've given Aurelia instructions to load a detail view of that particular contact on the right-hand side. Notice that the URL has changed. It's now #/contacts/1. This is something that will look very familiar if you've used any sort of JavaScript framework in the past. Aurelia will manage the browser history that allows me to use the back and forward buttons, and I can configure Aurelia to take specific actions when it sees specific URLs up here that's done through a routing component. Also notice there's a simple animation that displays at the top of the browser whenever I change the contact, and the way that we get this information onto the screen is to use data binding. So somewhere inside of a JavaScript object, I have a list of contacts. I'm binding them onto the screen. There's also two-way data binding, so if I want to edit Owen's first name because I think it's misspelled, then I can type in my changes and click Save, and Owen is now updated. Let's take a quick peek at the code just to get some ideas of how this comes together. First, let's look at contact-list.html. This is an HTML template that we've given to Aurelia. You can think of it as the view in the model-view ViewModel pattern. We've told Aurelia that it needs to repeat this list item, once for each contact in a set of contacts, and that is what is stamping out our user interface here on the left. Inside of that list item, we're building an anchor tag. We're going to show the contact's first name, their last name, and their email address. So those are simple binding expressions that you see there. Let's also look at the view for showing the details of a contact. Again, we have a template and now I have two-way data binding. Here's an input where we will show the user's first name and also allow the user to edit that first name. We're going to bind the value of this input to our view model's contact property that will have a firstName property that we're using here. At the bottom of this template, I have the button to save changes and when the user clicks on this, we're telling Aurelia to invoke a method on our model called save. Let's take a quick look at the view model. That would be contactdetail.js, so you can see there's a naming convention that is here and that's something that we'll see in Aurelia time and time again. Aurelia favors convention over configuration, so if you just name things appropriately and put them in the right places, everything will work for you without having to write as much code as you might have with other frameworks. Here we're looking at some JavaScript that might seem unfamiliar if you're not up-to-date with the latest JavaScript specifications. ECMAScript 2015, which was previously called ECMAScript version 6, it introduces a module syntax so I can import abstractions from other modules and I can export abstractions from my JS file. So here we are exporting a view model class. Classes are also new in ECMAScript 2015. A class can have a constructor. Aurelia uses an inversion of control container to inject dependencies into my view model when it creates my view model. Aurelia will also automatically call an activate method and give me some information about the environment that I'm operating in. This allows my view model to initialize itself. In this case, my view model is going out to a web API, getting some details about that particular contact, and then creating that contact property that we're binding against from the HTML. Down here's the save methods. So when I click the Save button, it will invoke this logic to save my contact and then publish an event that the contact was updated. That's done through an event aggregator that Aurelia provides. So if all of this seems overwhelming, don't worry, we're going to go through all of these different pieces that we've talked about step by step and build our own sample application, but I did want to give you the quick overview of Aurelia so you could get a flavor for what this framework is about and the types of problems that it solves. We're trying to build an application for the browser that uses all the latest features of HTML and JavaScript. That's what Aurelia can help us do. We'll be looking at some of the tools that we can use with Aurelia to help us build those types of applications.

Tools We Will Use

As we saw in the last clip, Aurelia uses new features of the JavaScript language and it is expected that we'll be writing our application using the same new JavaScript features that Aurelia uses, features like modules and classes. And that means we're going to need some tools for the immediate future, tools that can transform our code into older versions of JavaScript that run across all the browsers that we want to support. We don't need a lot of tools, and some of these tools you might already be familiar with. The first tool that you'll need, of course, is a text editor or IDE. You can use Aurelia in any environment and with any editor. So if you want to use Sublime, or Atom, or vi, or Visual Studio, they will all work. And of course, you can use any server side technology stack that you want, ASP.NET, or Rails, or Node. For this course, I'll be using Visual Studio and ASP.NET, but we won't spend a lot of time on the server. We will focus on writing client type code. In addition to an editor, you will want to have Node.js installed. This is because most of the best JavaScript tools are written for Node and Node is a simple lightweight install. Just come to nodejs.org and click the Install button. You can have Node.js running on Windows, or OS X, or Linux. Once node is installed, you should be able to open up a command prompt or a shell and type node that will start the ripple for Node and I'll just do a quick test, yes, node can add two plus two, so I know node is successfully installed. And when you install Node, you will also receive a program called NPM, the Node Package Manager. Npm allows us to download additional libraries and tools that we will be using to deliver our application into the browser. So if Node installed successfully, I should also be able to type npm, and since I didn't give npm a specific command, I just see the help text, but I can see that npm is working. One of the tools that I will install with npm is a tool called jspm. Jspm is a package manager. It's similar to Bower if you have used Bower. Jspm allows me to download libraries and packages that I want to use in the browser. For example, if I was developing something with jQuery, I can use jspm to install a version of jQuery or Bootstrap, or in our case, we're going to be installing Aurelia. And jspm goes beyond just being a simple package manager because jspm will setup our environment to load JavaScript code as modules and work the way that we want to work in this world of ECMAScript 2015. Jspm can even compile ES 2015 code on the fly into ES5 code as it's loaded into the browser to things that weren't even in browsers that don't understand these new standards. I'll show you exactly what I mean in just a bit, but for now let me show you how easy it is to install jspm. Once you have Node and npm running, I can say npm please install jspm, and do that with a -g, do it globally. That means I should be able to open up a shell or command prompt anywhere on this machine and type jspm to run this package manager. And now that that installation has completed, I should be able to type jspm and these are all the available options for jspm. The thing will be doing the most is jspm install, but we'll get to that. And there is potentially one other tool that you will need to install. Jspm relies on a command-line git client, so if you can open up your shell and type jspm and you can type git, and both of those programs execute without an error, you are set and ready to go. If you don't have a command-line git client, you can always come to git-scm.com and on this page you will find downloads where you can get a git client. Now just remember you'll want a command-line git client. But those are the tools that we need. We need Node, we need Git, we need jspm, plus we need an editor. So with those things in place, let's write our first Hello World program.

Hello, Old World

To get started, we're going to need some sort of web application and web server that can at least serve up static files, HTML files, and JavaScript files. That's all we're going to be working with for now. So you can do this with any technology stack that you like. Just find the simplest possible path to create a directory structure where you can edit HTML files and JavaScript files and have them served up to a browser. I'm going to be using Visual Studio and ASP.NET. The simplest path for me is to select File, New Project, tell Visual Studio that I want to create an ASP.NET Web Application, I'm going to call it Movies, and I'm going to select the ASP.NET 5 Empty type of project because this is the project that will setup the bare minimum directory structure and include only the files that are needed for the most basic of ASP.NET sites. And once that is ready, I even want to delete things like the project readme, which I don't really need. And now I'll just point out that in ASP.NET 5, this wwwroot folder, this is the root for my web server. So if I have static files that I want served up, files like HTML files and JavaScript files, they need to be in this wwwroot folder. Other environments might call this public or might call it assets. I'm going to create an index.html page inside of wwwroot, and this is something that can be served up when I'm ready to view this application in a browser. So it's currently blank. Now before we even get to saying hello world from Aurelia or introducing how to use tools like jspm, I want to put up a hello world message using JavaScript the way I might have done it in the past. So let me add to this project a JavaScript file. I will call it app.js, it represents my application. And I actually want app.js to use some logic from another JavaScript file. Let's call it greeter.js. Now greeter.js will be responsible for the low-level details of getting some message onto the screen. App.js is more for my application logic, it's going to orchestrate the greeter and tell it when to put this message on the screen. So greeter might be responsible for managing the actual text of the message and perhaps declaring a function, let's call it sayHello, that will raise an alert with that message at the appropriate time. And now what I want the ability to do is the ability to use that from app.js to figure out when to call sayHello. Now in order to get all of this to work in yesterday's world of JavaScript programming, I'd have to have intimate knowledge of the relationship between app.js and greeter.js, and I'd have to be very careful and make sure that I include greeter.js on the page before app.js because app.js requires some of that logic that's inside of greeter, but if I get everything correct and I come out to my web browser, I do get the alert on the screen, so everything is working. But there are a couple problems here. One problem is that I had to order my scripts correctly in the browser. I had to know what the dependencies were between those scripts. Another problem is that over here in greeter.js, I've actually created two globals here, one called message and one called sayHello. I can see that if I flip into the developer tools for this page and type in message, because that variable was not enclosed inside of some sort of scope, it was made a global variable and it's available anywhere. It would be nice to have a little bit of encapsulation around this code and not the type of encapsulation that you get by writing these hideous, immediately invoked function expressions and wrapping all my code inside of that, and it would also be nice for app.js to have the ability to say something like I need to import something called sayHello from another file, from another module. This is something that jspm is going to allow us to do ultimately because it's going to put the runtime pieces in place that understand syntax like this and will know how to go out and fetch abstractions that I have defined in another file or another module. Let's take a look at that next.

Hello, New World

My goal for this clip is to get jspm initialized and have the pieces in place so that I can start to use syntax like import sayHello from greeter. So the first thing I'll need to do is move into the root of this project, and this specific project is under a source folder, it's called Movies. This is where you can see my project.json file and the wwwroot folder, and I will type jspm init. We should be able to do that because if we npm install jspm with a -g switch, I'll be able to execute jspm from anywhere on the machine. And what jspm will do to initialize this project is ask me a series of questions. For the most part, I can take the default answers, but there are a couple questions where I want to make sure you choose the correct answer. So the first question is should jspm create package.json? I want to say yes. I'll show you what is inside of this file in just a little bit, but it is the file that both jspm and npm will use to track the packages and libraries and frameworks that you have installed for this project. So ultimately, when I jspm install Aurelia, the fact that I'm using Aurelia will be recorded in package.json. And then other developers who grab the source code to this project, they can just run jspm install without any other parameters and jspm will install all of the libraries, and utilities, and frameworks, and packages that are listed in package.json. So I'll just press Enter for that first question, press Enter for the second question, and I'll jspm to do both of those things. This third question is very important. The wording is a little bit strange, but it is essentially asking me from the project's perspective where is your public folder path, that is, where do you serve static assets from? And I am serving static assets from wwwroot. So that is my answer to that question. I will take the default answer here. I'll allow jspm when I install something to install it into a folder under that public folder path. It's a folder called jspm_packages, so when I install Aurelia, ultimately all the source code will go there. I'll also allow jspm to add a config.js file there. We'll see what that does in just second. I'll tell jspm to yes, please create that. This question is asking me what is the URL that a client would use to get to that public folder, and it's just the root of the website, so the / answer is fine. And then I need to pick which transpiler I want to use. So there are a couple projects out there, both Traceur and Babel, that have the ability to take ECMAScript 6 and ECMAScript 7 code and transpile it or transform it into ECMAScript 5 code, which will work in all sorts of browsers, even IE 9. And the compiler I want to make sure that I use is Babel, which is the default selection for me, so I will just press Enter there, and now jspm will go off and download some things that are needed for this project. And now, let's switch over and see if we can get this new syntax to work. I'll explain what's happening behind the scenes, but before I do that, I just want to go into index.html, and the important thing to understand about jspm is that it's not only a package manager, but it also installs the scripts that will function as a runtime environment for my application. These are scripts that can dynamically transpile JavaScript on the fly and also go out and dynamically load modules. And one of the things I'll be able to do with jspm is I no longer have to order my scripts and include all my scripts on the page at once. I'm going to get rid of that code. Instead, I'm just going to load two files, one which jspm has installed for me, and it's under jspm_packages and it is called system.js, and the second thing that I'll need to place on the page is this config.js. This is a file that is created by jspm, and it essentially contains the configuration information needed for my particular project so that system.js can load up my application and the libraries that it requires. I promise we'll take a look at what is in config.js in just moment, but for the most part it is opaque to you when you are developing an application. Jspm manages this file and except for setting perhaps a couple optional transpiler settings, you never really need to go in and edit this file, but is the configuration for system.js, and system.js is a universal dynamic module loader. It understands how to load ECMAScript 2015 modules. It also knows how to work with AMD modules, which you've might have used in the past if you've used RequireJS, and it even knows how to load CommonJS modules. And one way I can tell system.js to load a module is to use an API that it provides off the system global called System.import, and I tell it that I want to import a module called app. That will send system.js off looking for something called app.js that's in the same folder. I don't have to use the file extension here. I don't have to say app.js, I can just say app. And if I were to take my app.js and place it in a different folder, maybe like a main folder, I can use a relative path in front of my module name, so this would be saying get to the main folder from here and then look for app.js, but my app.js, it's right in the same folder as my HTML file. So now system.js will go out and grab app.js, and app.js says I need to import something from another module, a module called greeter. So again, not greeter.js, just greeter. You'll start to think of your JavaScript files not as script files that you have to include on the page, but as modules, and these modules can be referenced from other scripts using import statements. In order for this to work, greeter.js has to export a function or an object or multiple abstractions and give other modules the ability to import these exports. Everything else, by the way, will stay private. This is one of the beautiful features of ECMAScript 6, the fact that things will be private by default and only those things that I export will be public. This means I don't need to use an iffy to control the scope of different things. It also means I don't have to create some sort of global object that I can hang things off of unless I want to. Well let's save everything and come back to the browser, and refresh, and my application still works. It still pops up that message box Hello, and now let's try this message again, and I can see that now message is not defined, and that's because again, greeter.js it is loaded as a module, and unless I export something, it's not going to be available for the outside world to see. It's a private implementation detail. And what we're going to find in this new world of ECMAScript 2015/ECMAScript 6, and when using frameworks like Aurelia is that the designers of these next generation frameworks, they're going to design modules and these modules are going to export specific abstractions, and classes, and functions, and variables that you might need to import into your application to be able to use them, and this is dramatically different than how we have used JavaScript for the last 15 years. So now that we can see this code working, I'll explain just a little bit about what jspm and system.js are doing behind the scenes, and then we'll be ready to jump in and pull in Aurelia and create our hello world with Aurelia.

Behind the Curtain

Let's talk in just a little more detail about what is happening in this project and dispel some of the magic that's happening. We ran jspm in it earlier. Jspm then created a jspm_packages folder in our web root folder. This jspm_packages folder is where jspm will install libraries and frameworks that we want, including the script files for Aurelia when we get to Aurelia, but jspm also installs some libraries and files right from the start when we use jspm in it. One of these files is system.js. As I mentioned earlier, this is a universal module loader, and it relies on another file that we see inside the web root folder, the es6-module-loader. These files are providing an API that is based on future specifications for module loaders in the browser. So we're not working with a library that has an API that someone came up with on their own, we are working with a proper JavaScript module loader that gives us an API and a runtime for today's browsers that should match the API and runtime provided natively by browsers of the future. System.js and the ES6 module loader are what we call polyfills. They are filling holes in the browser until all the specifications are final and all the browsers match the specification. Specifically what system.js will do is provide a standard global object that is named System, we can reference it from our scripts, and System provides an API to import and load JavaScript modules. Here we are asking for the module named app, and if you've worked with AMD or CommonJS modules in the past, this syntax is very similar. I don't need to specify the .js extension. I just ask for app and the module loader will find app.js in the same folder, in fact, System can find many modules because I've included both system.js and config.js on this page. Config.js can be a little scary when you first see it, but the good news is that you don't need to maintain this file, other than perhaps changing a few options, it is jspm that will create and maintain this file. And this is one of the reasons that jspm is a useful package manager in this new world of JavaScript, because not only will jspm install a framework like Aurelia and put it on my file system, it will also make entries inside of config.js so that at runtime, the module loader will be able to locate Aurelia and make the right kind of HTTP request to fetch JS files. You can see there's all sorts of information in here about versions and paths. So while system.js provides the module loading, config.js provides the mapping between framework names and locations on the file server. And that's everything that we need to use standard JavaScript modules today, and modules are fantastic, they really change how you think about putting together an application as we'll see with Aurelia, but there is one more piece that has to happen when these chunks of JavaScript code like an app.js load. They have to be transformed from this future JavaScript syntax into ES5 syntax because not all browsers understand this particular syntax. Unfortunately, the module loader can transform this code on the fly as it is loaded from the server. It's doing that with the Babel transpiler that we selected when we ran jspm in it. Later in this course, we will look at transpiling and bundling files to get better performance on the client, so we'll have most of the work happen before the script gets loaded over HTTP, but for right now, let me flip over into the application. And in the Chrome debugger, you can actually see the code before and after. Here if I open up app.js, this is the source code that I wrote, and I can set a breakpoint on sayHello and I can refresh, and I can actually step through the code that I wrote and I can step into functions and I can inspect variables and all of this is through source maps that are provided. So the development experience is great, but I can also see here in app.js saying eval. This is the transformed code that is actually executing in the browser. It is not the prettiest code, but I would rarely have to dig into this code because I can debug and inspect variables through app.js, the original source code file that I wrote. So I hope this gives you just enough idea about what is happening inside of jspm packages and config.js and system.js to feel comfortable using this technology. It's all here really to open up the world of ECMAScript 2015 and make it available to use today, even on older browsers that don't understand this new specification.

Hello, Aurelia!

Now that we know a little bit about what's happening behind the scenes, let's get started with Aurelia. The first thing I will do is jspm install the aurelia-framework. This will bring down the core of the framework, everything I need to do data binding, display HTML templates, and it's the very basics of the framework, and I'm also going to jspm install aurelia-bootstrapper. Aurelia is designed with very small independent modules, so even the bootstrapping piece which will launch my application, that's in a separate module that I install, and right now jspm is bringing down all of the scripts that I need placing them inside of jspm packages. It's also going to update that config.js file, so that the module loaders will be able to find these different pieces of Aurelia. And once I have the Bootstrapper in place, what I'm going to do is no longer import my application module. Instead, I'm going to System.import the aurelia-bootstrapper, because like many frameworks, the framework really takes control. It's going to manage the browser, manage history, manage routing, and at the appropriate point is going to call into my application, so I need the Bootstrapper really to load my application. And the first thing the aurelia-bootstrapper will do, if I have given it no other information, is to try to load the first view model for the application, and it will do that by trying to load a module called app, and I already have an app.js. I just need to make this into a view model of the type that Aurelia would expect. So if you're not familiar with design patterns like model-view ViewModel, it is one of those UI design patterns that provides a separation of concerns much like model view controller will do. What Aurelia wants to do is find a view model for the application and to load that, and to also find a view for the application and load that too and then tie the two together, but first I'm going to need to write the view model. This can be a simple JavaScript class. And in this version of JavaScript, a class can have a constructor, and in this constructor I'm just going to initialize a message field to say Hello from Aurelia, and I will save this file. And again, if I'm going to use the Aurelia default, this has to be named app.js, that's what the Bootstrapper will go looking for, and then it will go looking for a view that can present that view model, and by default that view will have the same name, in other words, app, but in this case, it's going to be an HTML file. Now when I create a new HTML file in Visual Studio it likes to think I'm creating a full HTML file, but I'm really just creating a fragment. In fact, I'm creating an HTML template, and in this template I want to display the message for my view model. I can do that with a simple binding expression here ${message}. So very simple binding expressions. And the last thing that I need to do is tell Aurelia where it's going to load that view into the DOM, and I can do that using an attribute and telling Aurelia here's where to load the application view and it will put it into the body. So now my module loader will load up aurelia-bootstrapper, Bootstrapper will go looking for the app module, which is now nested behind app.html. Aurelia will construct an instance of this view model, it will load the view, it will tie the two together, find this binding expression, and if we've done everything correctly, I should be able to come into the browser and refresh. I can see some Aurelia logging messages going by in the developer console, and here's our Hello from Aurelia. And what's nice is my application is just using plain JavaScript and some plain HTML with some special attributes and data binding expressions mixed in. Now ultimately in this course, I want to show you how to do things like two-way data binding and how to make a call to the server to receive some data, and we'll be taking data in JSON format and exposing it from our view model and binding into the view, but for right now, let me just show you a few other simple things that Aurelia can do. If your view model has an activate method, Aurelia will automatically call this and we'll see later how we can use activate to retrieve some information about the environment that we're operating in, things like routing parameters that can influence the types of calls that we need to make to the web server to get information back, and let's say we want to give the user the ability to change this message. Eventually, I'll show you how to do two-way data binding with Aurelia so we could provide an input text box here and allow the user to type in a new message, but for now I'll show you something that we can do with a button. If I create a button that will show the text Change Message, the question is how can my view model find out when the user clicks this button. I can do that by adding a click.trigger attribute. This is like a binding expression that tells Aurelia when the user clicks this button, please invoke this method on the view model changeMessage. So now let's go back to app.js and add that method. I will say changeMessage is a method that will change this.message to be Goodbye. Let's save all these files, refresh the browser, and I see Hello from Aurelia and I see Goodbye. And this Hello World example, while it's simple, really represents the essence of Aurelia. I'm going to be able to write my application using the new features of JavaScript. Features like classes and modules, which means I don't have to use strange syntax inside of my JS files to make sure that variables and other things that I'm defining escape into the global scope. Here I'm simply exporting a simple class called app and Aurelia is going to pick that up, construct it, call the activate method, and then bind data and behavior between my view, which is responsible for presenting information, and leave this nice, simple view model class back here with simple JavaScript. It's responsible for logic, and fetching data, and reacting to an external stimulus like a button click. And you'll notice I don't have any crazy framework Aurelia code inside of my application view model. It's just plain simple JavaScript that would be easy for me to import this into a unit test and write a test, for example to ensure the changeMessage actually changed the message. And all I needed to do here was follow the Aurelia conventions. Once I import the Bootstrapper and tell Aurelia where to grab control of the DOM, it will go out and load my view model and view pair and start the application running.

Summary

In this first module, we saw how to set up and use the jspm package manager. We'll be using this tool again in the course to install additional Aurelia features that we will use. We also saw how jspm gives us a runtime that includes a module loader, and modules are going to be a key part of JavaScript moving forward. It's much easier to scale up complex applications and keep details hidden between different components. And finally, we bootstrapped Aurelia and created a simple Hello World application. We'll build on this example in the coming modules and create an application that can display and edit movie information. Along the way, we'll learn about a number of wonderful features that Aurelia provides.

Views and View Models

Introduction

Hi, this is Scott, and in this module we're going to dive into the view and view model relationship in our Aurelia application. You'll consistently work with view and view model pairs when you're building applications with Aurelia, and in this module I want to make sure that you see how to work with dependency injection, how to make HTTP calls to the server to fetch model data, and there will be more in this module focused on views and view models.

Model View ViewModel

A key concept in building software is the idea of maintaining a separation of concerns. It doesn't matter if you're using object-oriented design or functional decomposition, building a server application or desktop application, you always want to write software so that you break a complex solution down into small manageable pieces where each piece of code has a single responsibility to focus on, and no single piece tries to manage multiple areas of complexity. This is the idea behind the presentation design pattern known as the model-view ViewModel. In this module, we will fetch model data from an HTTP service, the model data will be movie information, we'll attach that model data to a view model, which is a model object specifically constructed for the responsibility of presenting data to the view and handling the behaviors associated with the view. For example, the view model can contain the logic associated with button click events. The view, on the other hand, ideally has no logic inside. It contains only the markup for the UI and some simple binding expressions that glue the view to the view model. So in short, the view has no logic while the view model has no idea of the presentation format. This is the separation of concerns that we want to follow. Let's look in more detail at how to apply this pattern with Aurelia.

Composing ViewModels

We're going to continue to build on the application that we created in the introduction module, and in the introduction we learned that Aurelia will load a view model named app by default and associate that view model with a view named app. Both of these files are in the same folder as our index.html start page. Later in the course, we'll see how we can configure Aurelia, we can load a view model of our choice, a view model with a different name, and even configure Aurelia to load a view model based on information in the current URL, but for now I just want to show you if I come in and I rename my app.html and my app.js as app2, if I try to run my application, we will ultimately get an error from Aurelia, app not found. It tried to go out and load app.js, didn't find it, so it threw an error that it could not find that module. So let me rename this back to app so it will work. And now to show you how deeply the view and view model pattern is ingrained into Aurelia, let's look at the custom compose element. With Aurelia, you can create your own custom HTML elements. We'll look at how to do that later in the course. For now, just know that Aurelia does define some custom HTML elements by default. These are elements that you might use frequently with Aurelia, and one of these elements in the compose element. Composition is a powerful concept in software. It allows me to build up something that is complex out of simple pieces, and what the compose element will do with Aurelia is tell Aurelia that this particular piece of the presentation is going to be delegated to another view model, and this view model can be independent of the app view and the app view model. We can also have them work together. We'll take a look at more advanced scenarios later in the course, but I want something that will show the current date on the screen, so I'm going to ask Aurelia to load up the view model currentDate and its associated view, and place the view into the DOM here where I have this compose element. And this means inside of wwwroot I will need to add, first of all, an HTML file. Let's call it currentDate to match that module name, so currentDate.html. I don't need a full page, I just need a template. And I'm also going to need the associated view model. So I will add also a JavaScript file, currentDate.js. And just like I did with app.js, I'm going to export a class that will be my view model. Let me also call this CurrentDate and just have a simple constructor that will initialize a date field, and I'll just call new Date and then ask for a date string. And that's the responsibility of the view model to put together model information like the currentDate and to hold that information and make it available for the view, which will use simple data binding expressions to place that information into the appropriate place in the user interface. So if I save all the files and refresh the application, I now have a user interface that is based on two separate and independent view models. This new view model is currentDate and that's also the name of the view. By default, Aurelia will just match those up. And now that we see how that works, let's go back to our app view model and see how to do some more interesting things with the server API.

The HttpClient

What we want to do next is call a web API that I have set up. It's under /api/movies. This will return movie information in JSON format, and I can also update and create movies. In ASP.NET 5, I've done this by setting up a controller that talks to a SQL Server database using the Entity Framework, but you don't need to set up all that infrastructure to follow along with this module. What you could do in your public folder is just create a JSON file. Here I've created a file called movies.json because in the browser and from JavaScript, they really don't know if they are invoking a web API or retrieving a static file. To them, it's just an HTTP message where the response is JSON data. And you can see I get the same information whether I go to the API or to the static file. Now to communicate with the server, I'm going to need to install an additional module, a module that's part of the Aurelia suite. So inside the root of the web project where package.json lives, I'm going to jspm install aurelia-http-client. Jspm will go out and download that module, put it on my file system, and we're ready to go. Let's start off by trying something very simple with this new module that I've just installed. Let's go into the app.js view model, and what I want to do is use this HTTP client. Since it is a module, I can just import HttpClient from aurelia-http-client, and that will bring the class HttpClient into scope for me. I could from the constructor of app say this.http equals a new instance of the HttpClient. So what I will do is instantiate HttpClient directly from my app view model. A little bit later in this module, we will look at injecting the HttpClient, which will decouple my view model from the specific client that's being used, which can make my software a little more flexible and testable, but first we'll start off with a simple case. During activate let's do this, let's use that HttpClient that I saved off in an HTTP field to get from movies.json. That will get the information that is in the static file. I'm going to return the result of http.get because like many asynchronous activities in JavaScript these days, that call will result in a promise object. A promise object is something that promises to deliver a value to you in the future. I can get that value by adding a then method here, and I'm going to write an error function. For more on promises and error functions, see the ES6 course on Pluralsight, also I promise to explain why I'm returning this promise object from activate in the next module. The first parameter that you pass to the then method is a success handler, a function that will be invoked if the promise resolves successfully. So I'm going to say when we get the response then this.movies = response.content. Hopefully what that will do is bring those three movies back from movies.json. They'll automatically be deserialized for me. I'm going to take that array of movies, save it into a field in my view model called movies, and that should allow me to go into app.html, and instead of saying Hello World, let's write out a div that says You have movies.length movies. Save the application and refresh, and I can see that I do indeed have three movies. Let's see if we can display some information about those movies, so I will create a table. In the table, I want to have the title of the movie and the year it was released, and then I need a table row for each movie that I have. Now in addition to Aurelia defining some custom elements that I can use like compose, Aurelia also has some custom attributes defined. One of those attributes is repeat. So I'm going to say repeat.for. This is like writing a for loop in JavaScript. What I'm going to do is ask Aurelia to loop through a collection from the view model called movies, and for each item that it finds, put it in what you can think of as a local variable here called movie and then stamp out this DOM element and all of its children once for each movie that it finds. So now I can write a table cell that will display the title of the movie and I can write out a cell that displays the release year of that movie. Let's save this once more and try it out. And now I don't have the prettiest UI, but I am retrieving information from the web server. I am displaying that information into the browser and I'm doing that with a simple view and view model where the view model is now using HttpClient to make calls to the web server. We're going to come back and talk in a little more detail later in the course about using things like repeat.for, but right now, I really want to focus on this view model for a moment, and the next thing we want to look at is how can we inject an HttpClient into this view model, that will give us some additional flexibility and testability.

Dependency Injection

Now we are using an HttpClient class that is part of the aurelia-http-client module, it's not part of the core framework, the HttpClient is optional, but you can use this component or really any component if you want to make HTTP requests from your application. You're not forced to use HttpClient, but the HttpClient does provide an API to send get, post, put, and delete messages to the server, as well as supporting JSONP and the ability to configure headers like authorization headers with tokens, and we'll see some more of these capabilities as we move through the course. Here in our view model we are directly instantiating a new instance of HttpClient and sending off a get request for movies.json. I could also replace this with a call to my real API, which is /api/movies that will work for this project, but what I really want to focus on is how to decouple this view model from its direct dependency on HttpClient. The core Aurelia framework provides an inversion of control container with dependency injection features. Dependency injection is a technique that allows you to follow the dependency inversion principle, that's a design pattern that you can research here on Pluralsight, but the quick story is that this container knows how to construct objects like my view model and create the dependencies that this object needs by passing those dependencies as constructor parameters, so that I don't have to instantiate them directly inside of my ViewModel. So now instead of having a hard dependency on HttpClient, someone's going to pass me the HttpClient that's going to be used. That will allow me to configure the container with different types of HttpClients if I need it. Perhaps I could write an HttpClient that provides some caching algorithms or manages authorization tokens, then I could configure the dependency injection container with my HttpClient and have it automatically passed into this constructor, and inside of a unit test I could pass any type of object by one, be it a fake, or a mock, or a stub. There are many benefits to dependency injection, and again, check out the design patterns at Pluralsight. Now in order to get this to work in ES6 with JavaScript being a dynamic language and not having rich metadata available via reflection like you have in other languages, we are going to need to add some metadata to our class to allow Aurelia's container to inject the proper component. One way to do this using straight up ES6 code is to add a static method to my class that's called inject, so yes, a class can have static methods in ES6, and the inject method is a method the dependency injection container, or what I prefer to call the DI container, the inject method is a method the DI container will look for to retrieve metadata about what needs to be injected, what components does this class need to be constructed? So I will return an array because there could be multiple constructor parameters, I'll return an array that contains the class name, HttpClient, that symbol. The DI container will look up what do I use for this particular symbol, then create that object and inject an instance into the constructor. So I should be able to save app.js, and let's just refresh to make sure that still works. And it does, but let me show you another approach. Now we're going to use another feature from Aurelia framework. I am going to import something known as inject from the aurelia-framework, and inject is not a class, inject is what we call a decorator. In other languages this might be referred to as an attribute or an annotation. Decorators are a feature of ECMAScript 7, so an even newer version of the JavaScript specification, and they're quite powerful. They are not static pieces of metadata like you have in .NET. A decorator can execute code against its target. In this case, the target is this class App, and what inject will do is modify this class for me to provide the metadata that this class needs HttpClient injected into the constructor, or some component that is registered as implementing the HttpClient API. Now in order to get this to work, there is one more little change I'm going need to make, and that change is inside of config.js. Config.js you'll remember contains all the mappings so that the module loader can find the appropriate components when we ask for something from aurelia-framework or aurelia-http-client, and up here at the top it also contains some options for the transpiler that we are using, Babel. This decorator that we are using, as I mentioned, it is a feature of ECMAScript 7, and by default, Babel won't do anything with ECMAScript 7 features. We need to explicitly turn them on inside the optional section of this babelOptions, and I just need to tell Babel to please support es7.decorators, and that feature should be enabled now. I'm going to save all my files, refresh the browser, and now we're still getting our movie information, but we are injecting the HttpClient that we need. So our view model is now just a little more flexible and a little more testable. And there are a couple different approaches to providing the metadata that the container needs to do the injection. I'm going to be using es7.decorators, specifically this inject decorator that the Aurelia framework provides.

A Custom Data Component

It's important to understand that when building applications with Aurelia and ECMAScript 2015, I can create my own abstractions and my own modules, and I can use those components for my view models. I can even have them work with dependency injection in Aurelia. As an example, let's say that we don't want our view model to have intimate knowledge about how to go out and fetch the movies. We don't want the view model to know things like we used HTTP and this is the specific URL that we go to. I want to abstract that a way a little bit. So in the wwwroot folder, I'm going to add a new JavaScript file, and I will call this file moviedata.js. And the purpose of this file or this module will be to build some sort of abstraction that multiple view models can use to retrieve information about movies to update information for a movie. I want this to be a wrapper around HttpClient and my web API. So with simple things like a URL change, I don't have to go through and change all of my view models. So I will export a class, let's call it MovieData, and it will now be the responsibility of this class to talk to the HttpClient, so I'm going to import the HttpClient from aurelia-http-client, and ultimately I will still want to inject the HttpClient, so I will also import the inject decorator from aurelia-framework. So let's inject HttpClient. That means I can have a constructor that takes an HttpClient instance and I will save that off as a field in an instance of this class, and now I can start thinking about the API that I want this component to provide. It might provide things like the ability to save a movie and the ability to create a movie and get a movie by its ID, but right now, the only feature that I need is something that will get all the movies. So let's write a method called getAll, and this will essentially hide the call that we have here. So for right now, I will copy that code and paste it into MovieData, but I do want to change up a few things. First of all, let's take this URL and let's create something called baseUrl so it only appears in one place. So baseUrl will essentially be a private variable inside of this module, and it will have that string /api/movies. And now, if this component wanted to do some fancy caching, it could keep movies around as a field, but let's do the simplest possible thing that could work, which is just to return the movies that come back from a successful HTTP response. And now over in my app, I no longer want to import HttpClient, I want to import this MovieData class from my movieData module, and I do need to make one slight change here. Since this is a local module that is not something that I installed with jspm that is well-known like aurelia-framework, I'm going to precede the module name with a ./. That will tell the module loader that MovieData this module is in the same folder as this app view model, and now let's add the decorator to inject MovieData. By default, the DI container that Aurelia provides will treat the services and components that it instantiates as singleton, so there will be one instance of MovieData for my application, and that's quite common in JavaScript applications to use singletons that way. There are some additional decorators we can look at later in the course, some decorators that I could add to make this a transient component that is it's instantiated each time it is required. Now let's clean up our app view model a little bit. So this will be a movieData instance that comes into the constructor. I don't need a message anymore and I will say this.movieData equals an incoming movieData object. Inside of activate, I no longer need to do an http.get, instead I can just return this.movieData.getAll and there will be a response from that that provides me the movies. So I'll write a then with an arrow function that says given a parameter movies, this.movies equals those incoming movies. And now just in the interest of cleanup, we no longer really need changeMessage, so let me remove that from the view model and just try to format this activate method a little bit so that all the code can fit on the screen at once. And that's pretty close, all we have left over here is a semicolon, and now let me save all my files and refresh the browser, and we can hope that this works again. And it does. We still get our three movies, but now we've seen just how easy it is to build our own component like a movieData component that will encapsulate how to fetch and save movies. We can import that abstraction using ES 2015 module syntax. We can have an instance automatically injected by Aurelia, and this leaves us with nice simple code inside of our view model. Notice that I didn't have to do anything special to have the movieData component injected into my view model. I didn't need to configure the DI container explicitly. This is something the DI container can do by default. It can instantiate movieData for me when it finds that class symbol, but if I wanted to, I could add some explicit configuration code for the container and tell the container to instantiate a different component when someone asks for movieData, and we will look at more advanced Aurelia configuration in the next module of this course. For now, let's turn our attention back to the UI and try to make things a little bit prettier.

Bootstrap

From a UI perspective, you are free to use any CSS framework that you like with Aurelia. There are no restrictions or built-in dependencies for a specific framework. You could also use jQuery and jQuery plugins to help build your UI if you wish. You might want to wait until later in the course when we start looking at building custom elements before you start using jQuery because it is good idea to keep jQuery out of your view models. You can use jQuery from a component like a custom element or a custom attribute because it's those types of components which have the responsibility of directly interacting with the DOM. We really want our view models to be free of explicit DOM manipulation code. All the DOM manipulation that happens, happens because I'm simply sending data and fields and properties inside of my view model, and then using binding expressions to influence what happens in the DOM. Right now, we're just building tables and putting text on the screen, but as we move through the course, we'll also see things like adding animations, and changing colors, and changing CSS class names. So to reach that point and to demonstrate how you might include a framework like Bootstrap, let's add Bootstrap to the application. Bootstrap is actually one of those assets that I can install with jspm. So jspm can do a little bit more than just JavaScript libraries. And I can see from the output that jspm has installed Bootstrap from GitHub, and I know that jspm places everything that it installs into the jspm_packages folder. So if I look under github, I should be able to find twbs, Twitter Bootstrap, and it is inside of this folder where I will find the version of Bootstrap that is installed and then a css folder, and it's inside of here where I can find bootstrap.css. There's also a minified version and a source map. I'm just going to take the full version, and back in our index page, let's add Bootstrap to the page and Visual Studio has perhaps unhelpfully added both the CSS file and the minified file and the source map. I really just need a link to just the CSS file. It is a stylesheet. Let's also give this page a title. I'll just call it Aurelia Movies. Save this file, and then the rest of our work will be in app.html. This is our app view, this is the template that Aurelia will pick up and insert into the DOM where I have the Aurelia app attribute, and typically when I work with Bootstrap, I like to have nav section. So a nav element with a class, navbar and navbar-inverse to make it dark, and I'm using Web Essentials for Visual Studio 2015, which has the Zen Coding abilities, so I can use this syntax where I want a div with the class of container-fluid. This will allow my header to stretch out across the screen, and inside of here I want my navbar-header, and this is the place where we could place our brand. So let me actually create an anchor tag that is a navbar-brand, but right now I'm not going to worry about the link, I just want this to display. Let's just display Movies, and it's typically after the header where I use list items to create the menu for the application. We don't need a menu just yet. We'll get to that in the next module, but now let me take this table and I just want to place it inside of a div that is a Bootstrap container, and then add some classes to the table to make that look a little bit better. So we can say it is a Bootstrap table, and then we can also pick some of these other styles like table condensed or table striped, but let's just save what we have so far and see what we get. And just with that little bit of work, we now have a much more presentable user interface, still not very sophisticated, but it certainly looks a little bit better than what we had, and we've also laid a foundation for the next module when we start talking about routing and we actually need to give the user a menu where they can click on different links to navigate to different sections inside of this application.

Summary

In this module with Aurelia we learned how to use the inject decorator. This allows Aurelia's DI container to give us the dependencies that a view model needs instead of us instantiating them directly. We also saw how to write our own modules and our own classes and have them injected into our view model, classes like movieData, and over on the presentation side we have now added Bootstrap to the application and earlier we saw how to use compose, a custom element provided by Aurelia. More on custom elements later. What compose did for us now was allow us to use a second view model and allow it to participate in the presentation and the behavior of this page. We're going to continue to build on this sample in the next module. We'll start with the same code base, but we're going to add some code that provides some explicit configuration instructions for Aurelia, and we're going to add new features to the application, we're going to add them using routing, client side routing.

Configuration and Routing

Introduction

Hi, this is Scott Allen, and in this module about Aurelia, we will look at Configuration and Routing. Routing is a required feature for most applications because routing allows us to break a large application into smaller, independent pieces, pieces that are tied together through links and navigation menus. To use routing, we need to add some configuration to the application, so we'll start this module by seeing how to take control of application startup and add some explicit configuration code.

App Configuration

Back in the beginning, in the introduction of this course, we saw how we need to place the aurelia-app attribute into the DOM. This lets Aurelia know how to get started and where to take control, and when we use aurelia-app without any value on that attribute, the Bootstrapper will start the framework with some default configuration values and then go looking for a module called app. We built out this app module to retrieve and display movies. And I told you we could use framework features like dependency injection because the DI container is available with the default configuration and the DI container itself receives some default configuration, but if we want to take more control over the configuration of our application, for example, we want to tell Aurelia exactly what features of the framework to use and perhaps configure the DI container to inject some component other than the real movie data when a view model asks for movie data, then we can tell Aurelia to start with a specific module that provides some configuration information. The way we do this is to give aurelia-app a value, and that value is going to be the name of the module that we want loaded that will provide the configuration information. In this case, I'm going to call that module main because it sort of represents the main entry point for our program, and that means I will need to add a JavaScript file that has the name main.js. And inside of main what I want to do is export a function. I'm going to call it configure because this is what Aurelia will look for and invoke once the framework is up and running and the Bootstrapper is putting all the pieces together. When the framework invokes this configure function it's going to pass in an object, we'll call it aurelia because it represents the framework, and then there's a configuration API available. I'm not going to go extensively through the API, you can look it up in the documentation, but the gist is that I will walk up to the aurelia object and tell it to use specific features. For example, I could tell Aurelia that I want to use the eventAggregator and I could tell Aurelia that I want to use the default binding language, and default resources, and the router, which we're going to get into in just a little bit. I can also just tell Aurelia to use a standardConfiguration, and that will give me all the basics that I had before and there's a fluent API here, so I can chain methods together. I can also tell Aurelia to use developmentLogging. And for now, this is all the configuration I want to provide. I just want to see the application running again, and in order to do that, now that I've exported an explicit configuration function, I need to explicitly tell Aurelia to start, and this start method can be asynchronous as Aurelia loads different resources. So it's going to return a promise and then I can say on that promise, given a variable a that represents Aurelia, let's set the root to use to be the document object, which is implied so I can actually leave this off, but I now have a place where I can put some explicit configuration code. Let me just save everything and refresh to make sure this still works. And it does. And of course, in the UI, there's no apparent difference. We're still just displaying movie information, but now I have a place where I can start taking control of this application, including the ability to specify exactly what module that I want loaded. Do I still want to load the app module? Or do I want to load something else initially? Well I'm starting to think that I want some different features in this application. Yes, I want to display movies, but I might also want an area where the user can go to an About page. These are all things that I would want in the navigation menu. And now that I have a little more flexibility about how my application starts up, I'm going to restructure the project so we can scale out these features a little bit better.

About Routing

With the main module configuration in place, we can now load a top level view model of our choosing, and I still tend to think of this top level view model as the app or app view model, but the view model doesn't contain all the application features. In larger applications you can't keep adding features to the same view model, you need to break things up. Typically I want my app view and my app view model to be responsible just for those features that are common across the entire application like the top level navigation menu, because it doesn't matter where in the application the user is, the nav menu will always be on the page and will probably need some support from a view model to show the available options to the user. Then when it comes to specific features like listing all the movies or editing a specific movie, I expect this app or this shell to contain a placeholder. The placeholder is an area in my app view where I want different features to appear as the user navigates through the application. That way I can build a large application by building small pieces, like the ability we have now to list all available movies, that's one view and view model pair, or one module. And when it comes to showing the details for a specific movie, I want that to be a different module, and then I can have a module for editing a movie or creating a movie, and maybe other functionality like showing a dynamic About Us page, and a Register page, and a Reviews page, and so on. And each of these pieces are separate classes, separate view models, separate views, and they get loaded into the placeholder at the appropriate time. That's the job of client side routing. Just like in server side routing, it's the ability to inspect the URL and direct the request to the appropriate resource that will satisfy the request. I might want the user to go to my site and when there is a #/list at the end of the URL, that will show a list of all the movies, but if they click a link to #/about, then I want the About Us module to be loaded, and this is what we can achieve with the Aurelia router. We can tell the framework to load specific view models when the user comes to a certain URL, and when the URL changes like from /list to /about, the router can remove a view model, take it out of the DOM, take it out of that placeholder, throw it away, and then load the new view model and the new view. What we're going to see is how Aurelia can do this. We can build small, independent view models to list and detail, and edit movies, and show an About Us page, and then configure a component known as the router, and it will be able to use information in the URL to load the appropriate view model and view into that placeholder. It will do that by looking for a custom element. The element name is router-view. This element is somewhat similar to the compose element that we looked at in the last video module because it allows us to build a page and a UI by composing a view model like the movie list view model into a larger view, the app view. In fact with Aurelia, it's really easy to do this recursively and have child routers inside of a router. But we're just going to use top level routing, and unlike compose, this router view composition, it's done by matching against the URL, and that integrates directly with the browser history and bookmarks as you might have seen with routing engines and other client side frameworks. So let's add this capability to our application and I also want to do some refactoring to make it easier to build additional features into the app.

Adding Routing

In the application, what I want to do to scale out the features is create a folder per feature. This isn't something that's required. I can certainly place all of the files and all of the views, all of the view models inside of the wwwroot folder, but I think there are some obvious advantages to organizing your views and view models and other components by features. So if I create a folder called movies, the idea is I can keep everything related to movies, like the movieData class we created in the last module, I can keep all those things in this folder and I'm going to create another folder and I'm going to call it about, and the plan is ultimately I'm going to have two links in the navigation menu. One link that says Movies, one link that says About, and when the user clicks on one of those links, they'll be navigating between two different feature areas, one area that shows movie information, one area that shows about information. The other component I have that's already related to movie information is this app view model and app view. This is really all about displaying movie information, and I want to move this functionality into the movies folder also, but I'm going to do a copy operation this time instead of moving it there because I'm still going to need a top level app view model. This is going to be my shell with a placeholder that other features plug in to. And this view and view model that was formerly the app view model, I'm going to rename it because now it's really about listing movies, so I'm going to call this list.html and list.js, and inside of the view, I don't want list.html to be concerned about the navbar, that's going to be the app's responsibility, so I'm going to take the navigation bar out of this file. All we're left with is just the markup that is concerned with displaying a table of movies. Save this file. Let me also open list.js. I want to change the name of this class to list, and you can name this whatever you want, movieList, listMovies, but all the functionality is going to stay the same inside of here and now it's going to be my responsibility to set up the router and set up the navigation links so that I can get to this movie information, and that's going to be the responsibility of the app view model, so no longer will this view be concerned with showing movies, it's only going to be concerned with showing the navigation bar and then including that placeholder where other views will plug in, and that placeholder is the router view element that Aurelia provides. So this app view is in good shape. And now let's turn to the view model, which is no longer concerned with retrieving movie information, so I'm going to take out all of the code inside of here and instead of movie information, it is going to be this view model's responsibility to configure the router. And again, this is a place where Aurelia uses convention. If a view model exposes a method called configureRouter, Aurelia will automatically invoke that method and pass in two parameters. One is a config object that you can use to express the rules for routing, and the second parameter will be an instance of the router itself. And having access to the router can be quite useful. In fact, I'm going to save off the router into a field in my class because ultimately what I can do now is make that a part of my view model, and I'll have the ability from my view to write binding expressions that use information in the router to display things like navigation links. So I have my router saved off and now I can use this config object to map my routes. In creating routes it's very conceptually similar to creating routes with a server side framework or with other client side frameworks that do client side routing. Basically for each route, I'm going to have an object that contains some information about what the URL should look like and then some instructions about what to do when the URL and the route match. So for example, if I said the route was about, the Aurelia router would know when the URL ends with #/about to follow the rest of the instructions that are in this object. If I said something like details/:id, then the colon indicates a parameter placeholder, so Aurelia would look for something like details/3 meaning we want to see the details for the movie with an ID of 3, and now do what I say over here. And if I just leave this empty, I'm essentially saying here's what to do with the root of this application. I can also have an array here and say here's what to do at the root or anytime you are at list, because I want to list movies. And now what should Aurelia do? At a minimum here, I probably want to specify a moduleId because this tells Aurelia and the router what module to load up. And now after the refactoring, I have a list module inside of my movies folder, so I could tell Aurelia please load up movies/list, load up that module. Again, Node.js extension there. Aurelia can also set the title of the page when we are on this route, and I can also include some additional properties. I'm going to include one called nav:true, and that's some additional information that will be entered with that route. I'm going to be able to use that information to build a navigational menu. There's only a subset of my routes that I actually want to appear as top level links, and it's those routes where I'm going to specify nav:true, and we'll come back in just a bit and build the view and we'll get to see how easy it is to generate links from the routing information. I'm going to include one additional route, let's call it about, and the moduleId for this will ultimately be about/about. Currently my about folder is empty, so this is a view model and view that we will have to create, but we'll get to that. But I just wanted to give this one a title and call it About, and also say nav is true. And I'll format things just a little bit, so we can have everything on the screen at once, but these are the two routes that I want to work with and start with. So I'll save this file. Let's change our view around to actually consume this information. What I want to do here after the navbar header is build a menu. I'll do that with an unordered list that has a class of nav.navbar-nav. Those are some Bootstrap classes that will help me out. And inside of here, I want list items, but I want them to repeat. I want to repeat.for row of router.navigation. So essentially what is happening is when I build out my routing configuration, when I make an entry that says nav is true, then the router will take this configuration information and it will expose a collection navigation just with those entries where nav is true, so I can iterate over that and I can build out anchor tags, that say please bind the href to row.href. So just like we did with movies, I can essentially write a loop over this collection and I can think of row as a local variable that will point to each item as it stamps out these DOM elements. I want to build an anchor tag that uses the href of that row and the title of that row. And now, let's save all of our work and refresh the application. And I now have a menu bar with links in it. I'm still displaying my movie information because I'm essentially at the root of this application, but I should also be able to go to #/list and get that information, and once we build this About page, I should be able to navigate over there and see that view and view model. We'll do that in the next clip and we'll also make it obvious where we currently are by highlighting some of these menu items using Bootstrap styles and router information.

Adding an About Page and Highlights

Inside the browser, if I click on the About link, I can see the framework tries to load the about module and receives a 404 error. That's the expected result because we haven't created that module as yet, but I do know that the router is following the proper instructions that I've given it in the routing configuration. And now just to see that work and be able to move between links, let's create a very simple view model and view. I will need an about.js file and I will need an about.html file. And inside the HTML page, all I really want to do is create my template and have a div that displays some sort of message so I know I got to this module successfully. And that means for my view model, I can export a very simple class, so let's call it About, let's give it a constructor, and let's just give it a message that says Hello, World! And I should just be able to save those files. Let's refresh the application. And now I should be able to move between the list of movies and the About page, which displays Hello, World! And you'll notice, as I move between the two, the URL will change and behind the scenes the router is picking that up and unloading things from the DOM and loading new things in. Those URL changes also go into the browser history, so I have the ability to use the back and forward buttons now, but notice one thing about the menu. Currently, About is highlighted. It makes it look like I'm on the About page, but we're displaying a list of movies. To fix that situation, I need to take a little more control over which item is highlighted, and I can do that using some Bootstrap classes. Essentially, on a list item, I want to set a class of active for the menu item that represents the route that I'm currently on. So not all of the list items, just one of them. Unfortunately, this is easy to determine. For each row that I pull out of router.navigation, I can check a property on that row, which is the isActive property. And here I'm using the interpolation syntax with the dollar sign and curly braces so that I can write a ternary expression because the Aurelia binding syntax understands this, so if row.isActive is truthy, then apply a class of active, otherwise, I want to yield the empty string so that the class attribute is empty, but save that updated markup and refresh the application. And here, I can see List is active, About is active, and I can now move around with the back and forward buttons and the appropriate menu item is highlighted. So now we've seen how we can configure routing and then how we can use the router to build navigation menus, a top level navigation menu. Next, let's see how we can use the router with some parameters to view the details of a specific movie. This won't be a top level navigation item. This will be something I want to click on this movie title or a button and go to another view that will display detailed information about that movie. We'll do that next.

Adding a Detail Page

Now that we have routing in place, let's take advantage of routing to add some additional features to the application. So I would like to give the user the ability to drill down and see the details of a movie, perhaps by adding a button here that when it's clicked will load up a different view and view model pair to show everything that we know about a movie. Now in the sample application, really the only thing we know is the title and the year, but feel free to add your own data properties to the movie. Maybe you can add a collection of actors or an associated poster or picture for the movie, but before we can even build out the details view, we'll have to provide this link from the list view that is showing the movie information. So let me add another column to this table. This column will be like an action column. It's going to be full of buttons and different things that you can do to a movie, and I think I will build those buttons just as anchor tags that use Bootstrap to make the anchor tag look like a button, and this button will display the text details. And now ultimately what I need is I need a link that will send us to a route that we haven't defined yet. So first, let's define the route that we want to use. Over in the application view model where we define routes, I'll add a new entry here. This route will be if we go to details/, and then some ID parameter, what I want the framework to do is go out and look for a module that is in that movies subfolder, we will call it details. That's a module we haven't implemented yet, but we'll get to that. For right now I just want to get the link working, so let me save this file, come back to the list, and I could hardcode a URL inside of this page, but there is also a custom attribute that Aurelia provides that's called route-href, and what route-href allows me to do is provide some information that the attribute can feed to the router to generate the URL that I need. So I can tell route-href that the route I want to go to is the details route, and because that route requires an ID parameter, I'm going to need to pass along some parameters using this syntax, params.bind, and it's a bit like building an object literal in JavaScript. I want to say that the parameters are an object that has an ID property and that ID will have a value movie.id. So I'm relying on the fact that I am still inside of a repeat, a repeat that's going over movies, and I have access to this parameter called movie inside of the repeat. I can use that to display the title and the release year and also to pull out the ID of the movie and bind that into the parameters. Now one quick note about this syntax, I know the team is working on improving the syntax, so it's not so verbose. You'll just want to check the documentation to make sure you're using the appropriate syntax for route-href. But with this in place, I should now be able to move on and create that module, the details module. So let me add a JavaScript File, details.js, and I'll also go ahead and add the associated HTML file, the view, which will be details.html, and quite commonly I start with the view, so I can figure out exactly what it is that the view model needs to provide. And I'm thinking if I'm going to look at the details of a movie, it might be nice to have a header that can somehow show the title of a movie. And maybe I'll make it movie.title, so I will expect my view model to have a movie field, and that will be one of the movie objects that we've brought back from the web server. The other piece of information that we have available for a movie is the release date. So I can say Released in movie.releaseYear, and again you can add other data and play around with other things like images and so forth, but the one other piece that I think I would want in this view is provide an explicit link that allows the user to go back to the full list. They can always use the back button, but not all users use the back button, so let me create another anchor tag that will be a button, and I can use the text Back to list. And now let me show you another feature of route-href. I also have the ability to give friendly names to a route, so in this case I'm going to say, just route:home. No parameters are needed. I just want to go to the home route. In order for that to work, I'm going to have to go out and find some route that I want to call the home route, and it would make sense for the list route to be that. I'm just going to give this a name of home. That should give me the proper URL. And now, with the view in place, I will build out a details view model. In many ways, this view model will look a lot like the list view model because I would expect to use MovieData to access the movie that the user wants details about, so I'm going to import MovieData from movieData, and I'll probably want to inject this into my class, so I will also import inject from aurelia-framework. And now export a view model class, so let's call it Details. I will expect this class to have a constructor that will take the movieData component. Since I want it injected, I will use that inject attribute to provide the metadata about the type of component that I want injected and then save off movieData into a field called data. Now when Aurelia loads up this view model, it will invoke an activate method if one is available. And it's really inside of activate where I want to do the work of going out and retrieving a movie, and I want it to look something like this.data.getById, so I want to get a movie by ID and the first question is what is the ID? Well when Aurelia invokes the activate method, it will pass along an argument, we'll call it params, and for any parameters that you have defined in the URL in your routing configuration, those will be properties that are available on this params argument. So I should be able to say getById params.id. And then, since that will be a promise, I would expect that to give me a movie, and what I'll do is just save that movie into a field of this class. This is very similar to what we did with the list view model that dealt with all movies. I also want to return that promise, or a promise that represents all of this work because what Aurelia will do, it is smart enough to see that when you return a promise from the activate method, it's going to wait for that promise to resolve before it actually puts this view into the DOM. So when the view enters the DOM, it should have all the data available, and if for some reason the promise is rejected, the router can cancel that navigation. This means we don't have views popping up without data. Instead, what we can do to let the user know that we're working on something is provide a little bit of animation. We'll get to that, but anytime you're working with some asynchronous activity inside of activate, you typically want to return a promise to the framework that represents the result of that activity, so the framework can know when that activity is finished or if that activity has failed. And this is really all we'll need for the details view model. The last piece we need is currently, our movieData component does not have a getById. I will need to add that. Oh and while I'm inside of the view, I want all of my views be inside of a Bootstrap container, so I'm just going to take the HTML that was there previously and push it inside of a div with a class container, save this, and now movieData. We will add a method that allows someone to getById some movie. And if you are just using the static JSON file, what you might want to do is go out and get all the movies and then search for just the one that is indicated by that ID parameter. What I can do with my API is use the HttpClient to go out and get. And what I need to do is formulate a URL like /api/movies/ and then the ID. I can do that pretty easily with the ES6 string templates feature. So inside of backticks, I want to build a URL that will have baseUrl and then a slash, and then the ID that we're looking for, and that will be a promise. I want to do some post processing, so given a response, please return response.content, so I will use the shorter syntax for the error function that doesn't require the return keyword because there are no curly braces, and I want to make sure to return this promise. And now if I save everything, I hope I can come out to the application and refresh and we'll be able to see our list of movies. I want to be able to click on one, and now I can see the details for Star Trek. So you might have seen a slight delay there, and that's because my API on the controller when I go out to get a movie by ID, I have purposefully added a little bit of a delay here, so a 1000 ms delay. That's just going to allow us a chance to see that, first of all, the view didn't appear until the data is ready, and secondly, we're going to add some animation so that the user knows we're doing something when we're navigating to a new route.

Navigation Animation

To finish this module, I want to show you an easy trick you can use to display an animation when the router is busy navigating somewhere. And to do this, I'm going to jspm install a library known as Font Awesome. This isn't required, but Font Awesome does come with some nice icons that I can use to show some sort of spinning animation. And to use Font Awesome, which should now be installed under the npm folder in my jspm_packages folder, I just need to make sure to include the CSS file, and I'll need to do that in my index.html file. So let me open up index.html and come back to the Font Awesome folder and drag in a link to the CSS stylesheet. Now again, Visual Studio has included a couple additional things there when I drag, but really all I need is a link to font-awesome.css, and that piece is now in the page. And with that in place, I now want to come to my app view and we will find a place to display this animation. So in app.html, let's create a div with the class of container, and it's inside of here where I want to use some of the Font Awesome icons. So I will create an element with a class of fa fa-spinner fa-spin. And the trick is, I really only want to show the spinner when the router is busy, and fortunately, Aurelia provides a custom attribute called show, and all I need to do is write an expression that binds to show. And since the router is available from the app view model, I can write an expression using the router and the router itself has a property, which is isNavigating. So what I should be able to do is save all my files and refresh the application, and now you might have seen the little animation that appeared. When I go to Details, that animation is there thanks to the 1 second delay. And now if that were to take longer, at least the user knows something is happening. And it's also easy to add thanks to information provided by the router itself.

Summary

In this module, we saw how to add an explicit configuration function to our Aurelia application. Then we also started using the router and learned how to configure the router with different routes. We saw in the app view itself how we can use the router. We can use the router to build navigation menus and also display an animation when the application is transitioning from one view to the next. In the next module, we'll turn our attention back to the UI and investigate some of the binding syntax and templates that we can use. Syntax like href.bind, as well as how to build our own custom elements and attributes just like Aurelia has provided a custom attribute show and the custom element router-view.

Templates and Bindings

Introduction

Hi, this is Scott Allen, and in this module with Aurelia, we will look at building views in more detail. Specifically, the different bindings that Aurelia supports, as well as some different techniques for building custom elements. Along the way, we'll also see how to build a form for editing a movie, but let's get started by reviewing some of the markup we've already written.

More Binding

So far in this course, we've seen that we use templates to implement the view for a view model and templates always start with a template element. The template element was defined by the HTML5 specification as a way to declare document fragments for script manipulation, and this is exactly what Aurelia will do. Aurelia will manage these templates, place them into the DOM at the appropriate place, and then allow us to use data binding and string interpolation expressions inside. The purpose of data binding is to link the state and behavior in our JavaScript view models with this HTML that is in the template. We do this using constructs like repeat.for, href.bind, show.bind, and we've seen others in this course like click.delegate. There is also if.bind. Show.bind will simply show and hide an element depending on the truthiness of the expression inside, so the element is invisible when this value is false while the if attribute, this will actually remove this element from the DOM entirely if the value is false, not simply hide it, but remove it, and then if will add this element back to the DOM when the value is true. But the common piece that you'll notice in all these binding expressions is the dot, the period. We say href.bind, or if.bind, or repeat.for. And basically the Aurelia templating and binding mechanisms, they jump in to parse these expressions. You can .bind at just about any attribute, standard attributes, as well as custom attributes. For example, on this list item, I could bind to the style if I want to set inline styles or I could bind to the text content property of the list item. But sometimes all I want to do is mix in my own string content with the markup and static content on this page. And that's when I can use string interpolation with the dollar sign and the curly braces. I can use interpolation to produce content that the user can see, like when I use row.title to build the text for a menu entry, and I can also use interpolation to set attribute values like I'm doing with the class of this list item to highlight the active menu item. And there are really two ways I could've done this. I could've done this using interpolation. I could've also done this with a bind, and with bind I wouldn't need the curly braces or the dollar sign. So when would you choose to use interpolation versus bind? Well for this scenario, I probably would use the bind syntax because it's a little bit cleaner, but interpolation would help if I wanted to mix some static content into the class name. For example, what if I wanted a second class name here, maybe because I wanted to turn this link into a button? When I'm not using bind, I can just type that into the class attribute and it will always be there. The active class might be there too, depending on how this expression is evaluated. If I wanted to do this with the bind syntax, I would have to bind to an expression that could produce a string with both button and active when the element is active and only button when the element should be inactive. Another significant difference between string interpolation and .bind is that string interpolation is always one way, we always move content from the view model into the view as a string, whereas .bind can be one or two-way binding. Aurelia always picks a sensible default, so if I bind to a class attribute that's going to be a one-way binding, but if I bind to the value of an input element, that will be two-way binding by default because Aurelia will assume if the user types into the input that I want that value pushed back into the JavaScript object. There is syntax available to explicitly request one-way or two-way binding, but let's look at a place where we can use two-way data binding. Let's build out an Edit page for a movie.

Editing a Movie

Inside the application, I want to add another action button here that a user can click on to edit a movie. So let's go into the list template that displays these movies, and what I can do is copy some existing markups, so I will copy this button that allows the user to go to the details and paste it in and just change around a few parameters. Instead of going to the details route, we want to go to the edit route, that's a route that is not yet defined, but we'll do that next, and I can imagine if I'm going to edit a movie, I'll still need the ID of a movie, so I will leave that expression in place. And I've changed the text to say Edit. So let me save list.html and let's come into our app. And what I want is another route. This one can be edit/ and an id parameter, and the module to load will be movies/edit. And I just want to point out that I can have multiple routes point to the same module, so maybe I also wanted a route later that will allow a user to create a brand new movie, maybe I'll want to see create in the URL. I can do that and have it point to the same module, movie/edit. That view model can figure out if it's trying to edit an existing movie or create a new movie just by looking for the presence of an ID parameter. If it's not there, we're trying to create a movie. But let me add in the required comma here. We're going to save this file, and now I can focus on the edit functionality. So in my movies folder, let me add a JavaScript File. This will be edit.js, and of course we will need the view, so I will also add an HTML Page. This will be edit.html. And once again, let's start with the HTML. So I need my template element, and I'll need a div with a class of container, and let's use some Bootstrap styling to try to make this form look somewhat reasonable. So let's create a div that has a class of panel.panel-default, and inside of here will be a div with a panel-title, and it's inside of here where I might have a header element that says something like Editing, and let's try to put the title of the movie into the header. And I will actually need this title to be inside of a div panel-heading. Then after the heading would come the panel-body, and it's inside the panel-body where I will want my form. So we can make this a horizontal form, and let's create some basic input. So a div with a class of form-group, which is again, a lot of Bootstrap styles being applied here to make the form look somewhat decent. What I want to do is create a form group for the label and the input for the movie title, so a label with a class of col-sm2 and control-label. This will be for the title of the movie. And then a div with a class of col-sm-10 to take up the remaining 10 units, and that will contain my input that will be a type text input. Let's say that the placeholder for this will be Title, so we know we're entering the movie title if it is blank. I want it to have a class of form-control and I want to bind the value to movie.title. So before we worry about actually saving the movie and performing validation, let's at least see if we can get the data on the screen, so I'll need another div form-group, again with a label that is restricted to col-sm-2, this will be for the Release Year, and after the Release Year, a div col-sm-10 with an input that has a class of form-control. Let's also start off this type as text and have a placeholder value and bind the value to movie.releaseYear. And now let's see if we can get the view model to put some data on the screen. I will export a class called Edit, and this class will need the movieData component so it can retrieve and then save a movie. So let's again import the inject attribute from aurelia-framework and import MovieData from the local movieData module, and I'll add the annotation, which will add the metadata so we can properly inject movieData and save that off into a field of class. So again, I don't want to fetch the movie in the constructor, I want to fetch the movie from the activate method because then I can return a promise and let the router know when I have retrieved my initial data, activate, those get a parameters object, and it's here where I could look and see if parameters has an ID property or not, but let's just take the simple case where we're just going to edit existing movies. So I'll say this.data, let's getById using the id that was passed into me, and then that should return a movie to me, so I'll say this.movie equals that incoming movie, and of course I want to return this promise. Let's save everything and refresh and see how this turned out. I'll go to edit Star Wars and it looks like I have a little bit of trouble with my markup, but we are getting the proper data onto the screen, and if I edit Star Wars, I can see that I have two-way data binding between this input and the title of the movie, which is in my view model, and because there's also an interpolation expression up here that looks at that title, I can see the updates in real time. So with this in place, we can fix up the UI a little bit and then add our Save button to actually persist the changes that we made.

Saving a Movie

Let's return to our view, and it would appear that I'm not using the correct Bootstrap class here, I need to have dash here, this is col-sm-2, that controls the width of the label, and now that I have the proper class, Title should move over here to the left side of the form and now I need to add a button to this form, a button with a class of btn btn-primary. This button will just have the text Save, and I want to wire up the click event to invoke some behavior inside of my view model, and there are really two ways to do that. One is to use trigger and say please invoke the save method for me, and the other approach is to use click.delegate. The difference between the two is that both will wire up a click event handler on this element, but with delegate, I can also catch click events from any of this element's descendants, and that can be an advantage when this element has a lot children or a lot of grandchildren and you want to listen for click events on those children, but you don't necessarily want to waste the time and memory required to wire up a click event on each individual descendant. Instead, this is providing a click event handler at the parent level, there's just one, and it will catch all the click events from anything inside. Aurelia will even let you pass in an argument here, $event, that will pass in the native event object into my view model method, and then inside of that method I could decide what I want to do in response to that click. For this scenario, we don't need anything quite so fancy. I can just invoke save and I can safely just use trigger here because I really don't have any child elements, but I also don't have that save method implemented inside of my view model, so let's implement this. I need a save method, and I would expect to just be able to turn around to my MovieData component and tell it to save this.movie that I'm holding onto, and then I need to figure out what to do next. I need to tell the user somehow that this movie was saved successfully, and perhaps one way to do that would be to redirect to the Details page for this particular movie. There are a number of different ways to do that, but one way to do that is to use a router. So I am going to import a Router from aurelia-router so that I can inject a router into my constructor, or at least some component that looks like the router and then I can save that router off as a field, so I can have access to the router later and use it to navigate. Notice I'm not going to use configure router, I'm not trying to create a new router instance. In this case if I were to add a configure router method to this view model, I would be creating a new child router, which can be useful in master detail-type scenarios when you want nested routing or hierarchical routing. I'm just taking the existing router, injecting it into my constructor, and now I have the ability to use that router to programmatically navigate throughout the application. So inside of my promise handler for saving the movie, I would expect save to give me an updated movie just in case the server applied some sort of logic to the movie. And it's inside of here where I can let the router compute the URL for the Details page that I want to get to. I can say this.router, please generate a URL for the details route, and just like with route.href, that custom attribute where I had to pass in an object that gives it the parameters to generate the route, I need to pass in an object that has an ID field so that the router can figure out what ID parameter to plug into the URL. So URL equals router.generate the details route, and then with the router I can navigate to some URL in the application. And this is all I need my view model save method to do for now. I currently don't have a save method in my movieData component, so we will need to add this piece also. I would expect you to pass the movie to save into this method. And now saving the movie could simply be return this.http client .put, I want to update a movie so that's going to be an http.put operation, do a put to the baseUrl and send along the movie. Now if you don't have a true server side API, you're just using a JSON file, what you might do here is just use console.log to see something come by in the developer window that lets you know that you saved a movie correctly, but in my demo, I actually want to call my real server side API and do an http.put and put the movie there, and one day it should be just this easy with Aurelia, but there is a slight hiccup in the framework currently at the time of this recording, and that is Aurelia currently does not send along the proper HTTP request header when it has taken an object and serialized it into JSON. It should send along a request header that says the content type of this request is application/json, and that's currently not there, so I'm going to need to write a little more code to work around that problem, but this will also demonstrate how to have some more flexibility with HttpClient. What I'm going to do is create an HTTP request object from the HttpClient by telling it to create a request, and what I'm really getting back is an instance of a request builder. It's an object that has methods that allow me to configure this particular request. For instance, a method asPut, which will tell the request to send along an http.put message. I'm also going to say with the URL of my baseUrl, I'm going to explicitly give it a header that says I Accept anything that is application/json, and I'll send another header that says I'm going to send you content of type application/json. And finally, here is my content, which is the movie. And now instead of returning a promise from httpclient.put, I'm going to return request.send that will send the HTTP request, and then I can process the response and just return response.content, which will be the updated movie. So now you can see a bit of the configuration API around HttpClient, and you can also use something very similar on an HttpClient instance itself to configure it globally for an application. So if you have some sort of header that is an authorization header, you always want that authorization header in the request, you can do that during application startup time. But with this new code in place, let's save everything, refresh the application, and I can see that my form layout is better. And you might know that the reason I want to edit Star Wars is because it was actually released in 1977, the original, so let's save this. That brings me back to the details view and now I can go back to the list and we have successfully saved that movie into the database.

Validating a Movie

Now that we have the ability to edit a movie and save a movie, it's time to take a quick look at validation because currently the user can blank out the title and enter random characters for the release year, click Save, and that data will be sent to the server. Now the server will do validation and not allow me to save a movie that doesn't have a title, but it would be nice if we also had some client side validation, and there are a few different ways that you can do client type validation. You can use HTML5 validation attributes, attributes like required, and min, and max, or you could use an existing JavaScript library like jQuery validation, but there's also another module that the Aurelia framework provides, and I wanted to give you a quick example of how it can work. What I want to is jspm install aurelia-validation. Once jspm is finished installing aurelia-validation, all I need to do is some simple configuration in the bootstrapping of my application and then import validation into my view models that need validation. So first, let's look at configuring this optional plugin. Back inside of the main module that we created in the last video module, I had my configure function that configures Aurelia for my application, and I want to tell Aurelia to use a plugin, aurelia-validation. We'll talk more about plugin in just a little bit, but all you need to know for now is that using this method .plugin, it's going to call into an entry point in aurelia-validation and allow aurelia-validation to configure its environment much like I'm configuring my environment here, and this will allow aurelia-validation to do things like plugin new custom elements that I can use, custom elements that will help me perform validation on a form. And in order to do that validation, I'm going to need some validation rules. And to do that, I am going to import the Validation symbol from aurelia-validation, and validation is another component, it's a class, it's a service that I want injected into this view model. So I will add Validation to my inject attribute and then expect to receive a validation component as the third parameter in my constructor. And there are various ways to use this validation component, but let me show you one approach that uses a fluent API to configure the validation rules here inside of the view model. So I am going to save off a field in this object called validation, and it will be the result of saying validation on this view model. What I want to do is ensure a few things about the title of a movie. I want to make sure it is not empty, and I want to make sure it has a minimum length of at least 3 characters and has a maximum length 100 characters or less. I also want to ensure that movie.releaseYear, that it is a number and that it is between let's say the year 1900 and 2100. So these are my validation rules, and like I say, this is one way to use the validation plugin. There are quite a few built-in validations. There's also a lot of extensibility in this plugin. If I want to build my own validation functions or my own validation components, I can easily do that and have them work with this plugin. Just refer to the documentation for more information. But I now have this field in my view model called Validation and I can use that field to drive validation both programmatically here inside of my code, as well as associate this validation with a specific form that is in my markup, so that I get the proper error messages onto the screen. And yes, the validation plugin does support some localization. Not all the languages are available yet, but it will be easy to provide some customized error messages. So first, let's take a look at using this validation component programmatically. Let's say that once I get movieData from a server, I want to run a quick validation just to make sure that the movie is in a good state. If that's the case, I can go to the validation field and I can tell it to run a validation, and if for some reason the movie comes back from the server in a bad state, the user will see some error messages on the screen about what needs to be fixed. Now in this particular case, I don't really care about the result of the validation, I just want to execute the validation and put those validation messages on the screen if they're required. But there are times where I also might want to know the result of a validation. For instance, when the user clicks the Save button, I might want to run this validation and wait to see the result of the validation before I call into the save method of my movieData component. If that's what I want to do, then I'm going to have to program against the promise that validate returns. It returns a promise because some validations can be asynchronous, and if the promise resolves successfully, that means the validation was successful. If the promise is rejected, that means the validation failed. And what I will do is just take the code to save the movie and paste that inside of the then method, so that we only send the movie to the server when we have valid data. I also want to come into my view and change a few things around for validation. First of all, I really want to associate validation with the submission of this form, not necessarily just the clicking of some arbitrary button that's inside of the form. So I'm not going to handle click.trigger inside of this button. In fact, I think I'm going to change this button into an input, type submit, that makes it more obvious that this is the button responsible for triggering a submission of a form, and I will just need to give this input a value, so that it displays the text Save. And now up here on the form, this is really where I want to handle the submit event. So submit.trigger equals, invoke that save method on my view model, but one more thing I want to do is use a custom attribute that is provided by the aurelia-validation plugin and bind that attribute to the validation field that is on my view model. This will allow the coordination of everything that has to happen for proper form validation, and with that in place, let's refresh the application and see what we get. If I try to blank out the title of Star Wars, then I can see Title is required, and when there are only a couple characters there, I can see that this needs to be at least three characters long. And of course, there's an obvious problem with the styling of these messages, but we'll talk about that in just a second. The Release Year, oddly enough, I did not make it required, I did not say that it should not be empty, but if something is there, it needs to be a number and it needs to be a number between 1900 and 2100. Now if you're wondering why these error messages appear a little bit oddly, why they break the layout of my form, that's just because by default they will be placed into the DOM as block level elements, but fortunately I can influence the layout if I just add a few of my own styles to the application. So let me create a Style Sheet, let's call it styles, and inside of styles I want to write a rule for the class aurelia-validation-message, and what I want to do is make sure that these display as an inline element. I'm also going to tweak the margin on the left, let's make it 5 pixels. And the margin on the top, let's make it 5 pixels. Save this. I'm also going to have to make sure that that stylesheet is included onto the page for my application to inside of index.html. Let's have a link, a link for a stylesheet and the href for that is simply styles.css. So save all this again. Let's refresh and let's break a validation rule, and I can see that a little more tweaking might be required, but I do have some client side validation occurring. And it's also really easy to disable the Save button when the form is not in a valid state. Let's go to that input and I want to say disabled, let's bind to this, so an expression. I want this to be disabled when validation.result is not valid, so not validation.result.isvalid. Save this again. Refresh one more time. And let me blank out the title and you can see the Save button gets grayed out, I can no longer click on it. And there in a valid title, I would now be able to click on that Save button. So this is a quick example of one approach to form validation with Aurelia, and what I want to focus on for the rest of this module is actually the topic of plugins and how something like aurelia-validation can plug into the aurelia-framework and provide new components, new components like custom attributes and custom elements.

Creating a Custom Element

Aurelia allows you to define both custom attributes and custom elements. And if you want to do direct DOM manipulation, these are the types of components that you want to build because you can actually inject the element that your attribute is associated with or that represents your custom element, and at that point you can use the DOM APIs or use a library like jQuery to manipulate things that are on the page. What I want to do is show you a couple different approaches to building a custom element, and I'd like to do that using this navigation menu that we have inside of the application view. This might represent a piece of HTML that I want to reuse throughout the application or throughout several applications, or it might be that I just want to cut this out and package it up into a custom element like nav-menu just to simplify this application view and make it very apparent that there are a couple different view models that participate in building up this application view. There's the nav-menu and then there's the router-view, whatever is dynamically loaded by the router. I could also take this animated spinner that shows when the router is navigating and make that into a custom element, but let's concentrate on just nav-menu for now. In order to build out this custom element, I'm going to need to build a view and a view model. So once again, we've seen this all through Aurelia, the view and view model combination, I'm going to build out a custom view and a view model in a new folder that I'm going to create. Let's call it resources. This isn't required, but I'm thinking a folder like resources will give me a common area where I can place reusable components and use them throughout the application. So it's inside of resources where I want to add first a JavaScript File, let's call it nav-menu.js, that will be the view model, and also the view, which will be an HTML file with the name of nav-menu. And inside of here, once again, I'm going to use a template element and then I'm going to paste in the markup that I took out of the app view, so that entire navigation menu, I'm going to paste it into the nav-menu view. And now, this nav-menu works a little bit different than the other view, view model pairs we've been using so far. This view model is going to need to expose a router that I can use inside of data binding expressions and string interpolation expressions and all throughout this view, but the way I want to get to this router is a little bit different than the way I've gotten the data with other view models. With other view models when I've needed something, I've simply injected the component and I've let the DI container decide what to hand me. In this case, I want the consumer of this custom element or the view that is using this custom element to tell me what router to use. So it's not something that I want to inject and I'm not sure what context that router came from, this is something that I want my parent to explicitly hand to me. And that means I'm going to need to write my view model in a particular way so that from a view like the app view, I'll be able to say something like I want a nav-menu, and by the way that nav-menu needs a router, so I want to bind the router of the nav-menu to the same router that I'm using. That's what this syntax would be saying. And that's what's going to allow me inside of a view to communicate with the custom elements and the custom attributes I have. I'm going to be able to communicate with them because they can expose properties from the view model in a certain way that I can bind to those things from my view. So how would I write the view model so I can do this? Well let's start with a class. I will call it NavMenu, and what I'm going to do is import a new decorator that we haven't seen yet, it's called bindable, I'm going to import that from aurelia-framework. And the way I can use this particular annotation is to use it to create a property on this view model. So I want a property called router that is bindable through attributes in the view. I'm going to initialize it to null, but it is this simple one line of code that will allow me to use syntax like router.bind=router where router is the name of this property. Now before I forget, there is one configuration change that I'm going to need to make for this particular syntax to use. This configuration change is in the config.js file. We've been in here before when we needed to modify some of the optional options for our transpiler, we had to enable ES 7 decorators. Well in order for this bindable syntax to work properly, we're also going to have to enable another ES 7 feature. It is called classProperties. This enables a special syntax that that bindable annotation/decorator will take advantage of to build out the property for my view model, that router property. And then there's one last piece or one last change I need to make inside of app.html to get this to work. Currently, Aurelia does not know what a nav-menu is. It doesn't automatically go searching through all of the HTML views that I have to find custom elements, so I need to do one of two things. I either need to make this globally available throughout the application, which is what we'll do next, or I need to give Aurelia a hint inside of this view that it will be using something called nav-menu, and the way I do that is using a require custom element that Aurelia provides. It's a lot like an import statement in JavaScript that's a way of telling Aurelia I've required this other component from and in this case it is in resources and I basically just need to specify a module name, so I need to specify nav-menu. And with this in place, if I save everything, I should be able to refresh the application and I still have a navigation menu, but I also have a custom element for that navigation menu. I can use this from anywhere just with these two lines of code. So next, let's look at the process of globalizing navigation menu, so I don't even need this require.

Globalizing an Element

Now let's see what it takes to get rid of this require element, so that I am able to use nav-menu anywhere without using a require. And just to make sure this works, let me refresh the application without the require and you can see I currently have no navigation bar because Aurelia doesn't know about this element. In order to get this to work, I basically need to register nav-menu as a global resource. So let me show you a common pattern with Aurelia to do that. What I'm going to do is come into main.js. So remember, this is the bootstrapping of the application. This is where we configure everything before we really start the application running. And chances are nav-menu is not going to be the only custom element that I want to create in an application. Chances are I'm going to have more, so what I want to do is really treat my resources directory as a directory full of plugins - custom elements, custom attributes, other things that I just want to plug in to the aurelia-framework as if they were there from the very beginning. And with plugin, you basically specify a module name here. So the previous plugin was aurelia-validation. That's a well-known name, something that we installed with jspm. For my plugin that is local to this application, I'll tell plugin to go to the resources directory and to load up a module called index. So literally, it's going to look for an index.js file. And that's a common convention that you'll see with modules throughout the world of JavaScript both in Node.js and with ECMAScript 6. When you want to have some entry point for a folder full of utilities and components and classes that other people want to use, you might commonly provide an index.js root module that people can load to take advantage of all the things that are in that folder. What index can do is aggregate those things together. So just like index.html as a default HTML file for a folder, index.js becomes the default file or the default module for a folder full of JavaScript files or JavaScript modules. And so I will need to go into resources and create index.js, and what Aurelia will do when you specify a module as a plugin, is it will do something very similar to what we have here for main.js. Aurelia will load up that module and expect you to export a configuration function and Aurelia will invoke that function passing in an Aurelia parameter that represents the framework, and then you can use the Aurelia APIs to register your different components, your custom attributes, your custom elements. So just like I have there in main.js, I'm going to export a function, main configure. It takes a parameter, I'll call it aurelia. And one of the APIs that is available for aurelia is an API globalizeResources. And this method can take a variable number of arguments, which it just specifies all of the modules that you want Aurelia to pick up and globalize, make globally available. So if I specify that in this folder there's a component called nav-menu, Aurelia will now recognize that view and view model pair as something that is a candidate to be a custom element. Now what I'm showing you really is just the tip of the iceberg, it's the minimum amount of syntax that you need to get this to work. But let's just save everything and refresh and try it. And I can see now that my nav-menu is back, but I do want to point out that there is a tremendous amount of functionality and ability to customize everything that I've just shown you by using additional APIs and additional features that Aurelia provides, so this is just the tip of the iceberg. This is how easy it can be to build a custom element. And you might be thinking that this is very similar to that compose element that we saw. We saw compose very early in the course. I could say something like compose view-model and I'd be able to point it to resources/nav-menu and I'd even be able to bind the router, so yes, these two basically equivalent, it's just a question of whether or not you want a custom element or you want to use compose. If you're thinking about building widgets that other people can use, then the custom element approach is a great way to go. And again, I've showed you the simplified API. There are all sorts of other decorators, and properties, and API methods that you can use to customize this experience.

Summary

In this module, we looked in more detail at the binding syntax available with Aurelia and we saw how to use show.bind and if.bind, as well as build our own custom element. We also saw two-way data binding and how to build a form with validation. In the next module, we'll take all the code we've written for this application and see what other steps are required to put Aurelia into production.

Bundling and Minification

Introduction

Hi, this is Scott, and in this module we are going to look at getting our application ready for production by using some tools to bundle and minify both our application scripts and templates. We'll see that Aurelia provides a custom tool to help in this scenario. The tool is Aurelia-cli where CLI is short for Command-Line Interface. And we'll also use some other tools, tools you might already be familiar with, tools like Gulp. Let's start by taking a look at how the application is currently performing in the browser.

How Many Requests?

Something you might have noticed about our application is the number of requests that are required to get the application started. You can see that total count in the Network tab of Chrome. In here, I can see it took 285 requests to load the home page of the application. And while some of these requests are requests for stylesheets and other resources that the app needs, the vast majority of the requests are for JavaScript files, and that might be a little bit shocking if you haven't worked with ECMAScript modules before. You probably just can't imagine the few things that we are using would require this many files, but one thing to keep in mind with ECMAScript 2015 is how we build JavaScript applications a little bit differently, and we can see that in the code we write. We no longer put all our code into a single file. We are placing individual components, even very small components into separate files and we really want to think of these files as modules. They contain code that is isolated by default and we export specific symbols and we import from other modules other pieces of code and other abstractions that we need. So here, the list view model is going to import movieData from another module, and movieData is going to import httpClient and we are also importing that inject decorator from aurelia-framework. And some of these modules like aurelia-framework, they are actually themselves composed of other small modules, both modules that are part of the core Aurelia code base and modules that are written by third parties like core-js. You can see this if you come into config.js. Inside of here, jspm keeps track of what is installed and what the dependencies are between the different pieces that are installed. So I can see, for example, that the Aurelia framework is actually a module that is composed from aurelia-binding, and dependency-injection, and loader, and logging, and all these other things, and also core-js, and if I were to search around to find core-js, I would find that that is a module. It is also composed of several pieces, and those pieces themselves will be broken down into several smaller pieces. Core-js, by the way, is a library that provides a number of polyfills and other features that make it easier to work in browsers with modern code. So of course, core-js itself is going to depend on other modules and polyfills that it needs to load. Now back in the first video module of this course, we set up the application so that we'd be loading all of these modules as they are needed and on demand, and we're doing that using system.js, which itself relies on another component, which is the ES6 module loader. It's also using a transpiler named Babel that will transpile all this code that arrives in the browser from ECMAScript 6 or ECMAScript 2015, which is how we want to write the code, and it will transpile it into ECMAScript 5 or whatever the browser requires so that it can actually execute. And the setup we used made it very easy to get started because all of the hard work of transpilation and loading modules, it all just happens automatically for us. But obviously it's not the best setup for performance. We certainly don't want to transpile on the fly using CPU cycles on the browser when we can transpile once on the server and ship executable code directly to the browser. We probably also don't want the application to send 285 requests to get started, although bundling and file concatenation, these might not be a big concern in a few years when we have servers and clients all using the HTTP/2 protocol, but that's still in the future, so for now, we want to bundle and transpile all of the code that our application requires into a single download. That should improve performance and that's what we're going to do next using the Aurelia-cli tool.

aurelia-cli

Aurelia-cli is a command-line tool that runs under Node.js, just like jspm that we installed back in the introduction to this course. So in order to get Aurelia installed on this machine, I'm going to npm install aurelia-cli with a -g switch, which means install it globally. That means I should be able to open a command prompt or a shell anywhere on this computer and type aurelia and it's going to be available. And now that that tool is installed, I should be able to type aurelia from anywhere and that command is available. I do get two warnings, however. The first warning is that a Local aurelia installation is not found. This is a pattern that several Node.js tools follow like Gulp. You want to have a global installation of this tool so that the command is available everywhere, but the global installation is just going to call into a local installation of that tool, so that individual projects can all be using different versions of aurelia-cli and not conflicting with each other, so I need a local installation in addition to that global installation, and I can do that by saying npm install aurelia, without the -g, and probably with a flag like save-dev because that will record the fact that I'm using this into my package.json file that will be a development dependency. With the installation complete, I should now be able to run Aurelia, and I'll be down to one warning that there is no Aurelia file. So an Aurelia file is very similar to a Gulp file or a Gruntfile if you've used those technologies. There's going to be a file that provides Aurelia with some instructions to execute and some parameters and some configuration data that will allow me to do things like bundle a file. So if I want to type aurelia bundle and have this tool create a bundle or multiple bundles for me, then I will need to create an Aurelia file with some instructions about what to bundle and where to place the output. It can be a very simple file, and I want to add this to the root of my project, and it is just a JavaScript File that has the name AureliaFile.js. And this is a file that just like a Gruntfile or a Gulp file will execute under Node.js. So for right now, these days I'll be using ES5 syntax and the var keyword, although, there are ways to write Gulp files and Aurelia files using ES6 and have them transpiled with Babel before they run in Node, but to keep things simple, what I want to do is I want to get a hold of a programming API that is available for this tool in this JavaScript file, so I can require aurelia-cli, and that's very similar to an import statement in ES6, and then I can tell Aurelia about the command, specifically, the bundle command. What should a bundle, where should it place the output? There are two types of bundling that can happen. There's the bundling of JavaScript files and there's also the bundling of template files or HTML files, because in that list of 285 requests, you'll notice a few HTML files are being downloaded, app.html and list.html, and if we navigate to the details for a movie, the application has to pull down details.html, so this tool also provides the ability to take all of those templates, put them into a single HTML file and then we can have a single download that will provide the application with all of the templates that it needs. But first, let's talk about the script files. What I do inside of this object is I essentially tell Aurelia first of all, what is the module or what is the bundle that I want to create? Well I'm going to tell it that inside of the wwwroot folder, I want something called appbundle.js. So you can think of it like the appbundle module. And that module itself will consist of the following modules, which I will list, and then you can have some bundling options that are specified. Bundling options would include things like do I want source maps or not. And I'm going to tell the tool about the following modules. So this is where I can list things like the aurelia-bootstrapper. So I want all of the modules that aurelia-bootstrapper provides, as well as all of its dependencies to be transpiled and placed into this appbundle file, and in addition to the bootstrapper, I also want the framework itself. We also use the aurelia-router, as well as the aurelia-http-client, as well as aurelia-validation. So you'll notice that this is basically the list of top level modules that we jspm installed. That's what I'm listing here, so everything gets placed into a single file. And remember it will be the module, as well as all of its dependencies, so technically because things like aurelia-validation depend on things that are inside of aurelia-framework, I could probably get away without listing that module explicitly, but I'm going to leave it in there because it makes me feel better to see it. Now in addition to all the framework stuff, which will bring in core-js and everything else that's needed, I also need to list out the application modules, my application modules. And if all of my application code was in a single subfolder underneath of wwwroot, like if I had pushed everything down into an app folder, it would be very easy for me to say go into the app folder and basically just blob up all the modules that you find in that folder and in all the subfolders. That's a syntax for that. We didn't do that, so I have to be a little more careful about how I attach modules here for my application just because there are some other JS files here like config.js, which I don't want to be caught up in this blobbing pattern, so I'm going to be very explicit and say that I need the app view model, the app module, as well as mean, that mean module, which bootstraps the application and configures Aurelia. And then there are the various folders that have my application modules, so there's about, and movies, and resources. So I'm going to say go to the about folder and take everything, go to the movies folder and take everything, and go to the resources folder and take everything. And that will place nearly everything that I need into a single file appbundle.js. And then, I don't even have to modify my index.html file to include that appbundle. Instead what I can do, during bundling, I can pass along this option that says inject: true. And what this will do is inject some configuration into config.js about the bundle, so that at runtime when the module loader sees that oh, we need something from movieData, it will know that that was already loaded as part of a bundle and it doesn't need to go back to the web server to fetch another file. Everything that it needs should already be in place. And one of the beautiful things about bundling is I can simply execute the code to produce this bundle and not change anything else and my application will automatically start using that bundle. There's also an unbundling command that I'll show you if I ever want to reverse that change in config.js. But now that we have the appbundle.js file specified, let's also go ahead and build out a template file, so this will also go in wwwroot in appbundle, but this will be an HTML file. And here I want to tell it to basically go out and grab all the HTML files that it can find, and this one will have no options right now as this is actually a very early preview of what the bundling features will be like in the CLI tool. The template bundling isn't completely finished, but what I should have the ability to do now is save everything and now come out to my command prompt and tell Aurelia to bundle up some files. I'll get a few warnings about things that are deprecated. This will all be fixed in the future. The important thing is I did not have any error messages. And if I come into Visual Studio, I now see that I have appbundle.html, as well as appbundle.js and appbundle.js contains all of the transpiled code for all of those modules, and if I look in config.js real quick, I'll also see that there's something new here, which is that there's a configuration entry that will tell the module loader that there's a bundle, appbundle, and all you need to do is grab that one file and that will give you all of the stuff that is listed here, all of these modules, stuff from Aurelia, stuff from core-js, stuff from the application itself, so I should just be able to refresh my application, and just with that little bit of work we were able to cut things down to 59 requests. I'm not taking advantage of the HTML bundling as yet. And there are a few other things that we can tighten up, but you can see that's a significant difference from 285 requests. And if for some reason I wanted to undo that, I could just tell jspm to unbundle that will remove that bundle configuration from config.js for me, and now I would be back to my 285 some requests. But with the basic bundling in place, let's continue to look and see how we can improve this.

Bundling and Minifying with Gulp

In addition to bundling our files, I also want to put together a quick Gulp file that will allow us to create a bundle file and then minify that file, so that we get an even smaller download for the application. Minification can typically cut the size of a JavaScript file at least in half, and that's my experience with the Aurelia bundle. And to do all this, I'm going to be using Gulp. There are quite a few Pluralsight courses that cover Gulp and John Papa has a course dedicated to Gulp, and if you've watched any of those or used Gulp yourself, you'll probably know that you need to npm install Gulp both globally, the gulp-cli, which I've already done, and I also need to install Gulp locally, and I'll throw in the save-dev flag so that appears in my JSON file. And now let's create a Gulp file. One of the nice things about using Gulp with Visual Studio 2015 is that Visual Studio 2015 does provide some integration with Gulp. It does understand what tasks are inside. When I want a Gulp configuration file that just means it's a JavaScript file named gulpfile.js. And to get started, let's see if we can put together a task that will create our bundle. So I will create a task called bundle, and this will take a function, and what I can do to execute aurelia bundle is pull in something called exec. This is from a built-in module child_process.exec, and what I can do inside of this task is to say execute on the shell, basically, aurelia bundle, and when that is complete, it will call back into this function. And basically, I need to propagate any errors that might have occurred during aurelia bundle, and I can do that by taking a callback parameter in the function for this task and that parameter will be a function. I can then invoke that function and pass in an error or an error object that is passed into this callback function for the exec. This is a fairly common pattern in Gulp and really a common pattern for Node.js in general. And just having that one task in place, I should be able to come out to the shell and say gulp bundle, and that will run the bundling and put my inject back in place so that the number of requests should be back down below 60. And now let's try to minify that file so we don't have so many kilobytes transferred. To minify, I'm going to npm install something known as gulp-uglify, you might be familiar with Uglify as a very popular tool for minification, it makes the source code ugly. And with Uglify installed, let me get a reference to that here. So uglify will be what happens when I require gulp-ugilfy. And now let's create another task. Gulp.task uglify is something that will depend on bundle being run first, so I want to bundle and then uglify. And to uglify, what I will do is first grab my source code, which in this case is now just a single file, it's in wwwroot, it is the appbundle.js file. I will take that file and pipe it into uglify, and then take the output of uglify and pipe that into the destination, which if I just put wwwroot here, that will write out appbundle.js into wwwroot, so I'm effectively replacing the existing appbundle.js with a minified version. And now I could also come into my default task and just essentially say that the default task is to uglify the files, which will of course first bundle the files. And because I now have a default task, I should just be able to type gulp, and this will first bundle and then uglify the bundle, and I should now be able to refresh the application and we've got a little bit of a smaller payload. And at this point I should mention, at the time of this recording Aurelia hasn't been officially released and one of the areas that the team is going to concentrate on next is performance and performance optimizations, including the amount of time required to get an application started up and the amount of code needed to get an application started up. So some of the hard numbers that you're seeing here should improve in the future. And this is just one approach to a development workflow in working with Aurelia. In this workflow, I'm going to rely on the bundling to put all my files together for a release build. And it's very simple to use jspm unbundle to go back to a scenario where all of the modules are loaded individually. And other projects, for example, the sample skeleton navigation application that is part of the Aurelia project and the contacts application that we looked at in the introduction to this course in the first video module, they make much more extensive use of Gulp to do a lot of upfront building and linting and moving files around, so there are a lot of different options and flexibility on how you ultimately go about delivering an Aurelia application to the browser. Hopefully this module gave you some ideas, some simple ideas, about how to use the aurelia-cli tool in combination with Gulp to provide a simple, but effective build system.

Summary

And this concludes my course on Aurelia. Hopefully this gives you an idea on what it would be like to build your own application. Just remember moving forward that the heart of Aurelia is about using views and view models to build an application. You can build out an app using view and view model pairs that are mostly independent, but you use routing to stitch them together into a larger application. And for the most part, developing with Aurelia is just remembering a few simple conventions. Now you also know one approach to bundling and minification, so at this point I encourage you to try building something on your own and have fun.

Course author

	
Scott Allen

 Scott has over 15 years of experience in commercial software
 development and is a frequent speaker at national conferences,
 and local user groups. Scott is a Microsoft...
Course info

LevelIntermediate
Rating
(513)
My rating
Duration2h 25m
Released25 Jun 2015
Add to playlist
Share course

