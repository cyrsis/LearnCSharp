
What do you want to learn?
Victor
cyrsis3@hotmail.com.hk
PLURALSIGHT
Home
Browse
Paths
Mentors
Playlists
Bookmarks
Notes
AngularJS: Get Started
by Scott Allen

This course demonstrates how to use the essential abstractions of AngularJS, including modules, controllers, directives, and services.

Start CourseBookmarkLive mentoring
Table of contents
Description
Transcript
Exercise files
Discussion
Learning Check
Recommended
Course Overview

Course Overview

Hi, this is Scott Allen, and welcome to my course on Angular 1. This course gives you the essential knowledge you'll need to start building applications using Angular and JavaScript. In this course we'll start from scratch and I'll give you some pointers on common JavaScript design patterns that you will see when programming Angular applications. We'll go on to learn about the core features of Angular, including controllers, templates, and services, and we'll do this by building a real online application. We will even consume a public Web API from GitHub so you can see how to retrieve real data over HTTP and use that data to update the UI. By the end of the course you'll be able to start using Angular in your own applications, and I think you'll see just how easy it is to build browser applications that are responsive and smooth, and applications your users will enjoy. I do expect that you already have some experience with JavaScript and know the very basics. I also assume you've already done some work with HTML. If not, we have plenty of courses on Pluralsight about HTML, JavaScript, and CSS. And once you are done with this course, you might consider my course on using components in Angular 1.5. Components make Angular even easier, and it's a good follow up course for you to enjoy.

An Introduction

Hello!

Hi, this is Scott Allen, and this is a course designed to teach you the basics of AngularJS. AngularJS is a JavaScript framework you can use to build applications, but run in a web browser using HTML. I'm going to assume that you've never worked with AngularJS and that you know only a little bit about HTML, CSS, and JavaScript, but I'll also assume that you have a desire to learn Angular and are willing to learn by following along and writing some code. In this first module, I want to show you how to get started with AngularJS on a web page, show you the development environment we'll be working in, and also cover some of the JavaScript coding styles we'll be using throughout the rest of the course.

AngularJS

The AngularJS framework started as a project inside of Google, but it's now an open source project so anyone can contribute to Angular or use Angular in their own applications. The home for AngularJS is angularjs.org, and this is where you can find links to mailing lists, you can find the documentation, you can find a Download button if you want to bring all of the Angular libraries down and use them locally, and there's also a link to GitHub where the raw source code lives. A related website you might be interested in is, builtwith.angularjs.org. This website includes pictures and links to other public websites that have been built with AngularJS. The examples include everything from games and video players, to statistical reports with user customize queries, and productivity applications that run on a mobile phone. You'll notice some popular sites on the list too; sites like YouTube and the news site, MSNBC. In this course, we won't build anything quite as visually stimulating as some of the applications here; we're going to focus on the basics, but builtwith.angularjs can give you some ideas and inspiration for building your own Angular application. Another site linked from builtwith.angularjs is Plunker; that is plnkr.co, Plunker. Plunker is built with Angular and it's interesting because it's a complete web development environment hosted in your browser. I can browse to Plunker and click on ‘Launch the Editor', and after a little bit of loading time, this will bring me to a page where I have my own web project, including my own HTML file, my own script.js file, and a stylesheet. And everything that appears in here can be rendered inside of a Live Preview window; I just need to click on the eyeball over here. If I hover over it, it says Live Preview, and now my HTML and JavaScript and CSS, it's all running inside of that far-right pane. And I can come into a file, like the JavaScript file that's here, script.js, and I can actually type code in here and it will be executed immediately. So I could say, ‘Let's do a document.write below Angular' and that will appear in the window and show me how my code is behaving. So Plunker is easy to use because there's nothing to install, and I like it so much, I think we'll use it in this course to work with Angular. So let's look at creating our first Angular application in the next clip.

An Angular Application

There are only two requirements for adding AngularJS to a web page. First, you need to add a <script> tag pointing to angular.js. Angular.js is the only script file that you need for the core Angular features, because Angular has no other dependencies on other libraries. This is the only script file we need, except for the script files that we might write for ourselves. The second requirement is that you need to add an ng-app attribute somewhere in your HTML. ng-app, in Angular terminology, is called a directive, and it is just one of many directives that Angular provides. The ng prefix is short for Angular. So whenever you see ng in your code or in documentation, or in a website name, or a bumper sticker, think Angular. ng-app is what we call the application directive. It is a special directive that Angular looks for inside of your HTML, and if it finds it, Angular will bootstrap itself; so it initializes itself and it jumps into action to start managing the page. Let's try this. Now I'm back on the Plunker landing page, and do make sure that you go to plnkr.co, so the word Plunker without any vowels, and a .co, not a .com. Now that I'm on the landing page, I'll click ‘Launch the Editor' again and Plunker makes it very easy to get started with Angular, because here on the right-hand side is a list of popular packages that I might want to use inside of the HTML that I'm building. And the most popular package is … angular.js. If for some unthinkable reason Angular doesn't appear here, I could always search the packages, and I'll be able to find angular.js. And I want to use the most current version of Angular so I'll just click on this icon right after angular.js and what Plunker will do is add a <script> tag to my HTML file to reference Angular. Let me close this external library's pane by clicking on the second icon, and formatting the source code a little bit so that you can see, yes here's a <script>tag with a source that points ultimately to an angular.js file that is hosted on some other server, code.angularjs.org. And that's fine, that's going to work for us, and that's the only script I need. My other requirement, though, is to add an ng-app directive somewhere in my markup. Some people like to add that directly to the html element; I could also add it somewhere else inside of the page, like on the body element, but you do only get one ng-app directive per page, and Angular's only going to take control of the section of DOM where that ng-app directive applies. So in this case it will apply to everything in the body; I won't be able to use Angular expressions and features outside of the body tag. But with the script in place and my ng-app directive in place, let me open up the Preview window and what we'll see is a web page that doesn't look any different than it did before I added Angular. It still just displays "Hello Plunker!" and there's nothing that tells me that Angular is running, but what can we do now? Well the other night my oldest son comes to me and says, ‘Dad, what's 843 divided by 42?' And although I could come up with a close approximation in my head really quickly, it just so happened that I was working on an Angular application at the moment and so I just went into the page I was working on and put in this expression, "843 / 42", and I put that inside of double curly braces. And because I was working on an Angular application, Angular found that particular binding expression, that's what we call it, and an output into the web page, the answer I was looking for, which was roughly 20.07. So these double curly braces are what some people would call mustaches or handlebars, they are binding expressions in Angular. Angular looks for these things and tries to evaluate the expression inside, and you might want to do simple division or addition or subtraction, but later in the course we'll do much more interesting things, because you can also build binding expressions that look at data that you have retrieved or computed from some web server, and that's what would allow us to build charts and tables of information for our users. But because this is showing up on the web page, it's a really good indication to me that Angular is up and it's working. If, for example, I were to delete the script reference or if I were to take out the ng-app directive, now I no longer see the result of that expression on my web page; I just see the literal text that I typed in, which is double curly braces and 843 / 42. Also, if I were to have another piece of markup, like another div, and the ng-app directive existed here, I would still see just the literal text that I typed in because Angular is not in charge of this section of the DOM on line 13; it's only in charge of the div that starts on line 14 and closes on line 16. So if I move my expression inside of there, Angular is in control, Angular finds that binding expression evaluates it and puts the result on the screen for me. So the <script> tag and the ng-app directive, those are the only two things that we need to get started with Angular, but if we're going to build anything interesting, we're going to need to learn a few more things about Angular, also this environment that we're operating in, Plunker, and a few JavaScript conventions that Angular follows. So let's continue our discussion of Angular by looking at a Plunker Editor.

Plunker Tips

There are a few key features of Plunker that I want you to know about to save you some time. First off is the Save button. I can save my Plunkers and then bookmark them, or share them with other people if I want to show them something I've done or have them help troubleshoot an issue, and so once this Plunker is saved, I can take this URL and hand it out or save it or copy it into a bookmark. I could even take it to another browser, open the same Plunker; now it's running in Internet Explorer. I can also click on this button that is close to the Sign-in button to download my code. This will download a zip file with all of my files inside, and then I could run the application locally on my own web server or I could add this work to an existing web application. If you have a GitHub account, you might also consider signing in to Plunker. This will make it easier to track your plunks and also collaborate and share your work with others. The left-hand pane is a list of the current files in the project. I can click an X on the far right to delete a file, so I no longer need README.md, I'll delete that. I can also double-click a file to rename it, so I could type the new name here inside of this dialog box. And at the bottom of the list is a link to add a new file, I can add new HTML files, JavaScript files, CSS files, really any type of textual file that I want. In the middle is my Editor, and I can switch between the different files just by clicking on them here. And on the right is the Preview window. If you have more screen real-estate and you want the Preview window to be a little bit larger, you can click the little blue button here in the toolbar in the Preview window. That will open up your preview in a separate window that you can size to full screen, if you want. This comes in handy in a number of scenarios, including debugging, which we'll look at a bit later. And finally a few useful features in this far right toolbar. The top button shows the Preview window, that's what we're using now, the second button allows me to go out and find other libraries and third-party files that I want to add to my application. The icon with the checkmark is a code linter. This can tell me about any errors or potential problems in my code. And the last button are some settings that we can configure. For example, I want to make the Font size a little bit larger for the rest of this course, and I also might want to try a different Theme, something like monokai, I find the vibrant colors very pleasing. I can also change the Refresh interval. This is the number of milliseconds after you finish typing in the Editor when the Preview window will automatically refresh and render your work. If you find this feature annoying because of the constant updates, you can always turn off auto refresh, and then in the Preview window, there is a manual refresh button here. So just click the manual refresh and you'll see how your code is behaving. And now that we know a little more about Plunker, let me also talk about just a few tips for the browser itself.

Developer Tool Tips

As we are working with AngularJS, there's always a chance that you might run into some problems and something might not work. I want to point out some of the features of the Developer Tools in my browser, and I'm using Chrome, but you can also use the Developer Tools in Firefox, Safari or Internet Explorer, because in all of these browsers, the Developer Tools help you track down errors and see what your program is doing. I'm going to show you some examples with Chrome; how to see errors in your scripts, how to open them for debugging, and to set breakpoints. For the point that we're working on, let me go in and turn on the auto refresh again. And now what I want to do is come into script.js and I want to just type some gibberish. Now, the Preview window is still going to update and display the same result I had before. There's no visual indication that something is wrong here, but it is true that, in fact, I do have an error in my JavaScript code; I just don't know that. And it's always a good idea when you're developing to have the Developer Tools window open, because it will tell you about errors and you can save many minutes of scratching your head and wondering why something's not behaving correctly on the page just because there's an error you don't know about. With Chrome on Windows, the easiest way to open the Developer Tools is to press F12. You can also get to the Developer Tools through this menu under Tools, Developer Tools, and that works on any platform. And when you open the Developer Tools, the most important place to watch is this area at the top of the window, because any time you see the red circle with an X inside and a number beside it, that means that there is an error somewhere on this page. And the best way to see those errors is to come into the Console tab. So the Developer Tools might open up on any of these tabs that are available, but you typically want to keep open the Console tab. And one of the challenges with the Console tab is it's going to collect all of the log messages, warnings and errors, from everything that is running on this Plunker webpage, and that includes things like the Plunker Editor, as well as the scripts that I'm writing for my own plunk. And you can see there's a number of entries in here from editor.js. Those I'm not concerned about because I have no control over them. That's the Editor that Plunker delivers. I'm worried about the errors that are in my scripts and I can see that script.js, that is the script that is in this project and in fact does have an error. The number over here is even telling me the line of code where this is occurring, and so on script.js it's on line 3. And if I come into the Editor, I can see, yes, that's the cat walking across the keyboard or something like that. So I remove that, the Preview window refreshes, but the error is still going to stay down here in the Console, because this Console just collects messages from the beginning of time, where the beginning of time is when you come to the webpage. So you will find it occasionally useful to right-click inside of the Console and say let's clear it; that way I can see errors as they occur now. When I type something ridiculous, it pops up as an error in the Console, so now I can remove that, clear the Console, and I know I'm in much better shape now. Something else that you'll probably find extremely useful over time is the ability to debug some of your scripts and be able to inspect variables inside of your scripts to see what values they hold. So let me give you a quick demonstration of that. Let's say inside of my script I'm going to compute some result, "result = 2 + 2". And I expect that answer to be 4, but perhaps something is showing a 5 on the screen and I cannot figure out why. For right now, let me just do an alert with that result that will actually pop it up in a dialog box. That's not something that I suggest you do when you're working with Angular, there's much better ways to do this, but this is what we're going to use for now, just so I can show you some debugging techniques. So let's say that that dialog box pops open and shows the #5 and I don't expect the #5. I want to find out what's in that variable. Why is it being computed that way? If that's the case, I will want to come into Sources, and inside of Sources, if this particular tab here is open, there'll be a list of dozens and dozens of JavaScript files, some of which are mine that I'm writing, like script.js, and some of which belong to Plunker in order to build the Editor and the Preview window and things like that. If I just want to find my file, script.js, then I want to hit Ctrl + 0, and now I can just search for it. So I can say, ‘Let's find script.js, there it is, let me open it.' And now what I want to do is set a breakpoint. So over here in the numbered columns, if I click there, there'll be a little visual indication that I have a breakpoint here. And the next time this script runs, Chrome will stop execution on this line and I can inspect some things. So now if I change something on my page, like just add a space, now Chrome is re-executing all this JavaScript, you can see that I have stopped on this breakpoint because the whole line is highlighted. If I hover over the results, the #4 pops out, so I can say, ‘aah yes, well there was a 4 inside of result, where did that come from?' I can go and inspect some other variables inside of this source code. And then once I think I've found the problem, I can always clear this breakpoint by clicking on it again. And then coming over to this toolbar on the right, and say ‘resume script execution on Windows'. I could also press F8 to resume, and now my page continues execution. I can see that a 4 pops up. And based on the code that I saw, that is the expected result. So just to review the couple tips that we covered, you probably want to keep your Developer Tools open as you're working on the code throughout this course, just to see if any errors pop up. You'll occasionally want to clear the Console to get rid of the clutter and be able to see your errors clearly. And when things go really wrong, you can always open a file by coming to this Sources tab, hitting Ctrl + O, typing in the name of your file, and then you can set breakpoints, you can inspect variables, and you can generally go through the process of debugging to figure out what is wrong with your program.

JavaScript Patterns

There are some common patterns that you're going to see in JavaScript code when we start working with Angular, and I want to spend some time, before we go further with Angular, to walk you through some of these common JavaScript coding patterns. Maybe you haven't seen JavaScript use this way before or you just need a refresher, but I want to show you how JavaScript can be used as a functional language and how we can use functions to create abstractions. Abstractions are useful because they typically provide some sort of encapsulation to make other code easier to write, and Angular relies heavily on the functional nature of JavaScript to build abstractions. So all this knowledge will come in useful later when we get to the other modules. So let's start by talking about using functions as abstractions. Inside of my plunk, I've deleted the code that we had previously in script.js, so there's no more call to raise an alert here, and I also want to go in and I want to turn off the auto refresh, just so it doesn't confuse us. The code that I want to write in here is, first of all, I want to create a variable called work and I want that variable to immediately point to a function. The purpose of this function is to abstract away some sort of operation that needs to be performed. We need to do some work, we want to wrap all that work up inside of this function, and assign it to a variable called work. And the only work that we'll actually do in here is something very simple, which is I'll just do a console.log that will say "working hard!" So that should appear in the Console down here when I actually run this program. Currently, if I were to refresh the page, nothing would appear in the Console because we're not invoking work, we're just defining work, but I could invoke work, refresh my preview, and in the Console we should see "working hard!" Very good! But let's raise the level of abstraction, because quite commonly when you're programming with Angular, you're going to need to define a function that executes some work or an algorithm or creates some data structure, and you're going to need to take that function and pass it to Angular because Angular needs that function and that abstraction to execute something on your behalf. And to simulate that kind of scenario, let me create another variable called doWork. doWork is going to be a function, and this function takes a parameter, I'm going to call it (f). And this function expects that (f) will be another function, that is something it can invoke by applying parentheses. And so now, if I call doWork and I pass in my work variable that happens to point to a function, all of this should still work and we should still see "working hard!" when I refresh. because I'm passing that work function in to doWork, which is actually where the work is executed. And just to be clear, I'm not invoking work. What that would do is invoke work and pass the result, or something that is returned from work, into doWork. That's not what I want to do, work doesn't even return any value, so that would be passing an undefined into doWork. What I want to do is pass the variable work into that function so that doWork can execute the function that I'm passing in. And you might say, ‘Well why is that useful, why not just invoke work instead of creating some other function to invoke work?' And again, the whole idea here is to provide some abstraction, so maybe doWork represents some routine that can add retry logic, or some routine that can add value, perhaps by logging when work is going to start and logging when work is going to end, and perhaps the work that needs to be performed is some sort of dangerous operation. So we could even wrap that work inside of a try catch block, and then if something goes wrong, we could tell people that there has been an error, in this case I'll just log a message to the console, but you could certainly raise some sort of actual alert box in the browser to let the user know something went wrong. And this is just a common pattern when programming with Angular and really a number of JavaScript frameworks, which is, we're going to use the function as the basis for an abstraction. So, functions that do work, functions that execute work, passing functions to other functions so they know what job has to be done instead of embedding that code directly in that other function. Because what I have now with doWork is a generic function that can tell me when something is starting, when it's ended, and also provides some error handling. So, perhaps I could reuse that to perform different types of work, but this isn't the only way that we use functions in JavaScript and with Angular. Sometimes we also use functions to simulate modules. Let's look at that next.

Modules

Functions are a useful abstraction in JavaScript, but sometimes I need more than just a function. Sometimes I need an object, and that object has data and it has methods attached to it, and that's the type of abstraction that I need. And let me show you what I'm talking about from a client perspective. In other words, as a client, someone who is going to use an object that exposes methods and data, I want to be able to say that I need a worker object and I can get that worker object by invoking a function called createWorker. Once I have the worker, I want to be able to do things like - worker.(perform)job1 and worker.(perform)job2. And it's really not important what those specific jobs are. job1 could be call a web server, job2 could be massage the data that came back from the web server. We're not really concerned with those details at this point; what we're really focused on is how do I create this worker object that has two methods on it, job1 and job2. There's several ways to do that in JavaScript, but let me show you the common approach that we use with Angular. Right now I know I need something called createWorker that points to a function, and that function has to return an object that has job1 and job2 on it and they have to be functions that themselves can be invoked. So I know ultimately I need to return an object. This is the JavaScript literal syntax where I can just define an object and I can say ‘yes, it has something called job1', and job1 is a function and I can just have an inline function defined right here, maybe do a console.log inside of it, but I'm going to take a slightly different approach; Yes, I do want to return something that has a job1 method on it, but I don't want to define this function's inline. Typically when I sit down to write an object that's going to expose some sort of API, what I want to do is focus on the implementation details first. So I'm just going to create a variable called task1, and task1 just happens to point to a function that will do a console.log that says, ‘we are inside of task1'. And since this is a very simple example, let me just copy and paste that code and change this to be a task2 variable. And when that is invoked, it will print out the result, task2. And now the question is, how do I return an object that exposes task1 and task2 as methods that can be invoked when someone says worker.job1 or worker.job2, and again, the object literal syntax will let me do that. I can say job1 is a member of this object, and instead of defining an inline function here, I can say that job1 points to task1, and job2 points to task2, and now that will return the proper object, an object that has a job1 method and a job2 method, and the code I have below should work. I could also call these variables job1 and job2. In fact, most people will do that to avoid some confusion. Then the object that I return here, this line would be job1: job1, because that variable would be named job1. And below that we would have job2: job2, but this is just an example of how you can alias things. So I think of the top part here as my private implementation details, I can call these functions whatever I want. I could even have private functions that aren't exposed from this object, but when I return this object I'm really defining the public API. I'm saying here's an object that has two methods, job1 and job2, no one really needs to know what is inside, but if we were to come in and clear the Console and refresh this page, I'm able to see that I just executed task1 and task2. And to many people in JavaScript, if you go out and read about JavaScript patterns, they'll refer to this as the revealing module pattern. It's a module because what we've done is encapsulate some code inside of a function, and a module, the general meaning of that term in computer science and software development in general, some collection of components or features that you can put together to perform some useful work. So we're creating a module in JavaScript by defining a function. Inside of that function building up some things that we can use and expose to the outside world, and we can even have some private implementation details; for example, if I create a variable called workCount that counts the number of times that task1 and task2 have been invoked. That's not something that I want to expose to the outside world and allow them to manipulate it. It's just something that I want to use an internal implementation detail and perhaps each time these methods are invoked, I will increment workCount and I will also print out the current value of workCount here inside of each task. So workCount += 1 (Typing); workCount here also. So now let's clear the Console and also let's add a couple more calls to job2, Refresh, and you can see how workCount is incremented. So I have task1, we essentially did 1 unit of work, then 2, 3, and 4 units of work. And this is something that we'll do later in the Angular course, will be defining a function that returns an object that provides an API, or other pieces of code elsewhere in the application to use. And inside of that function that we created, this function like createWorker, we can have some private implementation details and properly encapsulate our work so that it's hidden and other people don't have to worry about it. Now the one drawback to the code that I've been writing so far, both this code and the previous code snippet, is that I'm creating global variables. Let's learn about what those are and how to avoid them next.

The IIFE

The createWorker function that we have is interesting, because it creates, in JavaScript, what is known as a scope. and the local variables that we've created inside of that function, variables like workCount, task1, task2, they are only visible inside of the function itself. So yes, you can have function definitions nested inside of other functions in JavaScript; that's how task1 can point to a function that is defined inside of another function that we assign to createWorker, and that's something that we'll do a lot of in this course. And it's also great, because task1 is a variable that is not visible outside of createWorker. If I try to go up to the worker object and invoke task1, that is going to be an error that tells me undefined is not a function; on line 28, that's essentially a way of saying, I don't know what task1 is, I got undefined for that, and then you tried to invoke it, and that's just not going to work. So I need to remove that line. The only way I can get to task1 is because createWorker explicitly referenced that in an object that it returns to the outside world. But task1 itself is inside the scope of createWorker, it's not visible to the outside. And these variables that I have outside of this function definition, including the variable createWorker and the variable worker, these are also in a scope, and unfortunately, it is the global scope. They are global variables because they are defined outside of any other code, outside of any other function. If you've been doing software development for any time, you've probably heard that global variables are bad. They easily become a source of confusion and bugs. But in JavaScript, global variables are beyond bad, they're downright evil. Because JavaScript is a dynamically typed language, it's very easy for me to override a global variable defined by someone else, and vice versa, and so we try to avoid globals at all costs. And so my next question to answer will be this, is there a way for me to define all the code that I have and execute that code and achieve the same output, where I see task1 and task2 executing, and to be able to do that without creating any global variables? While I can think of one easy way to create only one single global variable, what if outside of createWorker, I defined a function called program, and program is going to wrap up, not just createWorker, the function definition, but also a code where I instantiate a worker and call job1 and job2. Now currently, formatting is a little bit messed up, but if I go into the toolbar here of Plunker and I select ‘Beautify my code', that will go through the code and make sure that I have the proper indenting everywhere. And now, let me temporarily close the Developer Tools so we can try to get this all on the screen. Now what I have is currently no global variables, because createWorker and worker, they're both now just variables defined inside of this program function, the only global variable I have is program itself, and now if I invoke program, I'll be executing this function, which will create a worker and have that worker perform some jobs. So if I open up the Developer Tools again, and let's clear the Console and run the program, I get the same output I had before, which is the worker spits out task1, task2, task2, task2, with a count of all the work being performed. So I'm down to one global variable, but how could I get to 0 global variables? Well what if instead of declaring a variable here called program, which will be global, what if I just took this function, and at the very bottom of that function definition, I just had it invoke itself? Well there's one little problem here, in that JavaScript doesn't particularly like this syntax, it doesn't like to have an anonymous function just sitting here that invokes itself, and what I have to do is apply an extra left parentheses before the opening keyword function and then have a corresponding closed parentheses at the end here before the semicolon. And now what I've built is something known in the JavaScript circles as an immediately invoked function expression; it is a function that I have defined that has some functions and some code inside of it that just immediately invokes itself. The end result being that if I clear the Console and load this page, I now have all the same code executing that I had before, but because all of that code is wrapped up inside of a function, I'm not creating any global variables. All the variables that are being defined are local variables inside of that IIFE, that immediately invoked function expression. And yes we'll use the occasional IIFE in this course to avoid creating any global variables. So, we will see this pattern at work, and yes, you'll see it in a lot of other JavaScript code. A lot of libraries use IIFEs to control the scope of the variables to build modules to provide encapsulation, and most of all to avoid those global variables.

In Conclusion

In this first module we did very little with Angular itself, but we did lay a foundation to dive into Angular in the coming modules. We set up a plunk in a Plunker and learned how to reference the Angular Library, Bootstrap and Angular application with the ng-app directive, and create a small expression to put some information on the screen. We spent most of our time making sure we know how to use our Developer Tools and the Plunker interface, as well as reviewing some common JavaScript coding patterns we'll see in the modules to come. I encourage you to try those patterns out on your own, experiment with them and make them do different things, even throw errors - that's the best way to learn. From here on out will be all Angular all the time.

Controllers

Introduction

Hi, this is Scott Allen, and this module is all about Controllers in Angular. Controllers are one of the central pieces of the Angular framework, and in working with Angular, you're going to create many different controllers. As the name implies, controllers are in charge of an area of the application. And with Angular, a controller is in charge or responsible for building a model. A model contains the data we need to work with and a controller will do whatever it needs to grab that data. So it might need to make some calculations or call back to a web server that talks to a database, whatever it takes. I'll show you how to build a controller that is able to build a model, and then we'll be able to use data binding to show that model in a view; the view is the HTML for our webpage.

Controller Basics

There are four basic facts for you to know about a controller. Now remember, the job of a controller is to control the information that we need to put on a page, or in an editing scenario to save the information that a user is typing into the page. And to bring a controller to life, the first thing we'll see is a new directive, the ng-controller directive. ng-controller is an attribute that we place into our HTML. So just like ng-app is a directive, ng-controller is another directive. And when we use ng-controller, we can specify the name of a controller that we want to take control of some area of the HTML. So in this code snippet, ng-app will initialize Angular and Angular will take control of that div and everything inside of it. Inside of that div is a child div where we can put something called the MainController in charge. So ng-controller can only be used where we have an ng-app in place, and we have to tell Angular the name of the controller that will be in charge. In this case, the controller is MainController, and we have to name these controllers, because in large applications you can have dozens and dozens of different controllers to use. So now the question is, how does Angular know where this controller lives? And the answer is that we'll need to create a controller with that name, MainController, and we can do that by writing a function and assigning the function to a variable with a matching name. As you can see in this code snippet, controllers are just functions. We don't invoke these functions; Angular will invoke this controller function when it needs to create a controller to manage an area of the webpage. And, when Angular creates our controller, it can pass a parameter to our function, a parameter we call $scope with a dollar sign in front, $scope. You'll encounter a few things with dollar signs in the front when you work with Angular, and just like the ng prefix, the dollar sign prefix is a sign that the component you're working with is a component provided by Angular. What we can do with the scope argument is assign our model to the object. So $scope is not the model, but things that we attach to that $scope are going to be the model. In the code snippet, we've only attached a single property to $scope, it's called message, and it points to the string "Hello!" This will now make message available to us inside the HTML so we can data-bind it into the display. Let's take a look at how that works. Here I am on the Plunker webpage. I've just created a brand-new plunk, but I haven't made any changes to it yet. Let's get set up to use Angular and create our first controller. So we know one way to get Angular is to come into the list of packages and just tell Plunker to install Angular for me. That's going to put in the script reference that points to angular.js. And once I have that in place, I'll need an ng-app directive. I'm just going to place that on the HTML element, but it could go anywhere. And what I want to do ultimately is put a controller in charge of the body and everything inside of it, and provide the ability to write out some sort of custom message. So, instead of the page displaying "Hello Plunker!", I want to be able to display something like, "Hello Angular!" or "Hello Scott!", and to do that, I will create the controller and I'll call it MainController. Now, a lot of people who work with Angular and a lot of the documentation you'll come across, you'll see that people abbreviate the name controller to just CTRL, and that's fine, that works perfectly well. It doesn't matter if you spell it this way or the long way; really just as long as you're consistent inside of an application, that's what would matter. I prefer to type out the word and just have MainController the full word; I'm not a big fan of abbreviations these days, unless they're really necessary. So, now I'm asking for a controller, and if I were to run this webpage, I would find that I have some errors collecting inside of my Console. If I look at that, one of the errors that will be here is Angular complaining that it cannot find a MainController, which makes sense, we haven't written that yet. So, let's do that. Inside of script.js, which is included in this page, I'm going to define a variable, MainController, and is this variable a global variable? Yes it is, because I'm defining it outside of any other code. We'll come back and fix that later. (long pause) But this MainController will be the controller that Angular is looking for, and one of the parameters that you can always pass into a controller is $scope. As we work through the course, we'll see there are other parameters that you can accept into a controller function, but for right now we just need this one, which is $scope, and now I can attach one or more things to that scope. So I can attach something called message and set it equal to "Hello, Angular!" And now when my page refreshes, I have this model, which is a message attached to my scope, and I have it displaying in the webpage, thanks to the data binding expression from Angular. And if you think about it, perhaps you can see why that argument that is passed to my controller function is called $scope, because it is establishing a $scope where the data binding expressions are evaluated again. So if I have something in my HTML called message, where is Angular going to look for message? It's going to look for it on the $scope object for the controller that is associated with that section of the HTML. And I can do some fancier expressions, so inside of the HTML I could say, ‘let's output, not message, but message.length", because every string has a length property and the length of that particular string is 15 characters. That might not be what I want to display to the user, but that was a perfectly valid expression inside of the curly braces. If I were to take that expression, the h1 that is inside of this body, and move it outside of the HTML element that has this ng-controller directive, then it would no longer work. I'd be trying to find a message, and the only place a message exists right now is inside of the MainController. So I have to use this expression inside of the body tag that is specifying your controller, that makes that message available. Let's build on this example in the next clip.

The Capabilities

Now we've seen a controller in action, and we see that the primary responsibility of a controller is to set up the model on our $scope object. Angular passes $scope to our controller function, and our controller manipulates that scope. Notice how our controller never has to directly manipulate the HTML, or what we call the view? It only manipulates $scope by attaching a model. And then we use binding expressions to move data from the $scope into the view. In future modules, we'll see how we can also set up methods to react to events. So when a user clicks a button or types into a textbox, we'll be able to know about that from the controller, but we'll do that with directives. So, again, the controller doesn't have to reach directly into the HTML to hook up events, and this setup creates a nice separation of concerns, where the controller is focused on $scope and the view is focused on HTML with some directives. And other than specifying which controller to use inside of my HTML, the view and the controller never interact directly. If you've ever worked with jQuery, you know that's a much different world, because your JavaScript code typically directly manipulates the HTML. And it looks inside the HTML to find elements to catch events and you have to write code to move data between your JavaScript objects and the HTML. Angular simplifies these scenarios and you write a lot less code that is also better factored; it has a separation of concerns. And here's a few other things that we can do with controllers. First, on larger applications, you'll almost always have multiple controllers in your application. Probably even on the same page, because each controller is going to be responsible for different features or different areas of data. So here's a page with three controllers; the Date, Quote, and Chart Controllers. You could also work against more complex objects. So instead of just having a simple message property on my $scope object, I might attach a Stock property to reference an object with symbol and price properties. And the binding expressions allow me to use dots to navigate inside of an object that is attached to $scope; stock.symbol, stock.price. And then there's a couple interesting things about the ChartController. First, you'll notice it's nested inside of the QuoteController. This is an advanced technique we probably won't use in this course, but I want to make you aware that it's possible. Also in this controller is something we will use, and that is, we can use binding expressions, not just to display text on the page, but we can also use them to set the attributes inside of our HTML. So in this example we're setting the source and the description of an image. And I'm showing this example to let you know that you're not restricted to displaying just text on the screen. You can control anything you need just by setting up the right model data and then binding that data into the page at the right location. Let's try this out ourselves. Inside of our plunk, let's swing over to the MainController and I want to now display information about a person. So just using the JavaScript object literal syntax, I'll define a person object, and let's give that person a firstName of Scott and a lastName of Allen, and I even want to give this object an imageSrc that has a URL that points to a picture of me, a slightly dated picture, but that's okay. Now just defining this person variable inside of the controller function does not make that object available for data binding. Right now that variable is only available inside of this function, but I can take that variable, that person, and attach it to $scope, and now my binding expressions in the view can reach into $scope, into this person, and display the firstName and lastName. So let's try that. In index.html, I'll leave the message here, but let's create a div that will contain person information. So, the first name of the person is person.firstName. And the last name of a person is person.lastName. And then let's try to display the image, so I need an image whose source is equal to person.imageSrc. And instead of using an Alt tag, which is good, I'm going to use a title tag to show you an expression that will appear if I mouse over that image. So inside of here, I want to put in person.firstName, space, person.lastName. And now once the page refreshes, if I mouse over, I can see that displays Scott Allen. So I'm using that model information, not just to display text on the screen and intermingle binding expressions with literal text, I'm also using my model to set attributes of an image so that we can display a picture on the screen. Now, one quick tip about using a binding expression in the source of an image, you have to think a little bit about how a browser works. When this HTML renders, the browser is going to see "<img src=" and then this binding expression. It's not until later when Angular is up and running, that it comes in and replaces person.imageSrc with the value from my model. But unfortunately, the way the browser works, as soon as it sees "<img src="{{person.imageSrc}}", it's going to go and try to download an image, treating that binding expression as a URL. And in fact, down inside of the Console window here, you can see that each time it refreshed the Preview window, it tried to grab that image and got a 404 error, could not be found. And this is why Angular provides a directive, ng-source. You'll notice now the Preview window refreshed, but I did not get a 404 error and I still have my image. The purpose of the ng-source directive is that once Angular is up and running, once it has evaluated this expression, then it will come in and set the actual source attribute for that image and the image should be successfully downloaded and you'll avoid these 404 errors. So ng-source is just a directive to set the source of an image when there's a data binding expression involved. That's a quick little tip, and there are many more directives that we'll see, particularly in the next module. I also just want to point out one other thing about Angular. Let's say I have a typo here, and instead of person.firstName, I forgot the ‘e'. And a couple things to notice; first of all, the firstName did not display in the Preview window, because I'm trying to reference a property that doesn't exist on person, and secondly there was no new error creating in the Console window. This is the way Angular works and it has some pros and cons. The pros are that a page doesn't break just because something isn't available. Now in this case, I have a typographical error - I meant to type firstName, and I wish this would've been treated as an error so I could catch it without visually examining the page and seeing that that doesn't appear. However, the Angular philosophy is, if a binding expression doesn't work, don't throw an error, just continue on, because you might be trying to bind to data that doesn't exist yet. It's data that we have to retrieve from a web server and massage before we make it available. And so it's okay to try to bind person.firstName, maybe person doesn't exist yet, but it's not going to break the page; it'll fill in later when we get the data. But that does mean that you have to watch out on your page, and make sure it's displaying the expected data. But what about the scenario I'm talking about; the scenario where I want to display person.firstName, but it's not available yet because I have to retrieve it from the server. Let's actually try to retrieve some data from a server, and see how that works with our controller and the model and the data binding.

Calling HTTP

When we're writing code inside of a controller, we usually don't just make up our data, like we're doing with the person object in the last clip. We need to fetch data from our web server, and our web server might need to talk to a SQL database to send us back the data we need, or it might talk to a no-SQL database, or XML files on the server's disk; we really don't care. We just need data from that server, so we need a way to communicate with the server, and this is the job of the $http Service in Angular. HTTP is a service that Angular provides, and this service is just an object, an object with methods I can use to make HTTP calls. In fact, the methods are named after the HTTP methods that I commonly use, so the methods on this object are methods like GET, POST, PUT, and DELETE. And HTTP GET is commonly used to read information from the server, as in get me all the details for this user, while POST, PUT, and DELETE, they typically modify data somewhere and save or delete information from a database. So how does one access this $http service in a controller, and the answer is, just like with $scope, I can ask Angular to provide me with the $http service just by having a parameter on my controller function named $http. It has to have the dollar sign in front and be all lowercase, because JavaScript is a case-sensitive language. And once I have the $http object, I can use methods like .get, .post, and .delete to communicate with the web server. So the code you see here is sending an $http.get message to the URL, /users/1783, presumably the 1783 is the ID of the user that I need information about, and now the server has enough information to go off and find that data and return it to me. Every API will be a little bit different, so the URL that you use in a call to $http.get will probably be a bit different for your software compared to my software. Now the code on the screen, though, has a serious flaw. It is calling $http.get and assigning the result to $scope.user; however, the HTTP communication methods on this object never ever return the data you need immediately. That's because all communication is asynchronous. When I call $http.get, that will start a request to the web server in the background and that call might take 250 milliseconds or it might take 25 seconds, but I'm not going to be able to get the result immediately, like this code here implies. What the $http methods do is return an object immediately, known as a promise. A promise object is an object that promises to give you some result in the future, and that result might be the data that you need, or the result might be an error if the server was unavailable. The way I find out is to call a then method on my promise and pass the then method a function that will be called in the future. So, again, we see the pattern that we talked about in the introduction, where we pass functions to other functions to do work. The then method will call my function when the data is ready sometime in the future, and it will pass the data into my function as a parameter. Here I'm taking a parameter named response, because the promise for an $http call will pass to me an object that represents the $http response, including things like the $http status code, but in many cases, all you need to look at is the data property of this response, because that will contain the data that the web server has returned to you. And now I can take that data and add it to my $scope as a user property. That makes the data from my server available to use from the view. Many people when they write code like this will shorten it up just a bit into a single series of chained functions. So, $http.get, pass in the URL, .then, here's how I want to process the response. Now before we write this code ourselves, let's take a look at a server API that we can easily use for my controllers.

Using $http

The API I want to use in my demo is the GitHub.com API, and I do this for three reasons; the GitHub.com API has three characteristics, which very few real APIs with real data have. #1, the API is available to call from JavaScript in a browser. #2, the response is in JSON format, which is easy to consume from JavaScript. In fact, Angular's $http service will automatically convert a JSON response into a JavaScript object for me. And #3, the service does not require me or you to sign up and provide authentication credentials or some sort of client or application key, so it's easy to use. This isn't to say the situation might change in the future, but I hope you'll still be able to use this API when you view this video. Here's what an API call looks like; I can go there right from a browser that will issue an $http.get request, and this is a get request to api.github.com/users/odetocode. So I'm asking for the user details on the GitHub users/odetocode, and I can see a response that will give me data like the name of the user, the location of the user, even the gravitar of the user, which is the image commonly associated with this user. So I'm using this GitHub API to simulate data that you might get back from your web server for your application that comes from your database, but I don't want to set all that up just to learn Angular, so let's try to use this GitHub API as a source of data. Inside of our controller, let's get rid of the fake person data that I constructed, and instead, let's ask Angular for the $http service and we can use that to call the GitHub API. So, I want to issue a get request to https, so this is secure sockets, api.github.com/users, and now instead of me, let's use robconery. $http.get is going to return a promise. So I don't get details about robconery immediately. What I need to do with that promise is invoke a then method and process the result, and I can do that by writing a function here, an anonymous function that I just pass into them, or I can write a named function up here, a private implementation detail of the controller, and just pass that function into the then method. We did some of the same sorts of things inside of the introduction. So, onUserComplete, as I have gotten the details of the user in a response from that http request, the promise will pass in the response; all I really need to do is pick out the data portion of that response and I can say "$scope.user = response.data". So, this web server will send data back in JSON format, Angular will automatically deserialize that data into a JavaScript object for me, and now $scope.user will have the same properties that we saw in the previous slide for that response from GitHub. It's going to have properties like name, location, avatar_url. All I need to do is tell them that the function to call, when this $http request is successful, is onUserComplete, and that will put everything I need into my user object. Let me turn on auto refresh. And we'll go over to our view, and fix this up to work with the new information we have. We don't have firstName and lastName anymore. Instead, what we have is the user's name, which is user.name, we have the user's location, which is user.location, and now for the image, I have that avatar_url. So let me first set the title of the image to user.name, so when a user mouses over, they can see that that is the person's name, and ng-source now becomes user.avatar_url. And again, if you don't remember what these properties are, you can just launch a web browser and go to this URL. You will see those properties in the output, but now that we've put all this together, we do get Rob's name and location and image on the screen. So let me show you one more thing about the $http service. What would happen if the server was down or let's say I just had a typo in the URL that I was trying to get to. Well that will create an error in the Console. I can see that that URL ap.github.com, it couldn't load for whatever reason, and of course my Preview screen goes blank because now I don't have a user attached to $scope; there's no data available. This function that I pass into the then method, the first function I pass in, that's only invoked if the get call, or the post, or the put, or the delete, whatever you're using, it's only invoked if that call is successful, and the web server returns a successful response. If there's an error, I can pass a second function to then, that will be called if there's an error. So let's write a function on error, that's a function. I will actually get a reason for that error, which will contain all sorts of technical details about the $http request. Perhaps I'm not interesting in any of that, I just want to tell the user that I could not fetch the user, and just have that on the screen so there's some visible indication that something went wrong. And now I can come into index.html and I can find a location where I could put that message. So, perhaps up here I could just say, bind error, and now "Could not fetch the user" appears. If I go back into script.js and I fix my call, now we're back to getting Rob's information. So this is the $http service, very easy to use. You just have to remember how to program with promises, invoke a then method, and give it a function to call when you have a successful response and grab the data out of that. You can also optionally give it a second function if there's an error, inspect the reason, and probably tell the user that something has gone wrong.

Controllers and Modules

Earlier in this course, I mentioned that the controller that we're creating in our plunk, the MainController, it's living in the global namespace, which is usually bad. When you are building your own application with Angular, you probably don't want to do this. And if you ever go to look at other applications built with Angular, you'll rarely see controllers in the global namespace. We only do that in simple demo applications. Instead, what you'll see is the controllers live inside an Angular module. Now the word module is overloaded in JavaScript. We have the module pattern, we have the revealing module pattern. I showed you that one in the introduction. And then we have Angular modules. And all of these are not exactly the same thing, but they all have similar goals, which is, I want to provide some sort of container for the code that I write, so it has some place to live and it's not in a global namespace. I don't want identifiers leaking out and cluttering up someone else's code. So my goal was to create an Angular module as a home for my controller, and then I can have many different controllers in that same module. If my application is complex, if it requires 20 different controllers, I can put all 20 into the same module. I can even have multiple modules for my application. Now that all depends on how complex the application is, does it have to share features with other applications, how do I want to go about unit testing the code inside of a module; all of those are decision points on when do I need a new module, when do I use an existing module, and those questions are slightly beyond the scope for this course. I just want to show you how to create a single module and place a controller inside, then we can use modules throughout the rest of the course. And working with modules is, fortunately, simple. The first thing I need to do is create a module and give it a name. I do this with an Angular API, angular.module. Angular, that particular object, is the one single identifier that Angular puts into the global namespace, so I can use it anywhere where angular.js is included. And that Angular object has methods like, .module, that will allow me to create a module or get a reference to an existing module. The way I create a module is to pass in the name of the module, in this case it is githubViewer, and then I can pass in an array describing the dependencies for this module, because modules can depend on features from other modules. This is a lot like how libraries work for certain languages, or in .NET the way assemblies work. I have an assembly that I wrote and it has dependencies on other assemblies; Angular modules are much the same way. In this case I'm passing in an empty array because my githubViewer module has no other explicit dependencies. Now implicitly, it does depend on a core Angular module, but that's always assumed so I don't need to specify it. Later in the course, we'll take a dependency on another module. Then once I have the module defined, there is an API on that module object that allows me to register my controllers, as well as other types of objects. Right now we're just working for controllers, but I can register my controllers with that module. And the name of the function to do that registration is named, conveniently, controller. I pass in the name of my controller as a string, and then the function that I use for the controller. That's the function that will take the $scope and the $http arguments, as well as anything else that controller needs to do its job. The third step in working with modules is that now that I have a module, now that I have some things registered into it, I need to tell Angular about this module when I bootstrap the application. If I've created a module that represents my application, then when I use the ng-app directive, I have to tell Angular, the module you want to be using is githubViewer. Load that up, Angular will go out and look for that. When it goes looking for a controller, it can look inside of that module, and everything will still work as it did before, but it won't be putting anything in the global namespace. So just three simple steps to working with modules. I create the module, I register my components in the module, and then I tell Angular to use that module. Let's try this out.

Creating a Module

Inside of our plunk, MainController is currently in the global namespace. I want to change that. Now, back in the introduction I showed you one way to keep things out of the global namespace. And one way to do that is, I could surround all of this code with an IIFE, an immediately invoked function expression. So I will just apply the proper parentheses and then I will try to beautify this code so that the indentation is correct. Unfortunately, when I do this, Angular now has an error that it cannot find the MainController, and as you can see in the Preview page, the application completely breaks down and I just see data binding expressions, because Angular couldn't find MainController, it didn't have any way to control that portion of my HTML markup, because MainController, it's not in the global namespace now, it's only available inside of this function. If I want Angular to be able to use this controller, I'm going to need to create a module, I'm going to need to stick this controller in the module. So let me do this starting backwards. I'll go in my index.html, into my view, and I'll say that the ng-app to use will be something called githubViewer, and now Angular will probably complain that it doesn't know what githubViewer is. That's because I haven't created the module yet, but at least I know that Angular is looking for that module. So back in script.js, let me create this module definition; I'll put it here at the top. Now many people, when they're working with Angular applications, what they will do is keep each component that they write in a separate .js file. So if I'm defining a module for my application, I might put that in a .js file called app.js, and I would put MainController in maincontroller.js, and then a second controller that I create goes in secondcontroller.js. And this works out really well for development because we don't want all of our JavaScript code inside of one file that can be thousands and thousands of lines. Instead, we break our JavaScript into separate files and each file has an individual component, but I'm just going to create the module in the same file as my controller just to keep things a little bit simple, and later in the course we'll use multiple JavaScript files. So, I will assign angular.module to a variable called app, and you can call that variable whatever you want. The name of the module is githubViewer, and then it's very important to pass that second parameter, which is an empty array, because otherwise you won't be defining a module. Instead, you would be asking Angular to get a reference to a module called githubViewer, and that would only work if someone else had defined githubViewer; here we have to define githubViewer. And now that I've created the module, I register my controller in the module, I do that by saying, dear application, here is a controller named MainController, and here is the function to use when such a controller services are required. And you notice as soon as I do that, the Preview window refreshes, everything is working again, and we don't have any errors. So you can see that working with modules is very simple, and also a good practice because it does keep that global namespace clear. Now let me tell you about something different that you'll probably see when you go out and you look at real world Angular applications. And that is that, most of them do not use the syntax where they just pass in MainController to this controller method. Most of them will actually pass an array as the second parameter here, and MainController is the last item in that array. The reason they do this is because most production applications, the JavaScript goes through a process known as minification. And if you've ever worked with a minifier before, you know that the minifier's job is to make the JavaScript code as small as possible so we have a smaller download to give to the person who is viewing our webpage; the page will load quicker. And the minifier makes the JavaScript smaller because it strips out unneeded white space. It will also change the names of local function arguments. So $scope might turn into the letter ‘n', because then instead of using 6 characters, we're only using a single character everywhere that we reference $scope, so this will become n.user and n.error and n.message. But the problem is that Angular has to see the name $scope or it has to know somehow that the first parameter you need here is your $scope object and the second one is the $http service, because Angular is responsible for providing those specific objects to you. And one way to tell Angular about that and still run a minifier that can change the names willy-nilly, is to, when you register the controller, you pass in the parameters that it is going to require. So, here I am telling Angular that when you create the MainController, it's going to need two parameters, $scope and $http, to pass those in here regardless of what those actual function argument names are. So not something we have to worry about in this course; this is just a little note to let you know when you move to production someday in the future and you go to minify your files and everything starts breaking, it's probably because you need to come back and tell Angular more explicitly about the dependencies that things like your controllers need.

Summary

In this module we took a look at controllers, and one aspect of controllers is how they manipulate $scope and thereby avoid interacting with the HTML directly. Instead, we attach data to the $scope object and we use binding to lift that data into the view. We also created a module for our controller to live in. This keeps the controller out of the global scope and will continue to use modules in this course. And finally we saw how controllers can use services from Angular; services like the $http service. There are many services in Angular and we'll see more as the course progresses, but the $http service, it was important enough for us to use early on, because this is the service that we use to grab data from a web server. The $http service methods return promise objects, and those promise objects, we can use them to grab a result in the future. We do that by using the then method. In the next module we'll continue to build on what we know and we'll build a more complex view, a view that has to work with an array of data and a view that requires click events from the user to interact with the page. All that and more in the next module on Views and Directives.

Directives and Views

Introduction

Hi, this is Scott Allen, and this module is focused on Directives and Views in AngularJS. We've used some directives previously with Angular, directives like ng-app and ng-controller, but now I want to show you some other useful directives, like the directive to handle button clicks and the directive to move user input into my JavaScript model. These directives allow you to build interactive webpages that not only display data, but also react to the user and become a little more dynamic. We'll build something that lets the user search, sort, and browse code repositories. But before we begin, let's review the purpose of directives, in general.

Philosophy

Based on what we've learned in the first two modules of this course, we know that the way to make data appear on a webpage with Angular is to add the data to a $scope object inside of a controller. We usually call the data attached to $scope, the model, and we've seen how we can display the model data on a webpage without the model or the controller knowing anything about the view or the HTML that we use on that webpage. The controller and the model, they live a life completely free of worrying about what appears in the browser. The way we make the model data appear on the screen is to use binding expressions. And these are actually one type of directive in Angular, a Data Binding Directive. And these binding directives can reach into the model, pull out the data, and put the data in the proper location on the screen. And this is just not to show text to the user. We've also seen how we can build the right URL for images by using model data. We can use these binding directives anywhere, to build any sort of presentation for our data. And this is a nice separation of concerns; the controller and the model are focused only on gathering the data, the view is focused only on presenting the data available from the model. And believe me, this makes life much easier than working with software that does not separate the concerns of managing the data itself, versus managing the presentation of that data. But what we haven't seen yet is this; what if we need to move information from the view back into the model? Because just like an API on the server, our HTML can be a source of information too. An example would be this HTML form, there's actually a couple sources of information in this form. First is the input, or the user can type text. We need to move that data back into the model so we know what type of message that the user wants. Another source of information is the form itself. We want to know when the user submits this form or clicks the Save button, because this information, which is an event, it's important; it means we might need to manipulate the model in response to that event, or send something to the web server to save and commit the user's updates. Fortunately, directives help in this scenario too. Directives are all about letting the view and the model work together without requiring direct interaction. And just like we have directives to move data from the model into the view, we also have directives to move information from the view into the model. And many of these directives work in both directions, so if data changes in the view or the model, the directive will keep both sides in sync by propagating the changes throughout the application. So let's get an application set up and learn about some new directives.

ng-model

For this module, I'm going to continue to work with the plunk that we created in the last module. This plunk is already set up with AngularJS included in the page, and we have a few features here. We have the ability to display information about a GitHub user. I'm currently displaying Rob Conery's GitHub information, but if I want to see a different user, I need to come into the source code and change this username portion of the URL, my Preview window, which is in an external window now, so we have more space for the Editor, it's still set up to automatically refresh. Now I can see new user information, but let's try to make this easier. What I want to be able to do is come into this page and have an input, where I can type in any username that I want, click a button, and then it will go out and fetch user information for me. So instead of hardcoding that value, I want to be able to input that value as a user. To do this, let's come over into index.html, and here above where I'm displaying user information, let's create a form. I did not need an action, but I think I'll give this form a name, let's call it searchUser. And inside the form, which will not be the prettiest form you've ever seen, let's have an "input type="search" This is where I'm going to be able to type the username. So I'll put some placeholder text here of "Username to find", and for right now I will close this off and let's have another input, which will be the button I can click on. So this will be "type="submit", and the value would be, let's have the text "Search". So one of my first jobs with this form is that I'm going to need to know what the user has typed in to that Search input. And we've seen how easy it is to move data from the model into the view, but there's a different directive that I need to use to move data from the view into the model. And that directive is, ng-model. With ng-model I can specify an expression, like username, and what ng-model will do is, as the user types into that input, ng-model will push the value of the input into my $scope object using this expression. So in this case it's going to appear in my $scope as a username property. And if that property doesn't exist, which it currently doesn't, we have $scope.user, $scope.error, $scope.message, so we don't have a username property, but that's okay. This ng-model directive will create that property for me and give my scope a username. In fact, we'll be able to see that, if I put a data binding directive here to display username, that will be evaluated against $scope, so whatever username is should display both in that binding directive, and also in the input. Let's flip over into our page, and try it out. Currently notice that there is no username displaying, but I do have my Search form, and now if I type robconery, you can see as I'm typing that string, it's appearing as the username above the Search form and it happens instantly with every keystroke. And if for some reason I were to change that username from my model, maybe because I got some information back from a web service call, that updated username would appear both inside of the input and also above the Search form where I have the username binding. In fact, I could initialize username inside of my $scope. Let's do a $scope.username. We can say the default username to search for is Angular, and let's change our message. We're not being introduced to Angular any longer. What we're sort of building is a GitHub Viewer. And now as my Preview window refreshes, you can see Angular appears there automatically. In fact, let me do an F5, a hard refresh, and you can see that username is there. What we currently don't have is the ability to type in a new username and click the Search button, and have the application go out and find information about that specific new user. We're going to have to handle this click event, this form submission. We'll do that next. But for now just know that ng-model, an extremely useful directive because you can apply it to inputs, you can apply it to selects, you can apply it to text areas, and what ng-model will do is always keep your data in sync; it's going to move information that the user types into your model. And if for some reason the model changes, it will move that information back into your input.

ng-click

Now I want to know when the user is ready to search for a particular username, and there's a couple different ways I can do that. One way I can do that is to attach a directive to the "input type="submit", and this is the ng-click directive. Just like with ng-model, I can put an expression in here. Typically with an ng-click, you put an expression that's going to be a function call. Because what I want to happen, when someone clicks on that button, is I want Angular to go out and find a function that is defined on my model, so it's attached to $scope, and then I want Angular to invoke it. In this case it's a Search function, and then inside of that Search function I'm going to write the code that gets the username, calls to the GitHub API, and retrieves information about that particular user. When you write expressions for ng-click, some of them can be rather fancy. We can even include things like parameters to that method call. In this case I'm going to call search and pass in the username. That's really not necessary because $scope will already have username as a property thanks to ng-model, but I'm going to leave that parameter there just so you can see how easy it is to call search and pass something along. And now before we go and implement that search, let me just clean up the user interface a little bit. I want things to be able to fix on this page, and I also want to clean up some of the things down here. Instead of having all these divs, let's just have a single div with an h2 element inside that displays the username that we retrieve. And then I'm not so much worried about location and so forth, and the image, I'm going to change that around a little bit too. Instead of displaying the avatar, which is often a large image, what I want to display is the gravatar, which by default is an 80x80 pixel image. It's much smaller and it will fit on the screen a little bit nicer. And in order to do that, I need to look at the gravatar_id that comes back from the GitHub call that we're going to make, and that's going to be part of our user model. The gravatar_id is basically a hash, but then if you take that gravatar_id and you use it in a URL that point to www.gravatar.com/avatar, if I use it here, gravatar_id from the user. That should be able to display that user's 80x80 image, and that's going to leave us more room on the page to display other information about the user. And now, I can see a couple errors down here in the Editor, I have a missing end div tag, I think that was right there. Now we can go, and let's implement our search. Inside the controller, instead of immediately sending it off an $http.get request, I'm going to create a search attribute on my $scope and have that equal to a function that takes a username parameter. And then I will send off the request, and I need to include that username in the request. And essentially, instead of hard coding Angular, we're going to add in username, and now let's flip over into the Preview window and see how this works. Now the first thing you'll notice that there's some odd image here. And this is because we don't have the gravatar_id of a user yet, but we still have an image tag that's trying to grab an image from gravatar.com and it's just giving us a generic image back. We're going to fix that later, but right now I just want to see if I can search and get the proper Angular information, that looks correct. If I go out and search for this, I get the right name and the right picture. So our code appears to be working. What happens if I search for something that doesn't exist? Just type in gibberish, but not fetch the user, so our error message works. Basically what happened is I sent off that $http request that probably came back with a 404 saying, ‘I don't know who this user is.' That will invoke our error handler so we can display that message. What happens if I don't enter any username? Well at that point, nothing happens. It would be nice if we could tell the user that they need to type something into that field. And one easy way to do this is to add an HTML validation attribute required, but in order for the browser to be able to tell the user that this particular input is required, I won't be able to handle ng-click on this button event. Instead, what I can handle is the ng-submit. Use that directive to catch the submit event of the form and then have that call search, passing in the username, that will work just as well. Let's get rid of that username, which --- was displaying some debugging information, come back to our Preview window, and now we can still find Angular. If I search for nothing, I get a nice little validation message from Chrome, saying I have to fill out this field, so fine; I'll fill out Rob's name and now we can get Rob's information. So using ng-model and then either ng-submit or ng-click, we are able to take some information that a user has typed in, apply that to an API call that we make to GitHub.com, and we can now retrieve information about different users. But let's find out some additional information about a user. It turns out that one of the pieces of information that will come back from GitHub is a URL that we can go to to get all of the repositories for that user. This is an interesting exercise because, if we want to display all those repositories, we're going to need some sort of loop inside of our view code to create a table, row, or a list element for each repository. Let's try this next.

ng-repeat

The information we receive from GitHub includes this repos_url, which if we follow that link, we will find out information about the repositories associated with that user. So the first thing I'll point out about the response is it starts with a bracket and a JavaScript object notation that means we're dealing with an array. So what we have is an array of objects, where each object represents the information about a specific repository. Information like the name, and then if we scroll down a bit, we can also see there's information about the number of stars that repository has, as well as the primary language that GitHub has detected for that repository. And this is the information that we want to retrieve and display on the screen. So we will start back in our controller. Once we receive information about a user, we can issue another $http.get request and send this one off to $scope.user.repos_url. That will retrieve the repository information, that particular method call, though, will only give us a promise back, so we have to call then, and then I'll say, ‘when we have repositories' or ‘when we have an error'. I might want to fix up this error function to say, ‘could not fetch the data'. Typically in a real application you'd have to dig into this reason, perhaps inspect the status code and the URL that was being called, and come up with a more specific error message so someone could diagnose exactly what went wrong. For now I'm just going to leave onError like this, and now I need onRepos, also a function that takes a response that will be all the repository information, and I will attach that to "$scope.repos = response.data". There's actually a couple different things I could do there. I could take that repository information and attach it to user, so "$scope.user.repos = response.data", but I'll leave it as a top-level collection here in the $scope that will also work. And although I'm not a big fan of the abbreviation, r-e-p-o-s, I'm going to stick with that since that is actually the name of the field that GitHub returns. And using that will reduce the chance of confusion. Now over in the view, I need to walk up to that property and be able to display information about each repository. Typically you would display information from an array inside of an unordered list or a table. I'm going to go with the table because I want to display multiple things about each repository. In fact, as I write out the thead here, we'll figure out exactly what we want to display. Let's display the name of the repository, the number of stars for that repository, and the primary language for that repository. And now I'm going to write the tbody and this is where I will need a table row for each repository. I just want to do that with Angular. That's the job of the ng-repeat directive. So I will write an expression here, "repo in repos". And the idea is that ng-repeat is a lot like a for loop, or more like a foreach loop in C# if you use C#. There is going to be a variable repo that will contain the value of each repository in that collection as we iterate, or loop through, that array of repositories. What ng-repeat will also do is take this element, this tr, and stamp that out for each repository, so for each time through the loop, and it's also going to include any child elements inside of that HTML. So if I write out a table cell, I'll get a row with a cell for each repository. Inside of the first cell, I want to write out the repository name, so it says if repository is available inside of the $scope where ng-repeat lives, and in fact that's exactly what is happening, repo is available inside of here, we want the stargazers_count, and we also want the language for the repository. And now if I have 10 repositories, I should have 10 tr's. Let's flip over into the Preview window and try this out, search for Angular, and it looks like I have a successful result. Now there are a couple issues with this display, one notable one would be that the format for the number, the number of stars on this repository, isn't very readable because it doesn't include any comma's or any sort of delimiter for the difference between what's in the thousands and what's in the one-hundreds. So let me show you a quick way to fix that. In addition to directives in Angular, Angular also has the concept of filters. A filter is something that you invoke and pipe data through, by using the | symbol, and then the name of the filter. So this expression that I have now, repo.stargazers_count, pipe into number. Number is a filter that can take data, the count of stargazers, and format it. In this case I want it formatted as a number. Number is one of many filters out there, and if we do a Search now, I can see that the larger numbers have formatted a little bit better, so 23,209 for angular.js, it's 23,000. If I wanted to include some digits after the decimal point, this is the syntax to say, please give me one digit after the decimal point. That's obviously not something I need for the number of stars, so I will remove that. But there's a number of filters included with Angular out-of-the-box. Filters that allow you to format numbers as currency, format date values, output JSON, even order some collection. So it might be nice, when we bring up this table of information, if we had the ability to order the list of repositories alphabetically, or by the number of stars, or by the primary language. We'll look at that next.

Filters

As we just saw in the last clip, filters in Angular allow you to massage and format data for a presentation. You can take an expression, like stargazers_count, and you can pipe that model value through a filter, which will modify the data for display. The basic format to use a filter is to use some sort of expression, and then the | symbol. So you pipe something into a filter, you have to name the filter, and then there's a colon and any parameters that the filter might need. Here are some examples using the built-in filters of Angular. We don't have time to cover each one, but you can convert numerical data into a number with a currency sign; convert dates into string that display just the date, or just the year, or anything you need as the date filter is very flexible; there's a filter filter that will filter out objects from a collection based on a Search term; and a json filter, which is useful for dumping objects into the display for debugging. The limit filter is a way to say, I only want to show 3 repositories or 10 repositories, instead of the entire array; while lowercase and uppercase transform strings, just as their names would imply; and number is one filter we've already used, it will format numbers with a localized delimiter, and optionally control the number of digits after the decimal point. What I want to use next is the orderBy filter, so we can sort our list of repositories using different fields. Let's set up the page so that we see the repositories up here in sorted order. I want the repository with the most number of stars to appear first, and in order to do that I would try an orderBy filter, here with my ng-repeat. So, I want to order this array of repositories by stargazers_count. And the reason I'm using a single quote here, is because orderBy needs you to tell it the property to orderBy, so I need to specify a property on a repository and I'm using single quotes here, because Angular will evaluate whatever parameter I pass here as an expression. By using single quotes, I'm telling Angular this is a string literal, stargazers_count, this is the name of the property to use. And it's single quotes because I already have double quotes here for the attribute. If I did not use those single quotes, Angular would go looking for a property on my $scope, a property by the name stargazers_count, and then it would use the value of that property to orderBy. That's not what I want just yet, but if that didn't make sense don't worry, we're going to come back and revisit that, but right now I just want to take a look at the Preview window and try to bring up Angular's repositories, and I can see that the default sort order is ascending sort. So we are looking at the repository with the least number of stars first. This is very easy to change. With Angular you can put a plus or a minus in front of this. A plus would imply ascending sort order, that's what we already have. So I would like to have a minus here, to get a descending sort order, and now I can see that the most popular repository for the Angular user is, not surprisingly, angular.js. So now let me show you what happens if I do not use single quotes here. I'm going to take this string, cut it out of here, and replace it with repoSortOrder. So now what Angular is going to do is it's going to look for a property by this name on my $scope object, and use that value to figure out how to sort this collection. In other words, if I come in, to my controller and I say, "$scope.repoSortOrder = ‘and that string that I cut out'", this is effectively the same thing I had before, but now instead of controlling the sort order by putting a hard-coded string into the view, I am now controlling the sort order using a property on my $scope. And if I come out to the Preview page and search for Angular, it's still working the same as before, but now what's interesting is, I have a property that I can manipulate on my $scope object to change the sort order, and perhaps the user doesn't like this default sort order, perhaps they want to sort by the repository name in alphabetical order or the primary language in alphabetical order. Well that is now very easy to make happen. Back in my Index view, just before the table, let me play some text here and let's build a dropdown list so that the user can select how they want to sort something. So this will be a select option, I don't really need a name or an id for my select, but what I do need to do is bind this using ng-model to repoSortOrder. So ng-model also works against a select, just as well as it does an input type="text". Essentially when the user selects something in this dropdown list, Angular will make sure to move the selected value into the model. Likewise, if my controllers sets the model value that it is examining, ng-bind will automatically make sure that that is the selected element inside of here. So now I just need some options. So one option will be to sort ascending order on Name. Another option will be to sort in descending order on stargazers_count, and that's the default. And the last option will be to sort in ascending order, on the Language. So the value that I'm putting in for these options is the value that's going to be placed into the model, +name or +language, and whenever that changes, Angular will realize there's a change there and then this orderBy depends on that particular value, so it will resort the table. Let's try it out. Back in the Preview window, let's look at Angular. Notice, Stars was the initial selection and that is the sort order, but I can change to Name, or I could change to Language. And now with just a little bit of code, not only are we displaying information about a user, we're also displaying information about the user's repositories and we're letting our user select the order in which those are displayed.

ng-show and hide

One of the issues I promised to come back to later in this application is the fact that, when this application initially displays, we have this generic gravatar image appearing and we also now have a table with no data in it. And this is because we don't have any user information to bind against yet. The controller's not going out and doing an $http request for Angular, until we hit the Search button, but now if I refresh this again to bring it back to its original state, what I would like to do is not display this image, or the table, or the sort order until we have some valid user information. And fortunately, there are directives in Angular that make showing and hiding pieces of my markup very easy. The directives are ng-show and ng-hide. For example, if I wanted to get rid of the gravatar image until we had some user information, I could place an ng-show directive on the div that surrounds that image and the username. And I could use an expression in here, which is just user. So the way ng-show works is it looks at that expression, and if that expression is truthy in JavaScript, it will allow this markup to show; otherwise, it's going to hide this markup. And what do I mean by "truthy"? Well if you've worked with JavaScript at all, you know that you can check to see if something is truthy, and it doesn't have to be a Boolean, it doesn't have to be a true or false value. You can check to see if a string is truthy, or if a number is truthy, and in this case user will be an object populated with lots of properties like the username and the user location, but until we reach that point, we don't have a user in $scope. User is undefined, and in JavaScript, undefined means false. If I also take this order markup, and place that in this top div, that would make that easy to show and hide also, just want to tab it over so it's inside that div. And the table, let me show you how ng-hide would work. I'll put, inside of here, not-user, because this is going to hide this particular markup if this expression comes out to be truthy. So by using bang user, or negate user, what I'm saying is hide this if we don't have a user. And now if we come back to the Preview window, what we'll see is all that other extraneous stuff disappears until I have my user information. And then I get the gravatar and then I get the table full of information. Now one thing I would try to do is not make logic too complicated, so really, on table, I would also use the ng-show directive, but ng-show and ng-hide, both useful directives when you want to make things appear and disappear from the screen based on some expression or some flag that is in the model.

ng-include

The last directive I have time to show you in detail is the ng-include directive. ng-include is useful for a number of scenarios, because ng-include can bring in HTML from another source, like another file, and then you can use that HTML in the current view. This is useful because you can break up a complex page into pieces; it's also useful if you have some markup that you can reuse in other views of the application. For example, perhaps the user details that we are displaying, the user's name, the gravatar, the list of repositories, perhaps we can use that in other areas of the application. In that case, I want to ng-include this markup. And then, what I would do, is take all the markup that is being used to display details about the user and I will cut it out of this index view, and now let me create a new file, userdetails.html. And I will paste all that markup into this file and do a little beautifying, just to make sure all the indentation is correct, and now I just need to ng-include this view. But before I do that, I'm going to take out the ng-show that we just added, because I'm going to add them on the element where I ng-include this markup. So, in index.html, I'm going to create a div, and this div will have two directives on it. The first directive is ng-include, and this is where I can specify an expression and that expression can be resolved against $scope, and the value that the expressions yields should be the location where Angular can go and grab the additional markup. Now because I know exactly where this markup is coming from, I'm going to use the single quote trick again to tell Angular, ‘I'm giving you a string literal, please use this value.' ‘Don't try to evaluate it against scope instead, just go grab userdetails.html and bring it in and include it right here.' And I'm also going to add just one ng-show now, one ng-show for user. So if we have a user object on the $scope, that expression evaluates to truthy and then we should be able to show all the details on the page. Let's go back to the Preview window and see if this works. I'll search for Angular, and I can see that my userdetails markup was included and that the ng-show was still working and allowing this to display once we have user information on the model. Notice how this included markup is just fitting in and working against the existing MainController. I didn't need to change any of the bindings or expressions in the included view; it just works if you want to include some additional markup inside of an area that is already the responsibility of a controller.

Directives!

Before we finish, I just want to let you know there's an entire world of directives available for Angular. There's over 50 directives that come with the core library. That's more than I could fit on the screen; that's more than we could cover in this module. We've used some directives, directives like ng-click, but there's a lot of directives that we didn't have time to cover; like mouse-related directives, for example, ng-mouseover and ng-dblclick; also key-oriented directives, like ng-keypress; and CSS-related directives, like ng-class. In addition to these built-in directives, Angular allows you to write custom directives and this is where the fun begins, because you can find many custom directives as open-source projects, custom directives to perform activities like drag-and-drop, or custom directives that can wrap bootstrap widgets, or media players, or wrappers for Google Maps. I encourage you to try out some of the other directives listed here, as well as some of the third-party directives, and see all of the capabilities and power that directives have to offer.

Summary

In this module we focused on directives and views, and we saw the powerful capability that directives offer. We can manipulate our view and move data in two directions between the model and the view using these directives. We've seen binding directives, they can move text anywhere we need into the HTML. We've also seen model directives, like ng-model, that can move data from a select or input into the model. We've seen event directives, like ng-submit and ng-click, that can direct events into our model, events like a button-click, and we've also seen display directives, like ng-include, ng-show, and ng-hide, that can fetch HTML fragments and also show and hide pieces of the display. And again we've only seen a handful of the directives available in Angular. There are many more directives available from the Angular Team itself, as well as other projects and parties. Once you start programming with directives, you'll never want to go back to programming against the browser, using a library like jQuery or handcrafting code to synchronize your data with the display.

Services

Introduction

Hi, this is Scott Allen, and this module is about Services in AngularJS. The word Service has many different meanings in software, and in web development we typically think of a service as a feature offered by a web server, like the GitHub API Web Service. But in an AngularJS application, a service is a different animal. A service in Angular is a component that performs a specific job, like providing a timer, or providing the ability to communicate over HTTP. We've seen that component, we've used it; it is the $http service. This module will show you some of the other built-in Angular services, as well as how and why you would want to build your own custom service.

The Venn of Services

So far in this course, we've seen how we can write a controller function that takes a $scope object, and it's the controller's responsibility to set up the model on that $scope object, by attaching properties and functions on $scope. We can even have a $scope property reference a complex child object, like we did in the last module when we had a $scope point to all the data for a GitHub user, as well as an array of all the user's code repositories. We also know there are views, which are the HTML markup for the application, and a view can consume the model using directives. So directives serve as an intermediary between the model and the view, making sure that neither one knows too much about the other, and that gives us more maintainable code thanks to two-way data binding and a separation of concerns; the concerns being model logic and presentation logic. Now where does services fit into the picture? Let me try to draw an actual picture. We have Controllers, we have Models, and we have Views. Directives sit in-between the Model and the View, keeping them separate, but allowing them to communicate indirectly and move data back and forth. If someone changes an input in the View, I can have the ng-model directive push that input value back into my Model, and changes in my Model are automatically pushed into the presentation of the page, the browser's Document Object Model, what we call the DOM, D-O-M. So we can say that a Model and a View work together thanks to a Directive. Now Services also allow us to separate concerns, because I can write a Service that provides logic not directly related to a module, it might be logic to communicate over HTTP, or it might be an algorithm to compute the hash of a string, or it might be code that provides validation checks, or code that talks to local storage in the browser, or manage cookies sent from a server. So one way to think about Services is, if the logic doesn't fit in a Model or a View or a Directive, then the Service is a grab-bag where everything else can fit. And one of the many benefits of putting logic into that service is that the logic will be easy to use anywhere else in the application, because Controllers can view Services, we've seen that example already where we've written the Controller that requires an $http service, and the Controller can then make that available to use from the Model methods attached to our $scope, and it turns out that Directives can also use Services. So you'd never use a Service directly from a View; a View is about presentation and directives only, but Services can offer functionality some Models and Directives in a reusable way. And they can contain logic that either doesn't belong in a Model or Directive, or it's just logic that you want to be able to use from several other Models or Directives that are in the application, or you just need to package up some functionality because your controller is growing too large, where you have hundreds and hundreds of lines of code inside of a single controller, that would be a point where I would look at that Controller and see if there's anything in there that should be refactored out of Controller, perhaps put into a service to use from there. Now so far we've been using the $http service, but let me show you a service that is not communication-related, actually a couple other built-in services from Angular, the timeout and interval services.

Gamification

In this module, we'll continue building on the plunk that we've been working on for the last couple modules, the GitHub Viewer, and to demonstrate one of the timer services from Angular, I'd like to play a bit of a game with the user. When the application loads, I will only give the user 5 seconds to perform a user search. Otherwise, the application will search for them using whatever is in that Search textbox. So we will count down from 5 to 0, and when we reach 0, automatic search. I probably want to let the user know what that countdown value is. So we can display 5, 4, 3, 2, 1 on the screen, and that means over inside of the controller, I will probably want to initialize a variable called countdown and I'll set it initially equal to 5. Now before we even get timers involved, I want to think about the logic of, how do I count down and perform an automatic search. So let me create a function, called decrementCountdown. That will be a function that ultimately I want it called once every second, and we'll figure out how to do that in just a bit, but right now I'm going to say that whenever this is called, we will subtract 1 from countdown and then if countdown is equal to 0, or I could also say less than 1, we will do an automatic search, so $scope.search, and because search requires a username, I will just pass in $scope.username, because that is the model value that is bound to that input search. Now the question is, how do I get this function invoked once a second? Well JavaScript provides some native global functions that you can use to work with timers. There is setTimeout and there is setInterval. setTimeout worked by passing in a piece of code and then the number of milliseconds into the future when you want that code invoked. So if I want to have a method called doWork invoked in 2 seconds, I would call setTimeout(doWork, and pass in 2000 milliseconds. setInterval is very similar, except setInterval will continue to invoke that method every time its countdown expires; it counts down from 2000 milliseconds to 0, and every time it hits 0, it invokes that method and then resets the timer to 2000 milliseconds. It will continue to do that until you cancel that interval. Now I could use these functions directly in my Angular application, but I don't want to. It turns out that Angular provides a service, or actually two services, that wrap these two functions. So there is a $timeout service that wraps setTimeout, and there's a $interval service that wraps setInterval. I want the $interval, because I want to call decrementCountdown once a second. And there's a couple really good reasons to use these services, instead of the built-in functions that JavaScript provides. Both reasons are a little beyond the scope of what this course is, but let me briefly describe them. One reason is unit testing; if you want to unit test the code inside of this controller, it's much easier to unit test if you're using Angular Services, instead of built-in, intrinsic, JavaScript objects, like setTimeout. Angular provides you a way to substitute a testable counterpart to a service like $interval, so during a unit test it's not really using a timer. And if you build bigger Angular applications, I strongly suggest you take a look at unit testing. I know it has saved me a lot of time on the Angular projects I've been in. The second reason to use these services has to do with some internal details of how Angular performs two-way data binding. If I change the model inside of a function called from setTimeout or setInterval, I might see that my page does not update correctly. I don't have data moving from my model onto the screen, but that problem goes away if I use the built-in Angular Services, and for that reason, instead of using setInterval, I want to ask Angular to provide my controller with a $interval service. And the way I would use that service is, let's say down here at the bottom of the controller, once everything is set up and initialized, I will explicitly call a function called startCountdown, and startCountdown will just be another implementation detail here. So startCountdown is a function that, when it gets invoked, it's going to go to $interval and it's going to tell $interval to call decrementCountdown, every 1000 milliseconds, or 1 second, and then there's actually a third parameter that $interval provides. Usually setInterval will just run forever until the user leaves the page or you cancel it. The $interval service, you can actually specify a parameter here for the number of intervals that you want. So I want 5 intervals and then stop using that timer after that. Or I could say $scope.countdown, which is also equal to a 5, but now I don't have it hardcoded. I just want to use this interval for 5 ticks. And after the fifth tick, stop calling that decrementCountdown function. Now one thing that you might notice is a little bit odd about this $interval service, is that it's a function, I can invoke it, and indeed in Angular you can have different types of services. So, $interval is a function, I can immediately invoke it; $http, that's more of an object API, so I typically invoke methods that are on that service, like $http.get, and you'll see examples of both of these throughout Angular, services that you have to dot in to some method to get it to perform work, and then services where you just invoke the service and pass in some parameters, and something magical happens. So now I think I have all the codes set up, but let's come over to the Preview window and I will see that something has gone terribly wrong. My application's not running. But that's okay, I want to show you about how to troubleshoot a specific scenario with Angular. Let's open up the Developer Tools and I'll see "undefined is not a function". That usually means I have something that is undefined, I tried to invoke it like a function. This is the TypeError that I will get in Chrome. I can see this happen in startCountdown, and that is in script.js, line 31. So let's go to script.js, line 31, and I will see --- that this must be the $interval service. This is the one method that I'm invoking here. Why is $interval, why am I not getting that service from Angular? So a couple things to check when this happens. First thing to check is, are you naming that service correctly as a function argument? And if I go and check the Angular API Documentation, I will see - yes, there is a service, $interval. I have it spelled correctly, it's using the proper case, but for some reason I'm getting an undefined value for that. And really undefined means Angular didn't know what to give you. So if you have that service spelled correctly as a function argument, the next place to check would be wherever you are registering that controller, which is done with module.controller, in this case we called it app.controller, that's the registration for this controller. I'm telling Angular, ‘Here is something called MainController, and here is an array that describes that controller.' You might remember we talked about this earlier in the course. I'm using this syntax to describe the objects and services that I need so that I can minify this file later on. Remember, minification changes the names of function arguments, so something like $interval might become just the letter ‘n'. And because Angular needs to know the names of these things to give you the proper services, minification will break your code, unless you use this syntax, but when you use this syntax, you need to make sure that you're describing all the right parameters. In this case I'm telling Angular, ‘I need $scope, I need $http, I need nothing else.' So it's not going to pass me that $interval service. To fix this problem, I would either need to add $interval here into the array, or let's just get rid of the array syntax and use the simpler syntax that says, ‘Dear Angular, I want to register something called MainController. Here's the function to use.' When you use that syntax, Angular will be looking at literally the names of these function arguments. So now it should see $interval, and I hope when I come back to the Preview window, it's working again. Let's refresh and start from the beginning. I can see there is a countdown, 5, 4, 3, 2, 1, Search. So now our page is working. But there is a slight problem, it's not exactly obvious. If I refresh this page again, think about what happens if I immediately do a Search, and now you'll notice the countdown still goes on. When it reaches 0, it's going to do another search. I'm going to prove to you that that is the behavior that is happening behind-the-scenes, and then we'll fix that up in a later clip, but before we do that, let's just take a step back, and talk a little more about services now that we've gotten to meet another one.

Service Roles

Let's talk a bit more about the relationship between services and the rest of your application. When you're writing a component like a Controller, you want to focus on one thing, which is setting up the model. The model should contain and retrieve the data that it needs, as well as have the methods required to respond to events, events from the user or other events, like a timer event, that might require the model to change. And when you're writing this Controller code, you want some insulation from the outside world, not just for testability, but also for the sanity of keeping complexity out of your Controller. And those are two reasons why services are useful; someone, like Angular, can provide a service that wraps up all the intricate details of $http communication and you can just ask Angular to pass the service to you by including $http as one of the controller arguments. So you can use services from Controllers, but you can also use services inside of directives if you ever write a custom directive, and also other services. We'll write our own service in a bit. Another service that we've seen, the $interval service, is just one of many built-in services that Angular provides. Each of these services provides a specific feature for an application, a feature that because it is wrapped in a service, it can be easily reused throughout the application. Let's take a look at another one of the built-in services, the $log service. You'll find this useful for debugging and diagnostics if you ever run into trouble with Angular.

Using $log

Let me demonstrate the $log service of Angular by first asking Angular to give me a $log service. And you can have as many services inside of this controller function as you want. Angular will identify each one and pass in each one that you need. And this $log service has some methods on it, methods like warn, info, error. You can invoke those methods, pass in a string, and that string will appear in the Developer Tools Console tab. So if I want to see when we're searching, what we're searching for, I could say let's do a "$log.info("Searching for ", and add in the username that we're searching for. So each time that particular method executes, I should be able to see who we're searching for. And one of the great features of Services in Angular, something that we won't have time to cover in this course, is that you can reprogram them. In other words, if I detect an air-condition, I might want to do a $log.error and put a description of that error in the Console, but no one's going to see that error message unless they are actively opening the Developer Tools and looking at the Console. And it is possible to reprogram this built-in $log service to not only add that message to the Console, but also to send that message back to the web server via the $http service. That way on the server, I can log these messages and find out that clients are having some errors, someone can investigate to see if it's an error in the program logic. But we're just going to use the $log service as is, and if I come over to the Preview window and open up the Developer Tools, I'm first going to clear out the Console and then refresh this window, quickly do a Search, and you can see I get one message searching for Angular. And then when the countdown expires, I get the second message searching for Angular. So we're doing two searches. I should change this program so that if the user beats the timer and does a search, then we no longer do the automatic search. And fortunately, this is relatively easy. When I call $interval, it's going to return an object to me, and the first thing I need to do is save that object and then use it later to cancel the $interval. So I will declare a private variable here, it doesn't have to be on $scope, let's call it countdownInterval. I'll start it off as null. And then when we call $interval, I will store the return value into that variable. Now, when we do a search, I need to check to see if there is a countdownInterval, because if there is I want to cancel that $interval. So, if countdownInterval, if that is truthy, because it's not null, then I can walk up to the $interval service and tell it to cancel, and I need to pass in that object, countdownInterval. Let's see how this behaves. Come back to the Preview window, and have the Developer Tools on the screen. I wasn't quite quick enough so let's clear the Console, refresh the window, and do a Search. I got one search, notice the countdown timer stopped. So I'm pretty sure that I have canceled that interval correctly. I might also want to take that 4 off of the screen. Let's try to do that real quick. You probably know how to do this, but if I just say $scope.countdown = null, or empty it out, blank it out, now what I should be able to do is, open all of these Windows again, let's do a refresh, do a Search, now I did one Search, I stopped the interval, and I took the countdown off the screen. So that's how useful the $log service can be. It's sort of interesting because it allows us to present some information into the Developer Tools, but what if I wanted to use a service to interact with something on the page, or on the screen, or in the browser window? Well generally, we try to keep things like services and controllers from interacting with UI pieces directly, but there are some scenarios where it's extremely useful to be able to invoke some behavior in the User Interface from logic that is inside of the model or inside of a service. Let's talk about that next.

UI Services

Most of the time with Angular, when we want something to happen in the View, all we do is make a change in the Model. And directives will make sure that the View and the Model stay synchronized. This keeps our Model and Controller free of UI concerns, but there are some scenarios where it makes more sense to use imperative JavaScript code to interact with the View in a more direct fashion than relying on declarative HTML with directives inside. Some of these scenarios include, forcing the browser to navigate to a new URL or popping up a model dialog box to force a user to input some data before we take some other action. And the solution to these types of scenarios is still not to touch UI-related objects directly from the model. Instead, there are services that can wrap these types of functionality. So, for example, there is a location service in Angular. And if we need to read or write the location in the address bar of the browser, the model can talk to the $location service and the service can talk directly to the UI component. Again, this can be because the service presents a simplified API for that UI component, making it easier to use. It's also easier to unit test if a model doesn't touch that UI object directly. So let's take a look at a couple of these UI-related services; the $location service, which can set the location in the address bar, and $anchorScroll, which can force a window to scroll to a specific location in the HTML identified by an element with an ID. So here is the scenario I want to explore. Imagine the user has very little real-estate on their screen. and when they come to this page and they do a Search, the Search results appear outside of the visible part of the window, so the user might not even know that the Search results have appeared on the screen. What I'd like to do is after the user has executed the search, after we have retrieved all of the data, I would like the window to scroll to make sure that the user details down here are visible. And to do this I need to do a couple things. First of all, I'm going to need to ID an HTML element that I want visible. In this case it will be very easy to find the element where the userdetails start. I'll give that element an ID. And then I need to use a service known as $anchorScroll, and tell it to scroll, make the window scroll so that element is visible. And that behavior is a little more indirect than what you might think. I do not pass the name or the ID of the HTML element to the $anchorScroll service. Instead what I have to do is actually change a fragment identifier of the URL. A fragment identifier is what will appear after the hash sign in the address bar of the browser. So if I give this HTML element an ID of userdetails, I'm going to have to set the fragment identifier in the URL to userDetails and then tell $anchorScroll to go. So a number of changes to put together, and a couple new services, but let's see how this works. I think I will start with userDetails. Let's come to this top div. I would like to give this the id of userDetails, try to get this div into the visible portion of the window. And now inside of my controller, I'm going to need two services. I'm going to need $anchorScroll to do the scrolling, and I'm going to need $location so that I can modify the fragment identifier inside of the URL. And now let me just reformat some of this code so we can actually fit all of our dependencies on the screen. Very good. Now, inside of onRepos, because at this point we will have retrieved both the user information inside of onUserComplete, and retrieved all the repository information, what I want to do is say, $location service, please set the hash or the fragment identifier to userDetails. And once that has been set, $anchorScroll is one of those services that is a function I can just invoke. So, two different services, only two lines of code required and one id on a DOM element. Now we should be able to come back into my Preview window, let me do a hard refresh, we're starting up here, I do a Search, we get all the results, and the window scrolls down. It bumps down to make sure that that part of the userDetails is visible. And that's an example of a couple UI-related services, and UI-related services, like $location, they certainly make dealing with the address bar a lot easier than if you had to use the built-in APIs provided by the browser. For one thing, the $location service can make sure that its functionality works across all the different browsers with all their little nuances and bugs. And now that we've used a few of the built-in Angular services, it's time to talk about why and how we could write our own service.

Custom Services

I want to show you how to create your own service for Angular, and the question to ask is, ‘Why would I ever want to write a service?' Well services are useful in a number of scenarios, many we've already seen, but let me talk about the big three. The first reason is to package reusable logic into a container that you can use in different places throughout the application. This might be an algorithm or some piece of logic that you need in several different controllers. Instead of duplicating code in multiple places, it's always a good idea to keep the code in one place, a service, and call into that shared code from other locations. Another reason is to store shared data. It turns out that if you need to share data between controllers on different views, a service makes a great place to store data, because Angular only instantiates a single instance of each service for a given application. That means if you use a service from three different controllers, all three controllers, even if they aren't on the screen at the same time, they will get the same service instance, and therefore the same shared data. A third reason is to manage complexity. Maybe a controller is getting too difficult to manage. You have so much code, it scrolls off the screen. That's a time to take a step back and see if there is anything you can do to simplify the code and separate the responsibilities. What I want to do is build a service that will demonstrate two of these reasons. We'll build a github Service. It will encapsulate the API calls to GitHub. Instead of using the $http service directly from our controller, we'll use $http inside of this new service instead, and we'll see it actually simplifies the code of our container, so it helps to manage the complexity, and it will be a nice reusable service that we can use for multiple controllers later on. Let's try it.

A GitHub Service

Inside of my plunk, I want to write a custom github service that will make $http calls for me. And I will place the code for that service inside of a new file, because script.js is getting a little long in the tooth, the code scrolls off the bottom of the screen. Things will be much easier if I just create this in a separate file, called github.js. I will add that to the project, and I need to make sure that inside of index.html, I include this script, so the JavaScript code inside will actually execute. Give me a reference to github.js, and I want to make sure that this script is included after script.js, because it is script.js that defines the module for the application. I know that defines the module for the application because it has the second parameter, which is an empty array. You might remember from a couple modules ago, that describes the dependencies for this module. We don't have any explicit dependencies, that's why it's an empty array. But I need a reference to that same module so that I can register my custom service in that module and make it available. So over in github.js, I will create an IIFE, just to give me some scope so that I won't create any globals, and then I'll create a variable called module and I'll say, ‘Dear Angular, please give me a reference to githubViewer.' There's no second parameter here, because I'm not trying to create a module; all I'm trying to do is get a reference to an existing module that was defined before this script file came along. So give me a reference to that module, that will allow me to register my service, but how do I create my service? I could actually put this above the module. While you might remember from the introduction of this course that we talked about a design pattern where I could have a function that gets invoked that returns an object with an API; that was the revealing module design pattern. So someone invokes this github function, it's going to be Angular that invokes it. I'm going to return an object that is the github service. What I return will represent the public API, but I will build first are the implementation details. I know the service has to do two things; it has to get a user and it has to get the repositories for a user. And in order to do either of those things, it's going to need the $http service. So yes, a service can have a dependency on another service, so my github service requires the $http service. That will allow me to do things like, get a user. So I'm thinking if you call getUser, you will pass in a username, and what I will do is make the $http call to get the data. Now this function is still going to be asynchronous, so what I need to return from this method is a promise, because in the controller when it gets a user, that's inherently an asynchronous operation. I cannot return you any data from getUser until I have talked to the server and the server has responded with some data. So ultimately the code inside of our controller is not going to change a lot. It's still going to call something to get a user, and then it needs a .then method for a promise that will deliver the value when we have that information. Let me copy this line of code that calls $http.get on the user URL, and I'm going to put that into getUser after a return statement. So if this is all I did and I registered the service with the name of github, someone could call this function and still do a .then and pass in a function that gets the $http response, because what I'm returning is the promise that is given to me by $http.get, but I can do one better than this, because inside of the controller, once it calls that URL and it says ".then(onUserComplete", one of the things that onUserComplete has to do is look at the raw HTTP response and dig the data out of that response. I can actually perform that in my service so that the controller doesn't have to. So back in my service, instead of returning this directly, I will say $http.get, .then. Here is a function that takes a response, and what I want you to return is response.data. Now there's something happening here, which isn't immediately obvious, and I'll admit it can be completely mind-bending until you get used to this particular programming paradigm, but what will happen when someone calls getUser is that I will make a call to $http.get and that will return a promise. I will call .then on that promise so that when that $http call is complete, it will call my function, passing in a response, and I will dig out the data to that response, and then I will return response.data. The not immediately obvious part is that when you return something from a function that is invoked by .then, and this something could be a number, could be an object, could be a string, whatever you return will be wrapped by .then into another promise that is given back to the caller. So whoever calls getUser, they're going to get back a promise that will deliver the value that this return statement provides, response.data. They're not getting back a promise that will be complete when the $http call is complete; they're getting back a promise that represents the completion of $http and this particular function that digs out the data. If it's not immediately obvious how that is working, that's okay, it didn't make sense to me for a little bit, I had to work at it awhile, but hopefully you'll see that the results are very simple and it's going to be very simple to call this method. We won't actually have to change much inside of the controller, but I am going to follow this same basic pattern for getRepos without any, which will get the repositories for a user, so you pass me a user object and I will figure out how to get the repositories. Again, let me borrow some code from onUserComplete, copy that call, and paste it here, because I still need to do an $http.get, this time not against $scope.user, but just against the user parameter that is passed to me. I'm still going to return a promise, but not the $http.get promise; I will return the promise that I will return this, which is response.data again. So, processing that response to the controller doesn't have to, and that is everything I need to do for the private implementation details of the service. Now we just need to pick the public API, which can be very simple. I want something called getUser, which will call that getUser function, and something called getRepos, which will call the getRepos function, and now my service definition is complete. All I need to do is register this service with Angular, so that other components can use it. Now, I will warn you there's about 24 different ways to register and configure a service with Angular. If you go into the documentation it's very confusing, but I will give you the one simple straightforward way to register a service with Angular, and that is to use a method called factory. With the factory method what you do is you pass in the name of your service, in this case it's going to be github, and then you pass in something that points to a function that returns an object with the API that you want. So now when any controller or anything else inside of this application says, ‘Give me something called github', they will get back this object, something that they can call .getUser and .getRepos. I've implemented that service here, I've registered that service with Angular here. The only thing I need to do to use it is, here inside of MainController, I no longer need the $http service. I need the github service, I just ask for it by name. And now we have to fix up the code in here to use that. Let's start at the top. When the user clicks Search, I don't want to call $http.get. I want to call github.getUser, here is the username to fetch, and then either call onUserComplete or onError. onUserComplete has to change just a little bit, it's up here at the top. Instead of getting a raw $http response, we're doing that processing here, what it will get instead is the user data. So this is simplified a little bit. Just give me the data and $scope.user will be that data. Now instead of calling $http.get here, I can also say github.getRepos, pass in $scope.user, that will call this function ultimately, and I can still use my promise to say onRepos or onError. And onRepos will change just like onUserComplete changed. I get the raw data, just set $scope.repos equal to that data. So the code inside of the controller hasn't changed tremendously. It's not like we took out 50% of the code inside of the controller, but it has been simplified. And if you think about it, now we have the service, this github service that manages the URLs, that manages the response processing. I can reuse it from other components inside of the application, and if I never need to add additional features, features like making authenticated calls or caching of the data that comes back, I can add that to the github service and it's just available everywhere. So I'm in a much better situation. And this is typically what I do in real applications; I never make $http calls directly from inside of a controller or inside of a model. I usually encapsulate all that server communication inside of a service that makes it easier to use. It's much easier to see that I'm getting repositories, or that I'm getting a user, than it is trying to read through a URL and figuring out what is happening, but having said all that, we should probably check the Preview window to make sure this works, and I'm hopeful because it is displaying Angular information. If I refresh, and let's go back to Rob Conery. If I can beat the timer, which I did, it looks like I now have a github service and that github service is working for my controller.

Summary

In this module we looked at services in Angular, and we used a few of the built-in services that Angular provides, services like $location, $log, and $interval. We also saw how to build our own custom service, and most importantly we saw that services are another barrier, or another shield that we can use to keep our models and controllers free of code that will make them complicated or harder to test. Services are like software components that we can pass around in the application and they can package up custom logic and data for reuse and allow us to break down large pieces of functionality into smaller pieces of software. In the next module, we'll look at yet another service that we can use with Angular, the routing service.

Routing

Introduction

Hi, this is Scott Allen, and this final module with Angular will demonstrate Routing. Routing allows you to manage multiple views in an application, and it's an essential feature for building larger apps, because you can allow a user to navigate between different screens, you can pass parameters between the controllers that manage these screens, and even tap into the browser Back and Forward buttons so that the browser history is synchronized with the user's location in your application. Let's start by looking at some of the details of how routing works in AngularJS.

What is Routing?

At a high level, here's what Routing is all about. You are building an application and you cannot put all the functionality that you need into a single controller in a single view. You have different features and you need different areas inside the application. That's going to require multiple views, multiple controllers. Each view and controller is responsible for a specific feature or area of functionality, and now that you have functionalities spread around, how do you know where the user is located in your application, how do you know what is supposed to be on the page, what are they seeing? Are they trying to view the details about a user, or are they trying to view the details about a repository for some user? And that's the first question; how do I know the location of the user? While the browser does have the concept of a URL, a Uniform Resource Location, that's what appears in the address bar. We usually think of the URL as a way to reach some resource on the server, but when building an application with Angular, you can also start thinking of a URL as being able to locate the resource on the client too. Every JavaScript framework I know of that provides Routing features uses the URL of the browser. So let's say the URL includes /users/odetocode; that means your customer wants to see information about the GitHub user, odetocode. It is the responsibility of the routing engine to see that URL, capture it, and figure out what should happen. It will figure out what should happen, because we will configure the routing engine with some rules. Rules like, when our customer comes to the URL that looks like /users/(some username), you need to render the users details view, or the user details controller. So the rules we configure allow the routing engine to pass the request off to the right area of the application. We'll have a controller find a user, and we'll use data binding to put that user information into the display. Then, a customer might click on a link, one that takes them to /users/odetocode/repos, so they want to drill into the details of the repositories available for this user. Again, the routing engine will see that request, intercept it, capture it, and transfer control over to the proper components to do the work of responding to that request. And all of this happens on the client, in the browser, in JavaScript. And now what we need to do next is talk about some specifics with Angular. How do we put this routing engine in place, and how do we configure the rules that the routing engine will use? That's what we'll look at next.

Routing With Angular

Here's how Routing works with Angular. First, we're going to need another script from the Angular code base; it's called angular-route.js. This will give us access to a new module, a module that our application module will need to take a dependency on; this new module is called ng-route. Using a component in ng-route, we will configure our routing rules into the routing engine. Remember, this is where you describe the URLs for your application. You have to tell the routing engine how it should respond to a particular URL that appears in the browser. With ng-route, this is done using a component known as $routeProvider. It has an API where you describe what the URL looks like and then what to do for that URL. For each URL you can specify a templateUrl, that is the HTML that Angular has to go and find and load up for that route, and then optionally a controller that should be used to manage that template. And because the routing engine has to take that template and load it into the display, we're going to need to reorganize our application and our default.html file. Our default.html file will become what some people call a layout view, or a shell view. A layout view is a view that contains the markup you will use on every page of your application. It might include some common features, like a navigation menu at the top that's going to appear everywhere in your application, and perhaps a foot at the bottom that contains links to contact you and a copyright, but there will be space somewhere in that layout view, where the routing engine can load a template that corresponds to the current URL. So let's say we have two templates available; one to display userDetails and one to display repository details. We will tell the routing engine where to place these templates using a new directive, an ng-view directive. We will use that directive on an HTML element and it is that HTML element where Angular will insert the template when we're at the right URL. And now, as the user clicks and navigates and enters information and saves information, the routing engine will swap out one template with another template inside the shell view, and our application is now scalable; it can support any number of templates and controllers. The routing engine is going to swap them in and out. When it does that, it will also coordinate with the browser history, so that if the user hits the Back button or the Forward button, they will still be navigating just inside of your application. So we have a little bit of work cut out for ourselves, but let's try this out now.

The Setup

For this module, I want to build on the Plunk that we've been working on for several modules now. Only this time we're going to tear it apart and put it back together and use it with routing. We'll have all the same features we currently have, plus we're going to add a feature, and what we'll find out is that routing actually makes some things easier. For one, we can start dividing responsibilities between searching for user information versus displaying user information, but before we get to any of that, we need to at least get set up for routing. So the first thing I will do is make sure I go out and add, that angular--route script that I can find if I do a Search for angular-route. Now you notice I get a couple Search results here, angular-route and angular-router. It's angular-route that I want, it has the most up-to-date version of angular-route. I'll just click the button, and that will add an additional script file for me in my page. This one going to code.angular.js, and it's picking up angular-route.js. And now that we have that script included, the next step would be to set ourselves up so that we can configure the routing engine. One place we could do that, is inside of script.js where we create a githubViewer module, but script.js is already a little bit full. It's really where we have MainController defined. So I would like to remove the creation of this githubViewer module from script.js and move it to the new file where we will create that module and also add the configuration. So, create a new file, this one I'll call app.js because this is really what's going to define the application, and it's inside of here where I can have an IIFE, where I can have a line that will define the module, and what we're going to find is that we can run and register configuration functions against our application, and inside of this configuration function where we can define our routes. And now that's cleanly separated out from script.js, which is just going to get a reference to githubViewer. And before I forget, we will need to add app.js to the list of scripts that need to be included here. This one has to come before the other scripts because it is the one that is defining the module, and actually script.js, I'm going to go ahead and rename that to MainController, because that is really what is inside of script.js. If I double-click the filename, I can rename this MainController.js, and now we're a little further along. So app.config, that's a new API we haven't seen yet, but I'm essentially telling Angular, here is a configuration function to run when you're bringing this module to life. And so Angular will do this early on in the lifecycle of the application. And it's inside of here where I can configure the routeProvider, but in order to do that, I need to tell Angular that I have a dependency on ng-route. So it's not enough just to put that angular-route.js script into the page; I also explicitly have to tell Angular, ng-route is another module that my module needs. Only then will routeProvider be available to me. And here's what I'm thinking we will do with routeProvider. What I'm picturing is that eventually we will have three separate views, three separate sections of the application. There will be a main section; this is going to contain the search form that we currently have, where a user can type in a name and click a Search button and go off and search for a user, but that's just going to be one view, and searching is the only thing that viewer is going to do. When a user of this application completes a search, we're going to send them over to a user.html view and controller, and that's where we will present the results. I also plan on adding a new feature to this application, which is the ability to drill into a repository and see some details. Someone can do that just by clicking a link inside of that user view, it will take them over to the repo view. And all of this is going to require the proper route configuration, as well as some changes to index.html, because we have to turn that into a layout view. And most of the HTML that's in there now is going to need to be broken out into some of these other views, but first the routing configuration. With the routeProvider, I will just do one of these right now. I can describe the route that I want it to look for. So I could say that if the user comes to the entry of this application, the root of this application, just slash, then go to this controller with this view, but I'm going to make the main view the entry point for the application, something that will appear on the screen when the user is at "/main". And I need to tell Angular when it does see this URL, here is the template to load main.html, and here is the controller to use, which is the MainController. So Angular will go out and fetch that view, put it into the DOM, create a MainController, put it in charge of that template, and then we'll be off and running. The other thing that I can do with the routing engine is I can tell it, ‘If you see a URL that you don't understand, so it's not one of the URLs that have been listed previously, it's not "/main" at this point, we'll add some other routes in just a bit, but otherwise if you don't know what else to do, I want you to redirect to "/main"'. And now what the routing engine can do, is if someone for some reason comes in to /unknown URL, what the routing engine will do is send them to /main, which will bring up our Search form. Let's just see if we can get this part working. index.html will need to become a layout view, a shell view. Let's say that it's going to have a body, and a header that appears on every page. We'll say githubViewer. I will remove that responsibility from the MainController, instead we're just going to have it hardcoded here, we could also have a navigational menu up here at the top, but we'll display githubViewer and then everything else will be controlled by the routing engine. I will put in an ng-view directive. So that is where the routing engine will load these different templates. And now this existing markup that I have inside of here, I'm going to need to change it around a bit, but I'm going to cut it out of this page; this is all we need now inside of index.html. I'm going to take that HTML and I'm going to put it inside of main.html and set it up so that it works correctly. But this is a new file, main.html, paste in what we have, and now I don't need this to be a body tag, so I will change that to being just a div. I no longer need to specify which controller to use, because that's going to be specified in the routing rules. This is optional, you don't have to specify the controller here, and you can still specify the controller in the template, but I'm going to remove it from here and allow the routing rules to figure out which controller is going to be in charge. We don't need the message anymore. And let me beautify things a little bit to get the indentation, that's better. Actually we don't need the error here, because this view will no longer have the Search results. I don't need userDetails anymore. It is just going to be that Search form and the countdown timer that MainController will be responsible for. So to see if we can get this page on the screen, the other piece I'm going to need to rip apart is MainController. Right now it does the searching and display of user data. I'm going to make a copy of everything in this file, create a new file called UserController.js, and paste it in here. We will come back to this file later and fix it up. We need to remove some features from this file. But right now, I want to remove some things from MainController that I no longer need. For instance, this controller no longer needs the github service. All it's going to do is present the Search form and send things off to another controller and template to do the actual search. And in fact, I'm going to get rid of $log and $anchorScroll also. The only thing this controller is going to work with is $scope, $interval, and $location. I'll show you why we need location in just a bit. I don't have to worry when the user search is finished, I don't need to worry about when repository searches are finished, or when there's an error. I do need my function to decrement a countdown, to start a countdown, to manage the countdown. And now, inside of search, we no longer call into GitHub. I still want to manage the countdownInterval. This is the place where I will need to place some codes that we go off to the right route where we will actually search and display this user that we're looking for. And now just to fix up a couple few last things, we'll still have a default username, I don't need a message or a repoSortOrder; I just need countdown-related logic. So now, MainController much smaller. It's focused on one thing, which is to manage that search form and to manage a countdown to perform an automatic search if the user doesn't search first. And now let's take a look at this in the Preview window. In fact, I want to look at it in an external window to show you a couple features here. The countdown timer still works, I'm still presenting the search form. If I open up the Developer Tools, I don't see any errors. These are all good signs that things are working. Of course now we're not actually doing the search; that's a feature that we'll tie in next. But I do want to call your attention to the URL, and that one has a hash sign in it and a /main. And that is what the routing engine is using to determine where to go. When I tell the routing engine to go to /main and to load up the MainController, that's exactly what it's doing, because we are at /main. We're using pliant fragment section of the URL, the thing that comes after the # sign, that's what Angular uses by default. And unfortunately, this address bar, you cannot modify it when it's being run in Plunker, but if I were to try to come to something like #/user, which we don't have it defined as a route yet, the routing engine would redirect me back here to #/main. So this part up here is to be working. Next, let's get the userDetails display back.

The Fixup

Let's get the display of userDetails back into the application. What I want to happen is that when the user clicks on Search, or there's an automatic search, I want the URL to change to /user/ and then the GitHub Login ID, like Angular. I want that in the URL for two reasons. One reason is that it makes it very easy to pass a parameter from this view and controller to another view and controller by putting data into the URL. And the second reason that this makes sense is because by having that Login ID in the URL, someone can bookmark that URL and come back to it anytime and see details about a specific GitHub user. They could also copy that URL and email it to a friend or a coworker who can follow the link and they'll see the same data as the first person. And in order for all of this to work, we'll need to go through four steps. First of all, we'll need to register a new route so that the routing provider understands why we go to /user/username, what it needs to do. Then we'll need to create a template for that URL, we'll need to create a controller for that URL, and finally we'll need the MainController to send us to that particular URL when a search occurs. Let's start all of this by working with the $routeProvider to define that new URL. So, as you've probably already deduced, .when is the API to use to register a route for your application. And you can have as many calls to .when as you want, and you can chain them together like this. So I can just say .when, .when, .when, .when, and then a dot otherwise at the end if you want to handle unknown URLs. This time I want a URL that looks like "/user/:username". So whenever the routing provider sees a segment of the URL with a colon in front, it's going to treat that piece of the URL as a parameter, a piece of data that needs to be extracted from the URL and perhaps given to other components, so that they know what to search for, what to look for. Everything else it treats as a literal string, so for this particular route, it has to start with /user, --- and then a slash, and whatever comes afterwards will be treated as a username parameter. So it could be /angular or /robconery, whatever the value is, we'll be able to ask the routing engine what is the value for username and it will be able to tell us what's in the URL. We'll see how to do that in just a bit. For right now, I want to tell the router what to do when we have reached this particular URL. Well the template, I want it to use something called user.html, we'll have to create that, and the controller will be UserController. We have already created UserController, but remember that was a copy of the original MainController, so it has a lot of functionality in there that we needed to take out. All it needs to do now is display userDetails, so we need to fix up that file. Now let's create the template, user.html. It turns out we already have something that can display userDetails, we had it ng-included into the main view as this file, userdetails.html. I can use this. All I need to do is rename it. Let me double-click the file, change its name to user.html, and maybe just a few little things to clean up here. We no longer need to ID a particular element, we're not going to scroll there anymore, and I might need a place to display errors if something goes wrong when we search for a user. So those two little simple changes, everything else in here is perfectly set up to display the userDetails that we need. So now I just need to fix up UserController.js, which we have not included as a script in the application as yet, because it hasn't been ready, but now I will go ahead and say, please bring in UserController.js. That can appear anywhere in this list as long as it is after the app.js script. And UserController itself, we will have to change the name here to just UserController, instead of MainController, and down here where I register this controller, I want to register a controller by the name UserController, and please use this function when you need a UserController. Now we can clean up inside of here. This UserController no longer needs an $interval service, or a $log service, or $anchorScroll, or $location. I'm going to get rid of all of those. It's going to be a much simpler controller. We do need to know when the user search is complete, when the repository search is complete. when there's an error, but we don't have to manage countdowns, or start the countdown timer, or perform a search; we don't need any of that. We don't need a message. All we really need to do is find out, what is the username we're searching for and then we need to search for it. So how do we find out the username? Well there is a service available called $routeParams, when you're using routing, and what $routeParams will give you is any parameter that is defined in the URL. So, if our route has something called username, which is a parameter in the URL, if that's available, $routeParams will make that available as a property that I can read. So I can say, the username we're going to look for is, $routeParams.username, that gives me the username. And now, I can say github service, let's get the user, $scope.username. And when that is complete, use the existing onUserComplete function, or the error function that we already have defined. And there's actually two more pieces of code that I can delete here. The feature that we had to scroll to the HTML element with an id of userDetails, we don't need that anymore because this page will only display userDetails. Now the UserController is nice and simple. We removed a lot of code because the UserController is only focused on one responsibility, which is to display those userDetails. Now all the application needs is a way to get to this UserController and user view. We left that until later. That's the line of code that I left commented out here. I need to move to a particular route from a code inside of a controller. How do I do that? I do that with the $location service. Not only can the $location service tell you what URL you are on, if you want to read the URL for some reason, but it can also tell the $location service to move this somewhere else. I can do that with a method named path. So I can say, $location.path, please take us to /user/ and then the username that our user searched for. Let's try this out, by looking at it in an external preview window. Notice we start at #/main. I do a search, and we go to #/user/angular, and our repository information displays. And now it might be nice, when I'm on this page, to be able to get back to the Search page. Currently we have no navigation here to get back and do another search, that's easy enough to add over in user.html. The other way to move between routes is to use a simple anchor tag. So I could say, please give me an anchor tag that points to #/main, and the text will be back to search. And by the time I flip over to the Preview window, that might've already refreshed so that if I scroll down, I have ‘Back to search', and here I am on the Search window. I can do a search for Angular again. The other thing that will be working will be the Back and Forward buttons in the browser, because every time you make a route change, the routing engine will make an entry into the browser history list. And although this Preview window does not display the UI for a Back and Forward button, it gets rid of the browser toolbar, there's always shortcut keys, like on Windows I can hit Alt + Back Arrow, that takes me back to the Search form; Alt + Forward Arrow, I'm back to displaying the user details of Angular. And that's another nice benefit of routing for your users, because many users like to use those Back and Forward buttons to move between screens that they've seen.

Your Challenge

I thought that a good finale for this course would be to implement a new feature in the application, and a feature that will require us to apply all the knowledge we've learned in this course. What I'm thinking of is that it would be nice to click on the name of a repository in this table, and to drill into some details about the repository, even see who are the people who work on the code in this repository. That's what GitHub refers to as the Collaborators. To get the details of a repository from GitHub, I really need two pieces of information; the GitHub username, which GitHub data sometimes refers to as the login, and the repository name, because repositories are unique only within the context of a specific user. So we'll need to define a new route with two parameters inside, then we can create a template, then a controller. We'll need to modify our github service to make http calls to provide this new data also. You'll find out that this requires two http calls. One call will need to get the details of a repository. From here I might want to display information about the total number of open issues in the repository. You'll find that in a data member called open_issues_count. And then a second call is needed to get the collaborators for a project. I'd like to list the names of the collaborators and their gravatar images. So think about how you would implement this feature and then pause the video and give it a try yourself. It will be challenging, but it's also a good test of what you've learned. I'll give you my solution in the next clip.

My Solution

To implement the feature, I'm going to start with the route definition. So inside of app.js, let's add a third .when. I'll tell the routing engine, when it sees something like repo/:parameter username/parameter repository name, then please do the following; I want you to load a template, repo.html, and I want you to load a controller in charge of that template, the RepoController. Now you could start this off by implementing the view first, or the RepoController first. I'm going to start off with the controller, so create a new file, RepoController.js. I will need to include this script in index.html; otherwise, the controller will not be defined. So please include the script, RepoController.js, that can appear anywhere in this list as long as it is after app.js, and inside of RepoController, I'll follow the pattern of creating an IIFE, then going out and getting a reference to my githubViewer. (Typing) And ultimately what I need to do is tell that module that I'm registering a new controller, it's the RepoController, and that will be a function that I'm about to define, RepoController. So RepoController is a function that will need $scope so it can do data binding, it will need $routeParams so it can figure out what username and reponame we're searching for, and it will need the github service. Let's figure out what we're searching for first. The reponame will come from $routeParams.reponame; the username will come from $routeParams.username. Remember we need both of those pieces of information to get the details of a repository, and these names -- reponame and username, they just need to match the way you've described the parameters to the routing engine; username, reponame, all lowercase. Then, we can go up to the github service and say, ‘github, please getRepoDetails for username and reponame.' Now this is a method that is not defined on the github service as yet, we're going to need to define it, but we can assume that when that comes back, it will give us information about our repository. So I can say, .then, here's a function that will get some data, or let's build named methods instead. I've gotten the repository, or I've gotten an error. Now, there's really two ways to implement getRepoDetails. Since getting all the information that we need about the repository and its collaborators requires two $http calls, you can certainly take the approach that we took in UserController, which is, first, get the user information, and then get the repository information. So I'm making both calls by calling something on the github service and kicking off those calls from the controller itself. For the RepoController, I'd like to show you a slightly different approach, which is, I'm going to make one method call and that service is going to put together all the information I need, so that I don't have to make a second call to the github service for my controller. All I need is onRepo and onError, and then we will go over and implement what we need in the github service. So onRepo is a function that will take some data and I'll just say, $scope.repo = that incoming data, onError is a function that takes some sort of reason that that error occurred, and then we'll just say $scope.error = the reason for the error. And that's all we need in our RepoController. But this will require us to work a little bit harder inside of our github service. So I need to expose a method, getRepoDetails, that's going to be a function that takes a username and a reponame and figures out how to make all of the $http calls necessary to get all the information I need about the repository and the collaborators, and I will expose that method here as part of the public API. So getRepoDetails points to getRepoDetails. And now inside of here, I will declare a variable, a variable that represents the repository, and that variable is going to contain all the information that we need to return to whoever called this method. So ultimately, return repo is going to be the goal, but first I need to populate that object with all of the information we need. And to do that, I'm going to need to call the GitHub API Server. The place I want to go is https://api.github.com/repos/and then add in the username, and another /, and add in the reponame. And I also need to return a promise. Because all of this is going to be asynchronous, I am going to return $http.get and call that repoUrl, but I don't want to return the raw response; I want to add a .then here and have a function that will process that response on behalf of the controller. And it's inside of here where I say, "repo = response.data". So, before when we had getUser and getRepos, we did some simple processing of the response just to return response.data, and ultimately inside of a controller, when it calls .getUser.then, what the .then is waiting for is response.data. That's what we're going to return to it. But in getRepoDetails, I want to take this one step further. I don't want to return just the repository information, I want to also go out and get collaborator information and process that, and give the controller back an object that is full of information about the repository, and all the collaborators are filled in too. And so, instead of returning response.data, I'm going to return $http.get on that repoUrl again, but this time add in the /collaborators, and that's going to return another promise from this then. The beautiful thing about promises is that you can chain them together, and we've done this already. GetUser returns response.data from a then method. So a controller has to say .getUser.then, the process response.data. What I'm doing is that second .then inside of getRepoDetails, so I can process this $http response, so again, a function that takes a response, and now I have collaborator information inside of this object. So if I say "repo.collaborators = response.data", I have now taken that collaborator information and attached it to my repository object, and ultimately what I want to do is just return repo. So, chained promises can be a little bit mind-bending; we talked about this in the last module. But ultimately, what I am going to return to the caller of getRepoDetails is a promise, a promise that will either deliver an error or it's going to deliver this repo object that I've been building up. I've placed inside of that object the response to get the repository details, I've placed in that object the response that includes the collaborators details, and by placing this all inside of .then calls with return statements, I'm essentially building a bigger promise that says, I will give you a result once all of this work is done, both of the $http calls will be complete, and we will have built this entire object for you. And now my next job will be to build the template for that particular route, so ‘New file', repo.html. I know in my RepoController, I will now have access to all of that information that the github service put together. So inside of repo.html, what are the things that I might want to display? Well I might want to display repo.name inside of a header, so it's really clear what we're looking at. I also said that I wanted to display the count of open issues, so give me a div tag that says, "Issues: {{repo.open_issues_count}}". And then I want to display the collaborators, so put that inside of another div. There are multiple collaborators, so perhaps an unordered list would be nice here. And I need to create a list item for each collaborator, so ng-repeat. ng-repeat, let's use the expression for each user in repo.collaborators, which I always have to pronounce funny to make sure that I spell it correctly. Inside of here I want to display the user's name, which in the particular data structure that comes back when you get collaborators, that is the login property, so user.login, but I also want to display their gravatar, which is available, and we've done this before. I need an image whose source references www.gravatar.com/avatar/and then the user.gravatar_id. We could make the alt tag the user.login also. And then it might be nice to provide some links to get back to the Search page, so a link to go to #/main, we'll say "Back to search", and perhaps a link to get back to the userDetails, so #/user/, and here I will have to say repo.owner.login, that's a particular data structure inside the repository details that will give you the name of the user. And here I could say, "Back to {{repo.owner.login}}". So now I have links from this view to go back to other places in the application. The last thing we need to do, I think, is inside of user.html, instead of just displaying the repository name, I need a link to go to this new feature. So an anchor tag whose href is "#/repo/{{user.login}}/{{repo.name}}", and it will display the text, repo.name. So if we've done everything correctly, I should be able to launch a preview, let's launch it in an external window again, do a Search for Angular, and I'll see that I have hyperlinks that I can click to see the details of the repository. I can see the number of open issues, I can see a list of the collaborators along with their pictures, and I have links at the bottom. I can go back to the Search page, or I can go back to the Angular user itself.

Summary

This concludes my course on learning Angular. We saw how Angular is a framework for building applications with HTML and we took a look at the primary components involved, including Controllers, Models, Views, and Services. And in this module, we looked at Routing in detail. The primary takeaways for Routing are that Routing allows you to build navigation into your application and it also allows you to build an application from smaller pieces. You can divide responsibility for your features amongst multiple controllers, models, views, and services. Now I encourage you to keep building applications with Angular, do some experiments, try some of the other Pluralsight courses on AngularJS, and look at unit testing. As an application grows, the tests that you write will make sure everything keeps working together.

Course author

	
Scott Allen

 Scott has over 15 years of experience in commercial software
 development and is a frequent speaker at national conferences,
 and local user groups. Scott is a Microsoft...
Course info

LevelBeginner
Rating
(11219)
My rating
Duration2h 58m
Released6 Jun 2014
Add to playlist
Share course

